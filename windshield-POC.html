<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Snowflakes / Stars — Vanishing Point Field</title>
<style>
  :root{ --bg:#000; --fg:#e8eef5; --muted:#9aa1ad; --accent:#5ac8fa; }
  html,body{height:100%;margin:0}
  body{background:var(--bg);color:var(--fg);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;overflow:hidden}
  canvas{display:block;width:100vw;height:100svh;touch-action:none}
  .hud{position:fixed;left:12px;top:10px;padding:.35rem .5rem;border-radius:.5rem;background:rgba(0,0,0,.35);backdrop-filter:blur(4px);font-weight:600;letter-spacing:.02em;color:var(--fg);user-select:none;pointer-events:none}
  .hud .small{display:block;opacity:.7;font-weight:500;font-size:.8em}
  /* iOS permission nudge (only shown if absolutely needed) */
  #perm{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.6)}
  #perm button{appearance:none;border:0;border-radius:.75rem;padding:.8rem 1rem;background:#fff;color:#000;font-weight:700}
</style>
</head>
<body>
  <canvas id="stage" aria-hidden="true"></canvas>
  <div class="hud" id="hud">
    <span class="small">Direction</span>
    <span id="dirTxt">North</span>
  </div>
  <div id="perm"><button id="permBtn">Enable motion sensors</button></div>
<script>
(() => {
  const canvas = document.getElementById('stage');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  const dirTxt = document.getElementById('dirTxt');
  const perm = document.getElementById('perm');
  const permBtn = document.getElementById('permBtn');

  // DPR-aware sizing
  let DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
  let W=0,H=0,CX=0,CY=0;
  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    const cssW = Math.max(1, Math.round(window.innerWidth));
    const cssH = Math.max(1, Math.round(window.innerHeight));
    canvas.width = Math.floor(cssW * DPR);
    canvas.height = Math.floor(cssH * DPR);
    canvas.style.width = cssW + 'px';
    canvas.style.height = cssH + 'px';
    W = canvas.width; H = canvas.height; CX = W*0.5; CY = H*0.5;
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // ------------------------------------------------------------------------------------------
  // SENSOR PIPELINE
  // ------------------------------------------------------------------------------------------
  let headingDeg = 0; // 0° = North; clockwise
  let pitchDeg = 0;   // forward/back tilt
  let rollDeg = 0;    // left/right tilt

  function bearingToText(b){
    b = (b%360+360)%360;
    const names = ['North','NNE','NE','ENE','East','ESE','SE','SSE','South','SSW','SW','WSW','West','WNW','NW','NNW'];
    return names[Math.round(b/22.5)%16];
  }
  function updateHUD(){ dirTxt.textContent = bearingToText(headingDeg); }

  function handleDO(e){
    const { alpha, beta, gamma } = e;
    if (typeof alpha === 'number' && isFinite(alpha)) headingDeg = (360 - alpha + 90) % 360; // compass-ish
    if (typeof beta === 'number' && isFinite(beta)) pitchDeg = beta;
    if (typeof gamma === 'number' && isFinite(gamma)) rollDeg = gamma;
    updateHUD();
  }

  // Try permissions only when the platform requires it (iOS 13+)
  async function ensureMotionPermission(){
    try{
      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function'){
        perm.style.display = 'flex';
        permBtn.onclick = async () => {
          try{
            const res = await DeviceOrientationEvent.requestPermission();
            if (res === 'granted'){
              addEventListener('deviceorientation', handleDO, true);
              perm.style.display = 'none';
            }
          }catch(_){/* ignore */}
        };
      } else {
        // Non-iOS: just listen
        addEventListener('deviceorientation', handleDO, true);
      }
    }catch(_){/* ignore */}
  }
  ensureMotionPermission();
  updateHUD();

  // ------------------------------------------------------------------------------------------
  // STARFIELD ENGINE (true 3D -> perspective -> vanishing point)
  // Robust even with zero sensors.
  // ------------------------------------------------------------------------------------------
  const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const COUNT = isMobile ? 600 : 1200;
  const FOV = 450; // larger = weaker perspective
  const SPEED = 1.3; // base z velocity units/s
  const stars = new Float32Array(COUNT * 3); // x,y,z in normalized cube [-1,1]

  function rnd(){ return Math.random()*2-1; }
  function respawn(i){
    const idx = i*3;
    // Spawn near the center so streaks originate at vanishing point
    const r = Math.pow(Math.random(), 2) * 0.25; // bias towards small radius
    const t = Math.random()*Math.PI*2;
    stars[idx]   = Math.cos(t)*r;
    stars[idx+1] = Math.sin(t)*r;
    stars[idx+2] = 1.0; // far away; moves towards 0
  }
  for (let i=0;i<COUNT;i++) respawn(i);

  let last = performance.now();

  function loop(now){
    const dt = Math.min(0.035, (now - last)/1000);
    last = now;

    // Compute transforms
    const rot = (headingDeg||0) * Math.PI/180; // rotate around Z to align with heading
    const cosR = Math.cos(rot), sinR = Math.sin(rot);

    // Shift vanishing point subtly with tilt
    const vpX = CX + (rollDeg/45) * (W*0.06);
    const vpY = CY + (pitchDeg/45) * (H*0.06);

    // Motion blur / persistence
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,W,H);

    ctx.globalCompositeOperation = 'lighter';
    ctx.strokeStyle = '#fff';
    ctx.lineCap = 'round';

    for (let i=0;i<COUNT;i++){
      const idx = i*3;
      let x = stars[idx];
      let y = stars[idx+1];
      let z = stars[idx+2];

      // Previous projected screen point
      const pz = z + 0.001;
      const pp = FOV / (FOV + pz*W*0.5);
      const px = (x*cosR - y*sinR) * pp * W + vpX;
      const py = (x*sinR + y*cosR) * pp * W + vpY;

      // Advance towards viewer
      z -= (SPEED + z*0.8) * dt; // accelerate as it approaches

      // Current projection
      const p = FOV / (FOV + z*W*0.5);
      const sx = (x*cosR - y*sinR) * p * W + vpX;
      const sy = (x*sinR + y*cosR) * p * W + vpY;

      // Line width grows with approach speed
      const w = Math.max(0.6*DPR, Math.min(4*DPR, (1 - z) * 2));
      ctx.lineWidth = w;
      ctx.beginPath();
      ctx.moveTo(px, py);
      ctx.lineTo(sx, sy);
      ctx.stroke();

      // Off-screen or passed camera => respawn
      if (z <= 0.02 || sx < -20 || sx > W+20 || sy < -20 || sy > H+20){
        respawn(i);
      } else {
        stars[idx+2] = z;
      }
    }

    requestAnimationFrame(loop);
  }

  // Initialize clear
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
