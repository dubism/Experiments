<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>North Stream Debug HUD</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font:14px system-ui;overflow:hidden}
  canvas{display:block;width:100vw;height:100svh;touch-action:none}
  .hud{position:fixed;left:0;bottom:0;right:0;background:rgba(0,0,0,.65);backdrop-filter:blur(6px);padding:.5rem;display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:.5rem;font-size:13px}
  .hud label{display:flex;flex-direction:column;font-weight:600}
  .hud input[type=range]{width:100%}
</style>
</head>
<body>
  <canvas id="stage"></canvas>
  <div class="hud">
    <label>Count<input id="count" type="range" min="100" max="5000" value="1600"></label>
    <label>Speed<input id="speed" type="range" min="1" max="100" value="30"></label>
    <label>Spread<input id="spread" type="range" step="0.1" min="0.1" max="2.5" value="0.9"></label>
    <label>FocalLen<input id="focal" type="range" min="200" max="2000" value="950"></label>
    <label>Trail<input id="trail" type="range" min="1" max="50" value="18"></label>
  </div>
<script>
(() => {
  const canvas=document.getElementById('stage');
  const ctx=canvas.getContext('2d',{alpha:false,desynchronized:true});
  let DPR=1,W=0,H=0,CX=0,CY=0;
  function resize(){
    DPR=Math.max(1,Math.min(3,devicePixelRatio||1));
    const cssW=Math.round(innerWidth), cssH=Math.round(innerHeight);
    canvas.width=cssW*DPR; canvas.height=cssH*DPR;
    canvas.style.width=cssW+'px'; canvas.style.height=cssH+'px';
    W=canvas.width; H=canvas.height; CX=W/2; CY=H/2;
  }
  addEventListener('resize',resize);resize();

  // controls
  const ctrl={
    count:1600,
    speed:30,
    spread:0.9,
    focal:950,
    trail:18
  };
  for (const k in ctrl){
    document.getElementById(k).addEventListener('input',e=>{ctrl[k]=parseFloat(e.target.value);if(k==='count')resetStars();});
  }

  // math utils
  const TAU=Math.PI*2; const deg2rad=d=>d*Math.PI/180;
  const norm=v=>{const m=Math.hypot(v[0],v[1],v[2])||1;return[v[0]/m,v[1]/m,v[2]/m];};
  const cross=(a,b)=>[a[1]*b[2]-a[2]*b[1],a[2]*b[0]-a[0]*b[2],a[0]*b[1]-a[1]*b[0]];
  function mul3(A,B){const r=new Array(9);for(let rI=0;rI<3;rI++)for(let c=0;c<3;c++)r[rI*3+c]=A[rI*3+0]*B[0*3+c]+A[rI*3+1]*B[1*3+c]+A[rI*3+2]*B[2*3+c];return r;}
  function mul3Tv(R,v){return[ R[0]*v[0]+R[3]*v[1]+R[6]*v[2], R[1]*v[0]+R[4]*v[1]+R[7]*v[2], R[2]*v[0]+R[5]*v[1]+R[8]*v[2] ];}
  function rotWorldToDevice(yaw,pitch,roll){const z=deg2rad(yaw),x=deg2rad(pitch),y=deg2rad(roll);const cz=Math.cos(z),sz=Math.sin(z),cx=Math.cos(x),sx=Math.sin(x),cy=Math.cos(y),sy=Math.sin(y);const Rz=[cz,-sz,0, sz,cz,0, 0,0,1];const Rx=[1,0,0, 0,cx,-sx, 0,sx,cx];const Ry=[cy,0,sy, 0,1,0, -sy,0,cy];return mul3(mul3(Rz,Rx),Ry);}

  // stars
  let stars; function resetStars(){stars=new Float32Array(ctrl.count*3);for(let i=0;i<ctrl.count;i++)spawn(i,Nd);}
  function spawn(i,Nd){const idx=i*3;let tmp=Math.abs(Nd[1])<0.9?[0,1,0]:[1,0,0];let U=norm(cross(tmp,Nd));let V=norm(cross(Nd,U));const r=(Math.random()**1.4)*ctrl.spread;const t=Math.random()*TAU;const j=[U[0]*r*Math.cos(t)+V[0]*r*Math.sin(t),U[1]*r*Math.cos(t)+V[1]*r*Math.sin(t),U[2]*r*Math.cos(t)+V[2]*r*Math.sin(t)];const FAR=80;stars[idx]=Nd[0]*FAR+j[0];stars[idx+1]=Nd[1]*FAR+j[1];stars[idx+2]=Nd[2]*FAR+j[2];}

  // sensor state
  let headingDeg=0,pitchDeg=0,rollDeg=0;
  function handleDO(e){if(typeof e.webkitCompassHeading==='number')headingDeg=e.webkitCompassHeading; else if(isFinite(e.alpha))headingDeg=(360-e.alpha)%360; if(isFinite(e.beta))pitchDeg=e.beta; if(isFinite(e.gamma))rollDeg=e.gamma;}
  if(typeof DeviceOrientationEvent!=='undefined'&&typeof DeviceOrientationEvent.requestPermission==='function'){
    DeviceOrientationEvent.requestPermission().then(r=>{if(r==='granted')addEventListener('deviceorientation',handleDO,true);}).catch(()=>{});
  } else addEventListener('deviceorientation',handleDO,true);

  // init
  let last=performance.now();
  let Nd=[0,1,0];
  resetStars();

  function loop(now){
    const dt=Math.min(0.05,(now-last)/1000);last=now;
    // update Nd from sensors
    const Rwd=rotWorldToDevice(headingDeg,pitchDeg,rollDeg);
    Nd=norm(mul3Tv(Rwd,[0,1,0]));

    ctx.fillStyle='rgba(0,0,0,0.2)';ctx.fillRect(0,0,W,H);
    ctx.strokeStyle='#fff';ctx.lineCap='round';ctx.globalCompositeOperation='lighter';

    for(let i=0;i<ctrl.count;i++){
      const idx=i*3;let x=stars[idx],y=stars[idx+1],z=stars[idx+2];
      const inv1=ctrl.focal/(ctrl.focal+z*DPR);const px=x*inv1*DPR+CX;const py=y*inv1*DPR+CY;
      x-=Nd[0]*ctrl.speed*dt;y-=Nd[1]*ctrl.speed*dt;z-=Nd[2]*ctrl.speed*dt;
      const inv2=ctrl.focal/(ctrl.focal+z*DPR);const sx=x*inv2*DPR+CX;const sy=y*inv2*DPR+CY;
      const dx=sx-px,dy=sy-py;const depthFactor=Math.max(0,Math.min(1,1-z/80));
      const k=ctrl.trail*depthFactor;const tx=sx-dx*k,ty=sy-dy*k;
      const w=Math.max(0.5*DPR,Math.min(5*DPR,0.6+depthFactor*4));
      ctx.lineWidth=w;ctx.beginPath();ctx.moveTo(tx,ty);ctx.lineTo(sx,sy);ctx.stroke();
      if(z<0.5||sx<-100||sx>W+100||sy<-100||sy>H+100)spawn(i,Nd); else{stars[idx]=x;stars[idx+1]=y;stars[idx+2]=z;}
    }
    requestAnimationFrame(loop);
  }
  ctx.fillStyle='#000';ctx.fillRect(0,0,canvas.width,canvas.height);requestAnimationFrame(loop);
})();
</script>
</body>
</html>
