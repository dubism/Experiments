<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Live Camera Palette — Square Crop</title>
<style>
  :root{
    --bg:#000; --ink:#fff; --muted:#bdbdbd; --line:#222; --zoom:1;
    --controlsH:92px; /* JS updates */
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;user-select:none}

  /* Bands */
  #videoPane{position:fixed;left:0;right:0;top:0;height:42vh;display:flex;align-items:center;justify-content:center;border-bottom:1px solid var(--line);background:#000;overflow:hidden}
  #palettePane{
    position:fixed;left:0;right:0;top:42vh;height:42vh;
    display:flex;flex-direction:column;gap:10px;
    padding:10px 12px calc(14px + var(--controlsH) + env(safe-area-inset-bottom));
    background:#000;border-bottom:1px solid var(--line)
  }
  #controlsBar{
    position:fixed;left:0;right:0;bottom:0;
    border-top:1px solid var(--line);background:#000;
    padding:10px 12px calc(8px + env(safe-area-inset-bottom));
  }

  /* Camera */
  .videoWrap{position:relative;display:flex;align-items:center;justify-content:center;width:100%;height:100%}
  video{max-height:40vh;max-width:92vw;border-radius:12px;background:#000;display:block;transform:scale(var(--zoom));transform-origin:center}
  #frozenCanvas{position:absolute;inset:0;margin:auto;display:none;max-height:40vh;max-width:92vw;border-radius:12px}

  /* Palette title */
  .title{display:flex;align-items:center;justify-content:space-between;color:var(--muted)}

  /* Palette containers (responsive height via JS) */
  .stack{display:flex;flex-direction:column;gap:10px;min-height:0;flex:1}
  .swatches,.gradient{border:1px solid var(--line);border-radius:14px;overflow:hidden;min-height:60px}
  .swatches{display:flex}
  .swatch{flex:1}
  .gradient{display:block}

  /* Control Center overlay (lifted above bottom bar) */
  #ccWrap{position:absolute;left:12px;right:12px;bottom:calc(12px + var(--controlsH) + env(safe-area-inset-bottom));display:none;z-index:10}
  #cc{background:rgba(0,0,0,.6);backdrop-filter:blur(6px);border:1px solid var(--line);border-radius:14px;padding:12px;display:grid;gap:12px}
  #cc .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
  .small{font-variant-numeric:tabular-nums;color:var(--muted)}

  /* Bottom single row: tabs | zoom | controls + FREEZE */
  .bar{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .tabs{display:flex;gap:8px;flex-wrap:wrap}
  .flex{flex:1 1 220px;min-width:160px}

  .tab{padding:10px 14px;background:rgba(255,255,255,.06);border:1px solid var(--line);color:#fff;border-radius:12px;cursor:pointer;white-space:nowrap}
  .tab.active{outline:2px solid #fff;outline-offset:1px}

  /* Zoom: thick with – / + */
  .zoomWrap{display:flex;align-items:center;gap:10px;width:100%}
  .zbtn{width:40px;height:40px;border-radius:50%;border:1px solid var(--line);background:#121212;color:#fff;font-size:22px;line-height:0;display:flex;align-items:center;justify-content:center;cursor:pointer}
  input[type="range"].zoom{appearance:none;-webkit-appearance:none;width:100%;height:14px;border-radius:999px;background:#1a1a1a;outline:none}
  input[type="range"].zoom::-webkit-slider-thumb{appearance:none;-webkit-appearance:none;width:28px;height:28px;border-radius:50%;background:#fff;border:none;cursor:pointer;margin-top:-7px}
  input[type="range"].zoom::-webkit-slider-runnable-track{height:14px;border-radius:999px;background:#2b2b2b}
  input[type="range"].zoom::-moz-range-thumb{width:28px;height:28px;border:none;border-radius:50%;background:#fff;cursor:pointer}
  input[type="range"].zoom::-moz-range-track{height:14px;border-radius:999px;background:#2b2b2b}

  .btn{padding:12px 18px;border:1px solid var(--line);border-radius:12px;background:#0d0d0d;color:#fff;cursor:pointer}
  .btn.cta{background:#fff;color:#000;font-weight:900;border-color:#fff;font-size:18px;padding:14px 22px}

  /* Composite overlay */
  #compositeOverlay{position:fixed;inset:0;background:#000;z-index:1000;display:none;align-items:center;justify-content:center;flex-direction:column;gap:12px;padding:10px}
  #compositeOverlay.open{display:flex}
  #compositeCanvas{max-width:98vw;max-height:94vh;background:#000;border:none}
  #unfreezeBtn{position:fixed;right:12px;bottom:12px}
</style>
</head>
<body>
  <!-- CAMERA -->
  <section id="videoPane">
    <div class="videoWrap">
      <video id="video" playsinline muted></video>
      <canvas id="frozenCanvas"></canvas>
    </div>
  </section>

  <!-- PALETTE -->
  <section id="palettePane">
    <div class="title">
      <div id="algoName" class="small">K-Means (LAB)</div>
      <div class="small">FPS <span id="fps">0</span> · <span id="res">–</span> · <span id="status">Waiting…</span></div>
    </div>
    <div class="stack">
      <div id="swatches" class="swatches"></div>
      <div id="gradient" class="gradient" hidden></div>
    </div>

    <!-- Controls overlay -->
    <div id="ccWrap">
      <div id="cc">
        <div class="row"><span>Colors (K)</span><span><input type="range" id="k" min="2" max="10" value="3"><span id="kVal" class="small">3</span></span></div>
        <div class="row"><span>Show rectangles</span><input type="checkbox" id="rects" checked></div>
        <div class="row"><span>Show gradient</span><input type="checkbox" id="grad"></div>
        <div class="row"><span>Processing width</span><span><input type="range" id="size" min="120" max="360" step="20" value="240"><span id="sizeVal" class="small">240 px</span></span></div>
        <div class="row"><span>Process every N frames</span><span>
          <input type="range" id="throttleLog" min="0" max="100" value="0"><span id="throttleVal" class="small">20</span></span>
        </div>
      </div>
    </div>
  </section>

  <!-- CONTROLS BAR: tabs | zoom | controls + FREEZE -->
  <section id="controlsBar">
    <div class="bar" id="bar">
      <div class="tabs" id="tabs">
        <button class="tab active" data-algo="kmeans">K-Means</button>
        <button class="tab" data-algo="hist">Histogram</button>
        <button class="tab" data-algo="mediancut">Median-cut</button>
      </div>

      <div class="flex">
        <div class="zoomWrap">
          <button class="zbtn" id="zoomMinus" aria-label="Zoom out">−</button>
          <input type="range" id="zoom" class="zoom" min="1" max="10" step="0.01" value="1">
          <button class="zbtn" id="zoomPlus" aria-label="Zoom in">+</button>
        </div>
      </div>

      <button class="btn" id="ccToggle">Controls</button>
      <button class="btn cta" id="freezeBtn">FREEZE</button>
    </div>
  </section>

  <!-- COMPOSITE -->
  <div id="compositeOverlay">
    <canvas id="compositeCanvas"></canvas>
    <button class="btn cta" id="unfreezeBtn">UNFREEZE</button>
  </div>

  <canvas id="off"></canvas>
  <canvas id="capFrame"></canvas>

<script>
/* ---------- Measure bottom height for safe padding ---------- */
const controlsBar = document.getElementById('bar');
function updateControlsH(){
  const h = controlsBar.getBoundingClientRect().height;
  document.documentElement.style.setProperty('--controlsH', Math.round(h) + 'px');
}
addEventListener('load', updateControlsH);
addEventListener('resize', updateControlsH);
addEventListener('orientationchange', updateControlsH);

/* ---------- Worker (algorithms) ---------- */
const workerBlob = new Blob([`
self.onmessage = (e)=> {
  const {pixels,width,height,algo,k,stride=2} = e.data;
  const data = new Uint8ClampedArray(pixels);
  const samples = [];
  for(let y=0;y<height;y+=stride){
    let row=y*width*4;
    for(let x=0;x<width;x+=stride){
      const i=row+x*4; samples.push(data[i],data[i+1],data[i+2]);
    }
  }
  let palette;
  if (algo==='hist') palette = histPalette(samples,k);
  else if (algo==='mediancut') palette = medianCutPalette(samples,k);
  else palette = kmeansLAB(samples,k,6);
  palette = dedupeAndSort(palette,10);
  const out = new Uint8Array(palette.flat());
  self.postMessage({palette: out.buffer}, [out.buffer]);
};
function rgb2xyz(r,g,b){
  r/=255; g/=255; b/=255;
  r=r<=0.04045?r/12.92:((r+0.055)/1.055)**2.4;
  g=g<=0.04045?g/12.92:((g+0.055)/1.055)**2.4;
  b=b<=0.04045?b/12.92:((b+0.055)/1.055)**2.4;
  return [ r*0.4124 + g*0.3576 + b*0.1805,
           r*0.2126 + g*0.7152 + b*0.0722,
           r*0.0193 + g*0.1192 + b*0.9505 ];
}
function xyz2lab(x,y,z){
  const Xr=0.95047,Yr=1,Zr=1.08883;
  const f=t=>t>0.008856?Math.cbrt(t):7.787*t+16/116;
  const fx=f(x/Xr), fy=f(y/Yr), fz=f(z/Zr);
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}
function rgb2lab(r,g,b){const [x,y,z]=rgb2xyz(r,g,b);return xyz2lab(x,y,z);}
function dE76(L1,a1,b1,L2,a2,b2){const dL=L1-L2,da=a1-a2,db=b1-b2;return Math.hypot(dL,da,db);}
function histPalette(samples,k){
  const bins=new Uint32Array(512);
  for(let i=0;i<samples.length;i+=3){
    const r=samples[i]>>5,g=samples[i+1]>>5,b=samples[i+2]>>5;
    bins[(r<<6)|(g<<3)|b]++;
  }
  const idx=[...bins.keys()].sort((a,b)=>bins[b]-bins[a]).slice(0,k);
  return idx.map(code=>{
    const r=(code>>6)&7,g=(code>>3)&7,b=code&7;
    return [r*32+16,g*32+16,b*32+16];
  });
}
function medianCutPalette(samples,k){
  const colors=[]; for(let i=0;i<samples.length;i+=3) colors.push([samples[i],samples[i+1],samples[i+2]]);
  let boxes=[{colors}];
  const bounds=b=>{
    b.r=[255,0]; b.g=[255,0]; b.b=[255,0];
    for(const c of b.colors){
      if(c[0]<b.r[0])b.r[0]=c[0]; if(c[0]>b.r[1])b.r[1]=c[0];
      if(c[1]<b.g[0])b.g[0]=c[1]; if(c[1]>b.g[1])b.g[1]=c[1];
      if(c[2]<b.b[0])b.b[0]=c[2]; if(c[2]>b.b[1])b.b[1]=c[2];
    }
  };
  boxes.forEach(bounds);
  const range=b=>Math.max(b.r[1]-b.r[0],b.g[1]-b.g[0],b.b[1]-b.b[0]);
  const axis=b=>{
    const rs=[b.r[1]-b.r[0],b.g[1]-b.g[0],b.b[1]-b.b[0]];
    return rs.indexOf(Math.max(...rs));
  };
  while(boxes.length<k){
    boxes.sort((A,B)=>range(B)-range(A));
    const big=boxes.shift(); if(!big||big.colors.length<=1) break;
    const ax=axis(big);
    big.colors.sort((a,b)=>a[ax]-b[ax]);
    const mid=big.colors.length>>1;
    const left={colors:big.colors.slice(0,mid)}, right={colors:big.colors.slice(mid)};
    [left,right].forEach(bounds); boxes.push(left,right);
  }
  return boxes.map(b=>{
    let r=0,g=0,bl=0,n=b.colors.length||1;
    for(const c of b.colors){r+=c[0];g+=c[1];bl+=c[2];}
    return [r/n|0,g/n|0,bl/n|0];
  }).slice(0,k);
}
function kmeansLAB(samples,k,maxIter=6){
  const pts=[];
  for(let i=0;i<samples.length;i+=3){
    const r=samples[i],g=samples[i+1],b=samples[i+2];
    const L=rgb2lab(r,g,b);
    pts.push([L[0],L[1],L[2],r,g,b]);
  }
  const centers=[]; centers.push(pts[(Math.random()*pts.length)|0].slice(0,3));
  while(centers.length<k){
    const d2=pts.map(p=>Math.min(...centers.map(c=>d2lab(p,c))));
    const sum=d2.reduce((a,b)=>a+b,0)||1;
    let r=Math.random()*sum,i=0; for(;i<d2.length-1&&(r-=d2[i])>0;i++); centers.push(pts[i].slice(0,3));
  }
  const labels=new Uint16Array(pts.length);
  for(let it=0;it<maxIter;it++){
    for(let i=0;i<pts.length;i++){
      let best=0,bd=1e9;
      for(let c=0;c<centers.length;c++){
        const d=d2lab(pts[i],centers[c]); if(d<bd){bd=d;best=c;}
      }
      labels[i]=best;
    }
    const sums=Array.from({length:k},()=>[0,0,0,0]);
    for(let i=0;i<pts.length;i++){
      const c=labels[i],p=pts[i];
      sums[c][0]+=p[0];sums[c][1]+=p[1];sums[c][2]+=p[2];sums[c][3]++;
    }
    for(let c=0;c<k;c++) if(sums[c][3]>0){
      centers[c][0]=sums[c][0]/sums[c][3];
      centers[c][1]=sums[c][1]/sums[c][3];
      centers[c][2]=sums[c][2]/sums[c][3];
    }
  }
  const acc=Array.from({length:k},()=>[0,0,0,0]);
  for(let i=0;i<pts.length;i++){
    const c=labels[i],p=pts[i];
    acc[c][0]+=p[3];acc[c][1]+=p[4];acc[c][2]+=p[5];acc[c][3]++;
  }
  const out=[]; for(let c=0;c<k;c++) if(acc[c][3]>0)
    out.push([acc[c][0]/acc[c][3]|0,acc[c][1]/acc[c][3]|0,acc[c][2]/acc[c][3]|0]);
  while(out.length<k) out.push(out[out.length-1]||[128,128,128]);
  return out.slice(0,k);
  function d2lab(p,c){const d0=p[0]-c[0],d1=p[1]-c[1],d2=p[2]-c[2];return d0*d0+d1*d1+d2*d2;}
}
function dedupeAndSort(rgbList,minDE=10){
  const labList=rgbList.map(([r,g,b])=>{const L=rgb2lab(r,g,b);return [L[0],L[1],L[2],r,g,b];});
  labList.sort((a,b)=>a[0]-b[0]);
  const kept=[];
  for(const c of labList){
    let ok=true; for(const d of kept){ if(dE76(c[0],c[1],c[2],d[0],d[1],d[2])<minDE){ok=false;break;} }
    if(ok) kept.push(c);
  }
  return kept.map(c=>[c[3],c[4],c[5]]);
}
`], {type:'application/javascript'});
const worker = new Worker(URL.createObjectURL(workerBlob), {type:'module'});

/* ---------- Elements ---------- */
const video = document.getElementById('video');
const frozenCanvas = document.getElementById('frozenCanvas');
const off = document.getElementById('off');
const capFrame = document.getElementById('capFrame');

const tabs = document.getElementById('tabs');
const algoName = document.getElementById('algoName');
const statusEl = document.getElementById('status');
const fpsEl = document.getElementById('fps');
const resEl = document.getElementById('res');

const swatchesEl = document.getElementById('swatches');
const gradientEl = document.getElementById('gradient');

const ccToggle = document.getElementById('ccToggle');
const ccWrap = document.getElementById('ccWrap');

const kRange = document.getElementById('k'); const kVal = document.getElementById('kVal');
const sizeRange = document.getElementById('size'); const sizeVal = document.getElementById('sizeVal');
const throttleLog = document.getElementById('throttleLog'); const throttleVal = document.getElementById('throttleVal');
const rectChk = document.getElementById('rects'); const gradChk = document.getElementById('grad');

const zoomSlider = document.getElementById('zoom');
const zoomMinus = document.getElementById('zoomMinus');
const zoomPlus  = document.getElementById('zoomPlus');

const freezeBtn = document.getElementById('freezeBtn');

const compositeOverlay = document.getElementById('compositeOverlay');
const compositeCanvas = document.getElementById('compositeCanvas');
const unfreezeBtn = document.getElementById('unfreezeBtn');

/* ---------- State ---------- */
let algo = 'kmeans';
let K = +kRange.value;             // 3
let procWidth = +sizeRange.value;  // 240
let throttleN = 20;                // default
let uiZoom = +zoomSlider.value;    // 1

let frameCounter = 0, lastT = performance.now();
let pending = false, every = 0;
let running = true;

let lastPalette = [];
let lastHexes = [];

/* ---------- Helpers ---------- */
const TH_MIN=1, TH_MAX=150;
function nToSlider(n){ return Math.round(Math.log(n/TH_MIN)/Math.log(TH_MAX/TH_MIN)*100); }
function sliderToN(v){ return Math.max(TH_MIN, Math.min(TH_MAX, Math.round(TH_MIN * Math.exp((v/100)*Math.log(TH_MAX/TH_MIN))))); }
throttleLog.value = nToSlider(throttleN);
throttleVal.textContent = String(throttleN);
throttleLog.addEventListener('input', ()=>{ throttleN = sliderToN(+throttleLog.value); throttleVal.textContent = String(throttleN); });

tabs.addEventListener('click', (e)=>{
  const btn = e.target.closest('.tab'); if(!btn) return;
  document.querySelectorAll('.tab').forEach(b=>b.classList.toggle('active', b===btn));
  algo = btn.dataset.algo; algoName.textContent = btn.textContent + (algo==='kmeans'?' (LAB)':'');
});
kRange.addEventListener('input', ()=>{ K = +kRange.value; kVal.textContent = K; forceRender(); });
sizeRange.addEventListener('input', ()=>{ procWidth = +sizeRange.value; sizeVal.textContent = procWidth+' px'; });
rectChk.addEventListener('change', ()=> forceRender());
gradChk.addEventListener('change', ()=> forceRender());

ccToggle.addEventListener('click', ()=>{ ccWrap.style.display = ccWrap.style.display ? '' : 'block'; });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ ccWrap.style.display=''; if (!running) unfreeze(); } });

function setZoom(v){ uiZoom = Math.max(1, Math.min(10, v)); zoomSlider.value = uiZoom; document.documentElement.style.setProperty('--zoom', uiZoom); }
zoomSlider.addEventListener('input', ()=> setZoom(+zoomSlider.value));
zoomMinus.addEventListener('click', ()=> setZoom(+zoomSlider.value - 0.25));
zoomPlus .addEventListener('click', ()=> setZoom(+zoomSlider.value + 0.25));

freezeBtn.addEventListener('click', async ()=>{ if (running) await freezeNow(); });
unfreezeBtn.addEventListener('click', ()=> unfreeze());

window.addEventListener('resize', ()=>{ updateControlsH(); if (!running) renderCompositeFullscreen(lastHexes, capFrame.width, capFrame.height, rectChk.checked, gradChk.checked); });

/* ---------- Crop (square + zoom) ---------- */
function computeSquareCrop(){
  const vw = video.videoWidth || 0, vh = video.videoHeight || 0;
  if (!vw || !vh) return {sx:0,sy:0,sw:0,sh:0};
  const z = Math.max(1, uiZoom);
  const base = Math.min(vw, vh);
  const sw = Math.round(base / z), sh = sw;
  const sx = Math.floor((vw - sw)/2), sy = Math.floor((vh - sh)/2);
  return {sx, sy, sw, sh};
}

/* ---------- Camera init ---------- */
(async function init(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    video.srcObject = stream;
    await video.play();
    status('Live'); updateControlsH(); loop();
  }catch(err){ status('Camera failed: '+err.message); }
})();

/* ---------- Main loop ---------- */
function loop(){
  requestAnimationFrame(loop);
  if(video.readyState < 2) return;

  const now = performance.now();
  if (now - lastT >= 1000){ fpsEl.textContent = String(frameCounter); frameCounter = 0; lastT = now; }

  const {sx,sy,sw,sh} = computeSquareCrop(); if (!sw) return;

  // downscale to processing width
  const scale = procWidth / sw, w = Math.max(2, Math.round(sw * scale)), h = w;
  off.width = w; off.height = h;
  const ctx = off.getContext('2d', {willReadFrequently:true});
  if (running){ ctx.drawImage(video, sx, sy, sw, sh, 0, 0, w, h); }
  resEl.textContent = w + '×' + h;

  if (!running) return;
  every = (every+1) % throttleN; if (every!==0) return;
  if (!pending){
    pending = true;
    const img = ctx.getImageData(0,0,w,h);
    worker.postMessage({pixels:img.data.buffer, width:w, height:h, algo, k:K, stride:2}, [img.data.buffer]);
  }
}

/* ---------- Worker response ---------- */
worker.onmessage = (e)=>{
  const arr = new Uint8Array(e.data.palette||[]);
  const cols = []; for(let i=0;i<arr.length;i+=3) cols.push([arr[i],arr[i+1],arr[i+2]]);
  while(cols.length < K) cols.push(cols[cols.length-1] || [128,128,128]);
  lastPalette = cols.slice(0,K);
  renderPalette(lastPalette);
  pending = false; frameCounter++;
};

/* ---------- Render palette (handles toggles + responsive heights) ---------- */
function toHex([r,g,b]){ return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
function forceRender(){ renderPalette(lastPalette); }

function renderPalette(palette){
  const stack = document.querySelector('.stack');
  if(!palette || !palette.length){ swatchesEl.innerHTML=''; gradientEl.hidden=true; return; }
  lastHexes = palette.map(toHex);

  // reset backgrounds to avoid “stuck” feel after toggle cycles
  gradientEl.style.background = '';
  swatchesEl.style.display = 'none';
  gradientEl.hidden = true;

  const wantRects = rectChk.checked;
  const wantGrad  = gradChk.checked;

  // Rectangles
  swatchesEl.innerHTML = '';
  if (wantRects){
    swatchesEl.style.display = 'flex';
    for(const h of lastHexes){ const d=document.createElement('div'); d.className='swatch'; d.style.background=h; swatchesEl.appendChild(d); }
  }

  // Gradient
  if (wantGrad){
    gradientEl.hidden = false;
    const stops = lastHexes.map((c,i)=>`${c} ${(i/(lastHexes.length-1))*100}%`).join(',');
    gradientEl.style.background = `linear-gradient(90deg, ${stops})`;
  }

  // Responsive vertical usage
  if (wantRects && wantGrad){
    swatchesEl.style.minHeight = '60px';
    gradientEl.style.minHeight = '60px';
    swatchesEl.style.flex = '1';
    gradientEl.style.flex = '1';
  } else if (wantRects){
    swatchesEl.style.flex = '1';
    gradientEl.style.flex = '0';
  } else if (wantGrad){
    gradientEl.style.flex = '1';
    swatchesEl.style.flex = '0';
  } else {
    // nothing chosen: default to rectangles ON
    rectChk.checked = true;
    swatchesEl.style.display = 'flex';
    swatchesEl.style.flex = '1';
  }
}

/* ---------- Freeze / Unfreeze ---------- */
async function freezeNow(){
  running = false;
  const {sx,sy,sw,sh} = computeSquareCrop();
  const scale = procWidth / sw, w = Math.max(2, Math.round(sw * scale)), h = w;
  capFrame.width = w; capFrame.height = h;
  capFrame.getContext('2d').drawImage(video, sx, sy, sw, sh, 0, 0, w, h);

  frozenCanvas.width = sw; frozenCanvas.height = sh;
  frozenCanvas.getContext('2d').drawImage(video, sx, sy, sw, sh, 0, 0, sw, sh);
  frozenCanvas.style.display = 'block';
  video.pause();

  const imgs = capFrame.getContext('2d').getImageData(0,0,w,h);
  const cols = await new Promise(res=>{
    const handler = (ev)=>{
      const arr = new Uint8Array(ev.data.palette||[]);
      const out=[]; for(let i=0;i<arr.length;i+=3) out.push([arr[i],arr[i+1],arr[i+2]]);
      while(out.length<K) out.push(out[out.length-1]||[128,128,128]);
      worker.removeEventListener('message', handler);
      res(out.slice(0,K));
    };
    worker.addEventListener('message', handler, {once:true});
    worker.postMessage({pixels:imgs.data.buffer, width:w, height:h, algo, k:K, stride:2}, [imgs.data.buffer]);
  });
  const hexes = cols.map(toHex);

  await renderCompositeFullscreen(hexes, w, h, rectChk.checked, gradChk.checked);
  compositeOverlay.classList.add('open');
}
function unfreeze(){
  compositeOverlay.classList.remove('open');
  frozenCanvas.style.display='none';
  video.play().catch(()=>{});
  running = true; status('Live');
}

/* ---------- Composite (1024 width; respects toggles; borderless; larger HEX) ---------- */
function renderCompositeFullscreen(hexes, frameW, frameH, showRects, showGrad){
  const CAM_W=1024, CAM_H=1024, RECT_H=showRects?240:0, GRAD_H=showGrad?120:0, LABEL=showRects?26:0, PAD=24, GUT=24;
  const W = PAD+CAM_W+PAD;
  const H = PAD+CAM_H+(showRects||showGrad?GUT:0)+RECT_H+LABEL+(showGrad?GUT:0)+GRAD_H+PAD;

  const c = compositeCanvas; c.width=W; c.height=H;
  const g = c.getContext('2d');
  g.fillStyle='#000'; g.fillRect(0,0,W,H);

  // camera
  g.imageSmoothingEnabled=true; g.imageSmoothingQuality='high';
  g.drawImage(capFrame, 0,0,frameW,frameH, PAD, PAD, CAM_W, CAM_H);

  let y = PAD+CAM_H; if (showRects||showGrad) y+=GUT;

  // rectangles + HEX
  if (showRects){
    const N=hexes.length, w=Math.ceil(CAM_W/N);
    for(let i=0;i<N;i++){ g.fillStyle=hexes[i]; g.fillRect(PAD+i*w, y, w, RECT_H); }
    g.font='15px ui-monospace,SFMono-Regular,Menlo,Consolas,monospace';
    g.fillStyle='#d0d0d0'; g.textAlign='center'; g.textBaseline='top';
    for(let i=0;i<N;i++){ const cx=PAD+Math.round(i*w+w/2); g.fillText(hexes[i].toUpperCase(), cx, y+RECT_H+4); }
    y += RECT_H+LABEL;
  }
  // gradient
  if (showGrad){
    if (showRects) y += GUT;
    const grad=g.createLinearGradient(PAD,0,PAD+CAM_W,0);
    const N=hexes.length; hexes.forEach((h,i)=>grad.addColorStop(i/(N-1),h));
    g.fillStyle=grad; g.fillRect(PAD, y, CAM_W, GRAD_H);
  }
}

/* ---------- Status ---------- */
function status(t){ statusEl.textContent = t; }
</script>
</body>
</html>