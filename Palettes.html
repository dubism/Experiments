<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Live Camera Palette — Minimal</title>
<style>
  :root { --bg:#000; --ink:#fff; --muted:#bdbdbd; --line:#222; --panel:#0a0a0a; --zoom:1; }
  *{box-sizing:border-box} html,body{height:100%} body{margin:0;background:var(--bg);color:var(--ink);
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; user-select:none;}
  /* Fixed panes: video top, palette bottom */
  .pane{position:fixed;left:0;right:0}
  #videoPane{top:0;height:48vh;display:flex;align-items:center;justify-content:center;border-bottom:1px solid var(--line);background:#000;overflow:hidden}
  #palettePane{bottom:0;height:48vh;display:flex;flex-direction:column;gap:8px;padding:10px;border-top:1px solid var(--line);background:#000;}
  .videoWrap{position:relative;display:flex;align-items:center;justify-content:center;width:100%;height:100%;overflow:hidden}
  video{max-height:46vh;max-width:92vw;border-radius:8px;background:#000;display:block;transform:scale(var(--zoom));transform-origin:center center}
  /* Top UI (now visible) */
  .topBar{position:fixed;top:6px;left:8px;right:8px;display:flex;gap:8px;align-items:center;justify-content:space-between;z-index:1000}
  .group{display:flex;gap:6px}
  .tab{padding:6px 10px;background:rgba(255,255,255,.06);border:1px solid var(--line);color:var(--ink);border-radius:7px;cursor:pointer}
  .tab.active{outline:2px solid #fff; outline-offset:1px}
  .btn{padding:6px 10px;border:1px solid var(--line);border-radius:7px;background:#0d0d0d;color:#fff;cursor:pointer}
  .btn.ghost{background:transparent}
  .small{font-variant-numeric:tabular-nums;color:var(--muted)}
  /* Control Center dropdown */
  .ccWrap{position:fixed;top:44px;left:8px;right:8px;display:none;z-index:1100}
  .cc{background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:10px;display:grid;gap:10px}
  .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
  label{color:#eee}
  input[type="range"]{width:220px}
  .hint{color:var(--muted);font-size:12px}
  /* Palette area */
  .title{display:flex;align-items:center;justify-content:space-between;color:var(--muted)}
  .swatches{flex:1;display:flex;border:1px solid var(--line);border-radius:8px;overflow:hidden}
  .swatch{flex:1}
  .gradient{flex:1;border:1px solid var(--line);border-radius:8px}
  .codes{display:grid;grid-template-columns:repeat(auto-fill,minmax(110px,1fr));gap:6px}
  .code{padding:6px 8px;background:#0a0a0a;border:1px solid var(--line);border-radius:6px;color:var(--muted);
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}
  /* Freeze actions bar */
  .freezeBar{position:fixed;bottom:52vh;left:50%;transform:translateX(-50%);
    display:none;gap:8px;backdrop-filter:blur(6px);background:rgba(0,0,0,.6);border:1px solid var(--line);
    border-radius:10px;padding:8px;z-index:1200}
  .freezeBar .btn{white-space:nowrap}
  /* Tiny overlays */
  .overlay{position:fixed;right:8px;bottom:8px;color:var(--muted);font-variant-numeric:tabular-nums}
  /* Hidden canvas */
  canvas{display:none}
</style>
</head>
<body>
  <div class="topBar">
    <div class="group" id="tabs">
      <button class="tab active" data-algo="kmeans">K-Means</button>
      <button class="tab" data-algo="hist">Histogram</button>
      <button class="tab" data-algo="mediancut">Median-cut</button>
    </div>
    <div class="group">
      <button class="btn" id="freezeBtn">Freeze</button>
      <button class="btn ghost" id="ccToggle">Controls</button>
      <div class="small">FPS <span id="fps">0</span> · <span id="res">–</span></div>
    </div>
  </div>

  <div class="ccWrap" id="ccWrap">
    <div class="cc">
      <div class="row"><label>Colors (K)</label><span>
        <input type="range" id="k" min="2" max="10" value="5"><span id="kVal" class="small">5</span></span>
      </div>
      <div class="row"><label>Gradient mode</label>
        <input type="checkbox" id="mode" checked>
      </div>
      <div class="row"><label>Processing width</label><span>
        <input type="range" id="size" min="120" max="360" step="20" value="240"><span id="sizeVal" class="small">240 px</span></span>
      </div>
      <div class="row"><label>Process every N frames</label><span>
        <!-- exponential steps up to ~150 -->
        <input type="range" id="throttleIdx" min="0" max="10" value="3">
        <span id="throttleVal" class="small">5</span></span>
      </div>
      <div class="row"><label>Camera zoom</label><span>
        <input type="range" id="zoom" min="1" max="3" step="0.05" value="1">
        <span id="zoomVal" class="small">1.00×</span></span>
      </div>
      <div class="hint">Serve over HTTPS (GitHub Pages) for camera + clipboard.</div>
    </div>
  </div>

  <div id="videoPane" class="pane">
    <div class="videoWrap">
      <video id="video" playsinline muted></video>
    </div>
  </div>

  <div id="palettePane" class="pane">
    <div class="title">
      <div id="algoName" class="small">K-Means (LAB)</div>
      <div id="status" class="small">Waiting for camera…</div>
    </div>
    <div id="swatches" class="swatches"></div>
    <div id="gradient" class="gradient" hidden></div>
    <div id="codes" class="codes"></div>
  </div>

  <div id="freezeActions" class="freezeBar">
    <button class="btn" id="saveComposite">Save composite</button>
    <button class="btn" id="savePalette">Save palette-only</button>
    <button class="btn" id="copyHex">Copy HEX</button>
    <button class="btn ghost" id="unfreeze">Unfreeze</button>
  </div>

  <div class="overlay small" id="overlayInfo"></div>

  <canvas id="off"></canvas>
  <canvas id="capFrame"></canvas>

<script>
/* ---------- Worker: algorithms ---------- */
const workerBlob = new Blob([`
self.onmessage = (e)=> {
  const {pixels,width,height,algo,k,stride=2} = e.data;
  const data = new Uint8ClampedArray(pixels);
  const samples = [];
  for(let y=0;y<height;y+=stride){
    let row=y*width*4;
    for(let x=0;x<width;x+=stride){
      const i=row+x*4; samples.push(data[i],data[i+1],data[i+2]);
    }
  }
  let palette;
  if (algo==='hist') palette = histPalette(samples,k);
  else if (algo==='mediancut') palette = medianCutPalette(samples,k);
  else palette = kmeansLAB(samples,k,6);
  palette = dedupeAndSort(palette,10);
  const out = new Uint8Array(palette.flat());
  self.postMessage({palette: out.buffer}, [out.buffer]);
};
function rgb2xyz(r,g,b){r/=255;g/=255;b/=255;
  r=r<=0.04045?r/12.92:((r+0.055)/1.055)**2.4;
  g=g<=0.04045?g/12.92:((g+0.055)/1.055)**2.4;
  b=b<=0.04045?b/12.92:((b+0.055)/1.055)**2.4;
  return [r*0.4124+g*0.3576+b*0.1805, r*0.2126+g*0.7152+b*0.0722, r*0.0193+g*0.1192+b*0.9505];}
function xyz2lab(x,y,z){const Xr=0.95047,Yr=1,Zr=1.08883;
  const f=t=>t>0.008856?Math.cbrt(t):7.787*t+16/116;
  const fx=f(x/Xr), fy=f(y/Yr), fz=f(z/Zr);
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];}
function rgb2lab(r,g,b){const [x,y,z]=rgb2xyz(r,g,b);return xyz2lab(x,y,z);}
function dE76(L1,a1,b1,L2,a2,b2){const dL=L1-L2,da=a1-a2,db=b1-b2;return Math.hypot(dL,da,db);}
function histPalette(samples,k){const bins=new Uint32Array(512);
  for(let i=0;i<samples.length;i+=3){const r=samples[i]>>5,g=samples[i+1]>>5,b=samples[i+2]>>5;bins[(r<<6)|(g<<3)|b]++;}
  const idx=[...bins.keys()].sort((a,b)=>bins[b]-bins[a]).slice(0,k);
  return idx.map(code=>{const r=(code>>6)&7,g=(code>>3)&7,b=code&7;return [r*32+16,g*32+16,b*32+16];});
}
function medianCutPalette(samples,k){
  const colors=[]; for(let i=0;i<samples.length;i+=3) colors.push([samples[i],samples[i+1],samples[i+2]]);
  let boxes=[{colors}]; const bounds=b=>{b.r=[255,0];b.g=[255,0];b.b=[255,0];
    for(const c of b.colors){ if(c[0]<b.r[0])b.r[0]=c[0]; if(c[0]>b.r[1])b.r[1]=c[0];
      if(c[1]<b.g[0])b.g[0]=c[1]; if(c[1]>b.g[1])b.g[1]=c[1];
      if(c[2]<b.b[0])b.b[0]=c[2]; if(c[2]>b.b[1])b.b[1]=c[2];}};
  boxes.forEach(bounds);
  const range=b=>Math.max(b.r[1]-b.r[0],b.g[1]-b.g[0],b.b[1]-b.b[0]);
  const axis=b=>{const rs=[b.r[1]-b.r[0],b.g[1]-b.g[0],b.b[1]-b.b[0]]; return rs.indexOf(Math.max(...rs));};
  while(boxes.length<k){
    boxes.sort((A,B)=>range(B)-range(A));
    const big=boxes.shift(); if(!big||big.colors.length<=1) break;
    const ax=axis(big); big.colors.sort((a,b)=>a[ax]-b[ax]); const mid=big.colors.length>>1;
    const left={colors:big.colors.slice(0,mid)}, right={colors:big.colors.slice(mid)};
    [left,right].forEach(bounds); boxes.push(left,right);
  }
  return boxes.map(b=>{let r=0,g=0,bl=0,n=b.colors.length||1;
    for(const c of b.colors){r+=c[0];g+=c[1];bl+=c[2];}
    return [r/n|0,g/n|0,bl/n|0];}).slice(0,k);
}
function kmeansLAB(samples,k,maxIter=6){
  const pts=[]; for(let i=0;i<samples.length;i+=3){const r=samples[i],g=samples[i+1],b=samples[i+2]; const [L,a,bb]=rgb2lab(r,g,b); pts.push([L,a,bb,r,g,b]);}
  const centers=[]; centers.push(pts[(Math.random()*pts.length)|0].slice(0,3));
  while(centers.length<k){ const d2=pts.map(p=>Math.min(...centers.map(c=>d2lab(p,c)))); const sum=d2.reduce((a,b)=>a+b,0)||1;
    let r=Math.random()*sum,i=0; for(;i<d2.length-1&&(r-=d2[i])>0;i++); centers.push(pts[i].slice(0,3));}
  const labels=new Uint16Array(pts.length);
  for(let it=0;it<maxIter;it++){
    for(let i=0;i<pts.length;i++){let best=0,bd=1e9; for(let c=0;c<centers.length;c++){const d=d2lab(pts[i],centers[c]); if(d<bd){bd=d;best=c;}} labels[i]=best;}
    const sums=Array.from({length:k},()=>[0,0,0,0]); for(let i=0;i<pts.length;i++){const c=labels[i],p=pts[i]; sums[c][0]+=p[0];sums[c][1]+=p[1];sums[c][2]+=p[2];sums[c][3]++; }
    for(let c=0;c<k;c++) if(sums[c][3]>0){ centers[c][0]=sums[c][0]/sums[c][3]; centers[c][1]=sums[c][1]/sums[c][3]; centers[c][2]=sums[c][2]/sums[c][3]; }
  }
  const acc=Array.from({length:k},()=>[0,0,0,0]);
  for(let i=0;i<pts.length;i++){const c=labels[i],p=pts[i]; acc[c][0]+=p[3];acc[c][1]+=p[4];acc[c][2]+=p[5];acc[c][3]++;}
  const out=[]; for(let c=0;c<k;c++) if(acc[c][3]>0) out.push([acc[c][0]/acc[c][3]|0,acc[c][1]/acc[c][3]|0,acc[c][2]/acc[c][3]|0]);
  while(out.length<k) out.push(out[out.length-1]||[128,128,128]); return out.slice(0,k);
  function d2lab(p,c){const d0=p[0]-c[0],d1=p[1]-c[1],d2=p[2]-c[2];return d0*d0+d1*d1+d2*d2;}
}
function dedupeAndSort(rgbList,minDE=10){
  const labList=rgbList.map(([r,g,b])=>[...rgb2lab(r,g,b),r,g,b]); labList.sort((a,b)=>a[0]-b[0]);
  const kept=[]; for(const c of labList){let ok=true; for(const d of kept){ if(dE76(c[0],c[1],c[2],d[0],d[1],d[2])<minDE){ok=false;break;} } if(ok) kept.push(c); }
  return kept.map(c=>[c[3],c[4],c[5]]);
}
`], {type:'application/javascript'});
const worker = new Worker(URL.createObjectURL(workerBlob), {type:'module'});

/* ---------- Elements ---------- */
const video = document.getElementById('video');
const off = document.getElementById('off');
const capFrame = document.getElementById('capFrame');

const tabs = document.getElementById('tabs');
const algoName = document.getElementById('algoName');
const statusEl = document.getElementById('status');
const fpsEl = document.getElementById('fps');
const resEl = document.getElementById('res');
const overlayInfo = document.getElementById('overlayInfo');

const swatchesEl = document.getElementById('swatches');
const gradientEl = document.getElementById('gradient');
const codesEl = document.getElementById('codes');

const freezeBtn = document.getElementById('freezeBtn');
const freezeActions = document.getElementById('freezeActions');
const saveCompositeBtn = document.getElementById('saveComposite');
const savePaletteBtn = document.getElementById('savePalette');
const copyHexBtn = document.getElementById('copyHex');
const unfreezeBtn = document.getElementById('unfreeze');

const ccToggle = document.getElementById('ccToggle');
const ccWrap = document.getElementById('ccWrap');
const kRange = document.getElementById('k'); const kVal = document.getElementById('kVal');
const sizeRange = document.getElementById('size'); const sizeVal = document.getElementById('sizeVal');
const throttleIdx = document.getElementById('throttleIdx'); const throttleVal = document.getElementById('throttleVal');
const modeChk = document.getElementById('mode');
const zoomSlider = document.getElementById('zoom'); const zoomVal = document.getElementById('zoomVal');

/* ---------- State ---------- */
let algo = 'kmeans';
let K = +kRange.value;
let procWidth = +sizeRange.value;
const throttleSteps = [1,2,3,5,8,13,21,34,55,89,144]; // exponential-ish up to ~150
let throttleN = throttleSteps[+throttleIdx.value];
let gradientMode = modeChk.checked;
let uiZoom = +zoomSlider.value;

let frameCounter = 0, lastT = performance.now();
let pending = false, every = 0;
let running = true;

let lastPalette = [];
let lastHexes = [];
let frozen = null;

/* ---------- UI wiring ---------- */
tabs.addEventListener('click', (e)=>{
  const btn = e.target.closest('.tab');
  if(!btn) return;
  document.querySelectorAll('.tab').forEach(b=>b.classList.toggle('active', b===btn));
  algo = btn.dataset.algo;
  algoName.textContent = btn.textContent + (algo==='kmeans'?' (LAB)':'');
});
kRange.addEventListener('input', ()=>{ K = +kRange.value; kVal.textContent = K; });
sizeRange.addEventListener('input', ()=>{ procWidth = +sizeRange.value; sizeVal.textContent = procWidth+' px'; });
throttleIdx.addEventListener('input', ()=>{
  throttleN = throttleSteps[+throttleIdx.value];
  throttleVal.textContent = String(throttleN);
});
modeChk.addEventListener('change', ()=>{ gradientMode = modeChk.checked; renderPalette(lastPalette); });

ccToggle.addEventListener('click', ()=>{
  ccWrap.style.display = ccWrap.style.display ? '' : 'block';
});
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape') ccWrap.style.display=''; });

zoomSlider.addEventListener('input', ()=>{
  uiZoom = +zoomSlider.value;
  zoomVal.textContent = uiZoom.toFixed(2)+'×';
  document.documentElement.style.setProperty('--zoom', uiZoom);
});

freezeBtn.addEventListener('click', async ()=>{
  if (!running) return;
  await freezeNow();
});
unfreezeBtn.addEventListener('click', ()=>{
  frozen = null;
  running = true;
  freezeActions.style.display='none';
  status('Live');
});
saveCompositeBtn.addEventListener('click', ()=> saveComposite());
savePaletteBtn.addEventListener('click', ()=> savePaletteOnly());
copyHexBtn.addEventListener('click', async ()=>{
  if (!frozen) return;
  const txt = frozen.hexes.join('\n');
  try{
    await navigator.clipboard.writeText(txt);
    toast('HEX copied');
  }catch(_){ toast('Copy failed'); }
});

/* ---------- Camera ---------- */
(async function init(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    video.srcObject = stream;
    await video.play();
    status('Running…');
    loop();
  }catch(err){
    status('Camera failed: '+err.message);
  }
})();

/* ---------- Loop ---------- */
function loop(){
  requestAnimationFrame(loop);
  if(video.readyState < 2) return;

  // FPS (processing FPS)
  const now = performance.now();
  if (now - lastT >= 1000){
    fpsEl.textContent = String(frameCounter);
    frameCounter = 0; lastT = now;
  }

  const scale = procWidth / video.videoWidth;
  const w = Math.max(2, Math.round(video.videoWidth*scale));
  const h = Math.max(2, Math.round(video.videoHeight*scale));
  off.width = w; off.height = h;
  const ctx = off.getContext('2d', {willReadFrequently:true});
  ctx.drawImage(video, 0, 0, w, h);
  resEl.textContent = w + '×' + h;

  if (!running) return;

  every = (every+1) % throttleN;
  if (every!==0) return;

  if (!pending){
    pending = true;
    const img = ctx.getImageData(0,0,w,h);
    worker.postMessage({pixels:img.data.buffer, width:w, height:h, algo, k:K, stride:2}, [img.data.buffer]);
  }
}

/* ---------- Worker response ---------- */
worker.onmessage = (e)=>{
  frameCounter++;
  const buf = e.data.palette;
  if (!buf){ pending=false; return; }
  const arr = new Uint8Array(buf);
  const cols = [];
  for(let i=0;i<arr.length;i+=3) cols.push([arr[i],arr[i+1],arr[i+2]]);
  while(cols.length < K) cols.push(cols[cols.length-1] || [128,128,128]);
  lastPalette = cols.slice(0,K);
  renderPalette(lastPalette);
  pending = false;
};

/* ---------- Render palette ---------- */
function toHex([r,g,b]){ return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }

function renderPalette(palette){
  if(!palette || !palette.length){
    swatchesEl.innerHTML = ''; gradientEl.hidden = true; return;
  }
  lastHexes = palette.map(toHex);

  // Discrete swatches
  swatchesEl.innerHTML = '';
  for(const h of lastHexes){
    const d = document.createElement('div');
    d.className = 'swatch';
    d.style.background = h;
    swatchesEl.appendChild(d);
  }

  // Gradient
  gradientEl.style.background = `linear-gradient(90deg, ${lastHexes.map((c,i)=>`${c} ${(i/(lastHexes.length-1))*100}%`).join(',')})`;

  swatchesEl.hidden = gradientMode;
  gradientEl.hidden = !gradientMode;

  // HEX codes
  codesEl.innerHTML = '';
  for(const h of lastHexes){
    const c = document.createElement('div');
    c.className='code';
    c.textContent = h.toUpperCase();
    codesEl.appendChild(c);
  }
}

/* ---------- Freeze & capture ---------- */
async function freezeNow(){
  // store frozen frame at processing size
  const w = off.width, h = off.height;
  capFrame.width = w; capFrame.height = h;
  const ctx = capFrame.getContext('2d');
  ctx.drawImage(off, 0, 0);
  const imageBitmap = await createImageBitmap(capFrame);
  const palette = lastPalette.slice();
  const hexes = palette.map(toHex);
  frozen = {
    imageBitmap,
    palette,
    hexes,
    meta: {
      algo: algoName.textContent,
      K,
      gradient: gradientMode ? 'On' : 'Off',
      procWidth: procWidth,
      throttle: throttleN,
      res: w+'×'+h,
      zoom: uiZoom.toFixed(2)+'×'
    }
  };
  running = false;
  freezeActions.style.display = 'flex';
  status('Frozen');
}

function saveComposite(){
  if(!frozen) return;
  const pad = 24, gutter = 24;
  const camW = 800, camH = Math.round(camW * (frozen.imageBitmap.height / frozen.imageBitmap.width));
  const sideW = 420;
  const paletteH = 180;
  const W = pad + camW + gutter + sideW + pad;
  const H = pad + Math.max(camH + gutter + paletteH, 520) + pad;

  const c = document.createElement('canvas'); c.width = W; c.height = H;
  const g = c.getContext('2d');

  g.fillStyle = '#000'; g.fillRect(0,0,W,H);
  g.fillStyle = '#fff'; g.font = '600 18px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
  g.fillText('Live Camera Palette — Capture', pad, pad+18);

  // Camera
  g.save(); g.translate(pad, pad+32);
  const scale = Math.min(camW/frozen.imageBitmap.width, camH/frozen.imageBitmap.height);
  const drawW = Math.round(frozen.imageBitmap.width*scale);
  const drawH = Math.round(frozen.imageBitmap.height*scale);
  const dx = Math.floor((camW-drawW)/2), dy = Math.floor((camH-drawH)/2);
  g.fillStyle = '#111'; g.fillRect(0,0,camW,camH);
  g.drawImage(frozen.imageBitmap, dx, dy, drawW, drawH);
  g.strokeStyle = '#222'; g.strokeRect(0.5,0.5,camW-1,camH-1);
  g.restore();

  // Palette
  g.save(); g.translate(pad, pad+32+camH+gutter);
  if (modeChk.checked){
    const grad = g.createLinearGradient(0,0,camW,0);
    frozen.hexes.forEach((h,i)=> grad.addColorStop((i/(frozen.hexes.length-1)), h));
    g.fillStyle = grad; g.fillRect(0,0,camW,paletteH);
  } else {
    const n = frozen.hexes.length, w = Math.ceil(camW/n);
    for(let i=0;i<n;i++){ g.fillStyle = frozen.hexes[i]; g.fillRect(i*w,0,w,paletteH); }
  }
  g.strokeStyle = '#222'; g.strokeRect(0.5,0.5,camW-1,paletteH-1);
  g.restore();

  // Right column: settings + HEX
  g.save(); g.translate(pad+camW+gutter, pad+32);
  g.fillStyle = '#fff'; g.font = '600 14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
  g.fillText('Settings', 0, 0);
  g.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'; g.fillStyle = '#bdbdbd';
  const lines = [
    `Algo: ${frozen.meta.algo}`,
    `K: ${frozen.meta.K}`,
    `Gradient: ${frozen.meta.gradient}`,
    `Proc width: ${frozen.meta.procWidth}px`,
    `Stride N: ${frozen.meta.throttle}`,
    `Processed res: ${frozen.meta.res}`,
    `UI Zoom: ${frozen.meta.zoom}`
  ];
  lines.forEach((t,i)=> g.fillText(t, 0, 22 + i*16));
  g.fillStyle = '#fff'; g.font = '600 14px system-ui,-apple-system,Segoe UI,Roboto,sans-serif';
  g.fillText('HEX', 0, 22 + lines.length*16 + 16);
  g.font = '12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace'; g.fillStyle = '#bdbdbd';
  const startY = 22 + lines.length*16 + 36;
  frozen.hexes.forEach((h,i)=> g.fillText(h.toUpperCase(), 0, startY + i*16));
  g.restore();

  downloadCanvas(c, 'palette_composite.png');
}

function savePaletteOnly(){
  if(!frozen) return;
  const S = 1024;
  const c = document.createElement('canvas'); c.width = S; c.height = S;
  const g = c.getContext('2d');
  if (modeChk.checked){
    const grad = g.createLinearGradient(0,0,S,0);
    frozen.hexes.forEach((h,i)=> grad.addColorStop((i/(frozen.hexes.length-1)), h));
    g.fillStyle = grad; g.fillRect(0,0,S,S);
  } else {
    const n = frozen.hexes.length, w = Math.ceil(S/n);
    for(let i=0;i<n;i++){ g.fillStyle = frozen.hexes[i]; g.fillRect(i*w,0,w,S); }
  }
  downloadCanvas(c, 'palette_square.png');
}

function downloadCanvas(canvas, filename){
  canvas.toBlob((blob)=>{
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=> URL.revokeObjectURL(a.href), 1000);
  }, 'image/png');
}

/* ---------- Helpers ---------- */
function status(t){ statusEl.textContent = t; }
function toast(t){ overlayInfo.textContent = t; setTimeout(()=>{ overlayInfo.textContent=''; }, 1200); }
</script>
</body>
</html>
