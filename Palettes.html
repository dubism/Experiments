<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Live Camera Palette — Minimal</title>
<style>
  :root { --bg:#000; --ink:#fff; --muted:#bdbdbd; --line:#222; --panel:#0a0a0a; --zoom:1; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif; user-select:none;}

  /* Three fixed bands */
  #videoPane{position:fixed;left:0;right:0;top:0;height:42vh;display:flex;align-items:center;justify-content:center;
    border-bottom:1px solid var(--line);background:#000;overflow:hidden}
  #palettePane{position:fixed;left:0;right:0;top:42vh;height:42vh;display:flex;flex-direction:column;gap:8px;padding:10px;
    border-bottom:1px solid var(--line);background:#000}
  #controlsBar{position:fixed;left:0;right:0;bottom:0;height:16vh;min-height:96px;border-top:1px solid var(--line);
    background:#000;padding:8px 10px;display:flex;flex-direction:column;gap:6px}

  /* Camera area with frozen overlay canvas */
  .videoWrap{position:relative;display:flex;align-items:center;justify-content:center;width:100%;height:100%}
  video{max-height:40vh;max-width:92vw;border-radius:8px;background:#000;display:block;
    transform:scale(var(--zoom));transform-origin:center center}
  #frozenCanvas{position:absolute;inset:0;margin:auto;display:none;max-height:40vh;max-width:92vw;border-radius:8px}

  /* Palette */
  .title{display:flex;align-items:center;justify-content:space-between;color:var(--muted)}
  .swatches{flex:1;display:flex;border:1px solid var(--line);border-radius:8px;overflow:hidden}
  .swatch{flex:1}
  .gradient{flex:1;border:1px solid var(--line);border-radius:8px}
  .codes{display:grid;grid-template-columns:repeat(auto-fill,minmax(110px,1fr));gap:6px}
  .code{padding:6px 8px;background:#0a0a0a;border:1px solid var(--line);border-radius:6px;color:var(--muted);
    font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace}

  /* Bottom controls */
  .row{display:flex;align-items:center;justify-content:space-between;gap:8px}
  .group{display:flex;gap:6px;align-items:center;flex-wrap:wrap}
  .tab{padding:6px 10px;background:rgba(255,255,255,.06);border:1px solid var(--line);color:var(--ink);border-radius:7px;cursor:pointer}
  .tab.active{outline:2px solid #fff; outline-offset:1px}
  .btn{padding:8px 14px;border:1px solid var(--line);border-radius:8px;background:#0d0d0d;color:#fff;cursor:pointer}
  .btn.ghost{background:transparent}
  .btn.cta{background:#fff;color:#000;font-weight:900;border-color:#fff;font-size:16px;padding:10px 18px}
  .small{font-variant-numeric:tabular-nums;color:var(--muted)}
  input[type="range"]{width:220px}

  /* Control Center overlay (on palette, translucent) */
  #ccWrap{position:absolute;left:10px;right:10px;bottom:10px;display:none;z-index:10}
  #cc{background:rgba(0,0,0,.6);backdrop-filter:blur(6px);border:1px solid var(--line);border-radius:10px;padding:10px;display:grid;gap:10px}
  #cc .row{justify-content:space-between}

  /* Fullscreen Composite (after freeze) */
  #compositeOverlay{position:fixed;inset:0;background:#000;display:none;z-index:1000;
    display:flex;align-items:center;justify-content:center;flex-direction:column;gap:12px;padding:10px}
  #compositeCanvas{max-width:98vw;max-height:94vh;border:1px solid var(--line);border-radius:10px;background:#000}
  #unfreezeBtn{position:fixed;right:12px;bottom:12px}
</style>
</head>
<body>
  <!-- CAMERA -->
  <section id="videoPane">
    <div class="videoWrap">
      <video id="video" playsinline muted></video>
      <canvas id="frozenCanvas"></canvas>
    </div>
  </section>

  <!-- PALETTE -->
  <section id="palettePane">
    <div class="title">
      <div id="algoName" class="small">K-Means (LAB)</div>
      <div class="small">FPS <span id="fps">0</span> · <span id="res">–</span> · <span id="status">Waiting…</span></div>
    </div>
    <div id="swatches" class="swatches"></div>
    <div id="gradient" class="gradient" hidden></div>
    <div id="codes" class="codes"></div>

    <!-- Control Center overlays lower palette area -->
    <div id="ccWrap">
      <div id="cc">
        <div class="row"><span>Colors (K)</span><span>
          <input type="range" id="k" min="2" max="10" value="5"><span id="kVal" class="small">5</span></span>
        </div>
        <div class="row"><span>Gradient mode</span>
          <input type="checkbox" id="mode" checked>
        </div>
        <div class="row"><span>Processing width</span><span>
          <input type="range" id="size" min="120" max="360" step="20" value="240"><span id="sizeVal" class="small">240 px</span></span>
        </div>
        <div class="row"><span>Process every N frames</span><span>
          <input type="range" id="throttleIdx" min="0" max="10" value="3">
          <span id="throttleVal" class="small">5</span></span>
        </div>
        <div class="small">HTTPS required for camera/clipboard.</div>
      </div>
    </div>
  </section>

  <!-- CONTROLS BAR -->
  <section id="controlsBar">
    <div class="row">
      <div class="group" id="tabs">
        <button class="tab active" data-algo="kmeans">K-Means</button>
        <button class="tab" data-algo="hist">Histogram</button>
        <button class="tab" data-algo="mediancut">Median-cut</button>
      </div>
      <div class="group" style="margin-left:auto">
        <span class="small">Zoom</span>
        <input type="range" id="zoom" min="1" max="10" step="0.01" value="1">
        <span id="zoomVal" class="small">1.00×</span>
        <button class="btn ghost" id="ccToggle">Controls</button>
        <button class="btn cta" id="freezeBtn">FREEZE</button>
      </div>
    </div>
  </section>

  <!-- FULLSCREEN COMPOSITE -->
  <div id="compositeOverlay">
    <canvas id="compositeCanvas"></canvas>
    <button class="btn cta" id="unfreezeBtn">UNFREEZE</button>
  </div>

  <canvas id="off"></canvas>
  <canvas id="capFrame"></canvas>

<script>
/* ---------- Worker: algorithms ---------- */
const workerBlob = new Blob([`
self.onmessage = (e)=> {
  const {pixels,width,height,algo,k,stride=2} = e.data;
  const data = new Uint8ClampedArray(pixels);
  const samples = [];
  for(let y=0;y<height;y+=stride){
    let row=y*width*4;
    for(let x=0;x<width;x+=stride){
      const i=row+x*4; samples.push(data[i],data[i+1],data[i+2]);
    }
  }
  let palette;
  if (algo==='hist') palette = histPalette(samples,k);
  else if (algo==='mediancut') palette = medianCutPalette(samples,k);
  else palette = kmeansLAB(samples,k,6);
  palette = dedupeAndSort(palette,10);
  const out = new Uint8Array(palette.flat());
  self.postMessage({palette: out.buffer}, [out.buffer]);
};
function rgb2xyz(r,g,b){
  r/=255; g/=255; b/=255;
  r=r<=0.04045?r/12.92:((r+0.055)/1.055)**2.4;
  g=g<=0.04045?g/12.92:((g+0.055)/1.055)**2.4;
  b=b<=0.04045?b/12.92:((b+0.055)/1.055)**2.4;
  return [
    r*0.4124 + g*0.3576 + b*0.1805,
    r*0.2126 + g*0.7152 + b*0.0722,
    r*0.0193 + g*0.1192 + b*0.9505
  ];
}
function xyz2lab(x,y,z){
  const Xr=0.95047,Yr=1,Zr=1.08883;
  const f=t=>t>0.008856?Math.cbrt(t):7.787*t+16/116;
  const fx=f(x/Xr), fy=f(y/Yr), fz=f(z/Zr);
  return [116*fy-16, 500*(fx-fy), 200*(fy-fz)];
}
function rgb2lab(r,g,b){const [x,y,z]=rgb2xyz(r,g,b);return xyz2lab(x,y,z);}
function dE76(L1,a1,b1,L2,a2,b2){const dL=L1-L2,da=a1-a2,db=b1-b2;return Math.hypot(dL,da,db);}
function histPalette(samples,k){
  const bins=new Uint32Array(512);
  for(let i=0;i<samples.length;i+=3){
    const r=samples[i]>>5,g=samples[i+1]>>5,b=samples[i+2]>>5;
    bins[(r<<6)|(g<<3)|b]++;
  }
  const idx=[...bins.keys()].sort((a,b)=>bins[b]-bins[a]).slice(0,k);
  return idx.map(code=>{
    const r=(code>>6)&7,g=(code>>3)&7,b=code&7;
    return [r*32+16,g*32+16,b*32+16];
  });
}
function medianCutPalette(samples,k){
  const colors=[]; for(let i=0;i<samples.length;i+=3) colors.push([samples[i],samples[i+1],samples[i+2]]);
  let boxes=[{colors}];
  const bounds=b=>{
    b.r=[255,0]; b.g=[255,0]; b.b=[255,0];
    for(const c of b.colors){
      if(c[0]<b.r[0])b.r[0]=c[0]; if(c[0]>b.r[1])b.r[1]=c[0];
      if(c[1]<b.g[0])b.g[0]=c[1]; if(c[1]>b.g[1])b.g[1]=c[1];
      if(c[2]<b.b[0])b.b[0]=c[2]; if(c[2]>b.b[1])b.b[1]=c[2];
    }
  };
  boxes.forEach(bounds);
  const range=b=>Math.max(b.r[1]-b.r[0],b.g[1]-b.g[0],b.b[1]-b.b[0]);
  const axis=b=>{
    const rs=[b.r[1]-b.r[0],b.g[1]-b.g[0],b.b[1]-b.b[0]];
    return rs.indexOf(Math.max(...rs));
  };
  while(boxes.length<k){
    boxes.sort((A,B)=>range(B)-range(A));
    const big=boxes.shift(); if(!big||big.colors.length<=1) break;
    const ax=axis(big);
    big.colors.sort((a,b)=>a[ax]-b[ax]);
    const mid=big.colors.length>>1;
    const left={colors:big.colors.slice(0,mid)}, right={colors:big.colors.slice(mid)};
    [left,right].forEach(bounds); boxes.push(left,right);
  }
  return boxes.map(b=>{
    let r=0,g=0,bl=0,n=b.colors.length||1;
    for(const c of b.colors){r+=c[0];g+=c[1];bl+=c[2];}
    return [r/n|0,g/n|0,bl/n|0];
  }).slice(0,k);
}
function kmeansLAB(samples,k,maxIter=6){
  const pts=[];
  for(let i=0;i<samples.length;i+=3){
    const r=samples[i],g=samples[i+1],b=samples[i+2];
    const [L,a,bb]=rgb2lab(r,g,b);
    pts.push([L,a,bb,r,g,b]);
  }
  const centers=[]; centers.push(pts[(Math.random()*pts.length)|0].slice(0,3));
  while(centers.length<k){
    const d2=pts.map(p=>Math.min(...centers.map(c=>d2lab(p,c))));
    const sum=d2.reduce((a,b)=>a+b,0)||1;
    let r=Math.random()*sum,i=0; for(;i<d2.length-1&&(r-=d2[i])>0;i++); centers.push(pts[i].slice(0,3));
  }
  const labels=new Uint16Array(pts.length);
  for(let it=0;it<maxIter;it++){
    for(let i=0;i<pts.length;i++){
      let best=0,bd=1e9;
      for(let c=0;c<centers.length;c++){
        const d=d2lab(pts[i],centers[c]); if(d<bd){bd=d;best=c;}
      }
      labels[i]=best;
    }
    const sums=Array.from({length:k},()=>[0,0,0,0]);
    for(let i=0;i<pts.length;i++){
      const c=labels[i],p=pts[i];
      sums[c][0]+=p[0];sums[c][1]+=p[1];sums[c][2]+=p[2];sums[c][3]++;
    }
    for(let c=0;c<k;c++) if(sums[c][3]>0){
      centers[c][0]=sums[c][0]/sums[c][3];
      centers[c][1]=sums[c][1]/sums[c][3];
      centers[c][2]=sums[c][2]/sums[c][3];
    }
  }
  const acc=Array.from({length:k},()=>[0,0,0,0]);
  for(let i=0;i<pts.length;i++){
    const c=labels[i],p=pts[i];
    acc[c][0]+=p[3];acc[c][1]+=p[4];acc[c][2]+=p[5];acc[c][3]++;
  }
  const out=[]; for(let c=0;c<k;c++) if(acc[c][3]>0)
    out.push([acc[c][0]/acc[c][3]|0,acc[c][1]/acc[c][3]|0,acc[c][2]/acc[c][3]|0]);
  while(out.length<k) out.push(out[out.length-1]||[128,128,128]);
  return out.slice(0,k);
  function d2lab(p,c){const d0=p[0]-c[0],d1=p[1]-c[1],d2=p[2]-c[2];return d0*d0+d1*d1+d2*d2;}
}
function dedupeAndSort(rgbList,minDE=10){
  const labList=rgbList.map(([r,g,b])=>[...rgb2lab(r,g,b),r,g,b]); labList.sort((a,b)=>a[0]-b[0]);
  const kept=[]; for(const c of labList){
    let ok=true; for(const d of kept){ if(dE76(c[0],c[1],c[2],d[0],d[1],d[2])<minDE){ok=false;break;} }
    if(ok) kept.push(c);
  }
  return kept.map(c=>[c[3],c[4],c[5]]);
}
`], {type:'application/javascript'});
const worker = new Worker(URL.createObjectURL(workerBlob), {type:'module'});

/* ---------- Elements ---------- */
const video = document.getElementById('video');
const frozenCanvas = document.getElementById('frozenCanvas');
const off = document.getElementById('off');
const capFrame = document.getElementById('capFrame');

const tabs = document.getElementById('tabs');
const algoName = document.getElementById('algoName');
const statusEl = document.getElementById('status');
const fpsEl = document.getElementById('fps');
const resEl = document.getElementById('res');

const swatchesEl = document.getElementById('swatches');
const gradientEl = document.getElementById('gradient');
const codesEl = document.getElementById('codes');

const ccToggle = document.getElementById('ccToggle');
const ccWrap = document.getElementById('ccWrap');

const kRange = document.getElementById('k'); const kVal = document.getElementById('kVal');
const sizeRange = document.getElementById('size'); const sizeVal = document.getElementById('sizeVal');
const throttleIdx = document.getElementById('throttleIdx'); const throttleVal = document.getElementById('throttleVal');
const modeChk = document.getElementById('mode');
const zoomSlider = document.getElementById('zoom'); const zoomVal = document.getElementById('zoomVal');

const freezeBtn = document.getElementById('freezeBtn');

const compositeOverlay = document.getElementById('compositeOverlay');
const compositeCanvas = document.getElementById('compositeCanvas');
const unfreezeBtn = document.getElementById('unfreezeBtn');

/* ---------- State ---------- */
let algo = 'kmeans';
let K = +kRange.value;
let procWidth = +sizeRange.value;
const throttleSteps = [1,2,3,5,8,13,21,34,55,89,144]; // up to ~150
let throttleN = throttleSteps[+throttleIdx.value];
let uiZoom = +zoomSlider.value;

let frameCounter = 0, lastT = performance.now();
let pending = false, every = 0;
let running = true; // default: unfrozen

let lastPalette = [];
let lastHexes = [];
let frozen = null;

/* ---------- UI wiring ---------- */
tabs.addEventListener('click', (e)=>{
  const btn = e.target.closest('.tab'); if(!btn) return;
  document.querySelectorAll('.tab').forEach(b=>b.classList.toggle('active', b===btn));
  algo = btn.dataset.algo;
  algoName.textContent = btn.textContent + (algo==='kmeans'?' (LAB)':'');
});
kRange.addEventListener('input', ()=>{ K = +kRange.value; kVal.textContent = K; });
sizeRange.addEventListener('input', ()=>{ procWidth = +sizeRange.value; sizeVal.textContent = procWidth+' px'; });
throttleIdx.addEventListener('input', ()=>{ throttleN = throttleSteps[+throttleIdx.value]; throttleVal.textContent = String(throttleN); });
modeChk.addEventListener('change', ()=> renderPalette(lastPalette) );

ccToggle.addEventListener('click', ()=>{ ccWrap.style.display = ccWrap.style.display ? '' : 'block'; });
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape'){ ccWrap.style.display=''; if (!running) unfreeze(); } });

zoomSlider.addEventListener('input', ()=>{
  uiZoom = +zoomSlider.value;
  zoomVal.textContent = uiZoom.toFixed(2)+'×';
  document.documentElement.style.setProperty('--zoom', uiZoom);
});

freezeBtn.addEventListener('click', async ()=>{ if (running) await freezeNow(); });
unfreezeBtn.addEventListener('click', ()=>{ unfreeze(); });
window.addEventListener('resize', ()=>{ if (!running && frozen) renderCompositeFullscreen(); });

/* ---------- Helpers: compute zoom crop ---------- */
function computeCrop(){
  const vw = video.videoWidth || 0;
  const vh = video.videoHeight || 0;
  if (vw===0 || vh===0) return {sx:0,sy:0,sw:0,sh:0};
  const z = Math.max(1, uiZoom);
  const sw = Math.round(vw / z);
  const sh = Math.round(vh / z);
  const sx = Math.floor((vw - sw)/2);
  const sy = Math.floor((vh - sh)/2);
  return {sx, sy, sw, sh};
}

/* ---------- Camera ---------- */
(async function init(){
  try{
    const stream = await navigator.mediaDevices.getUserMedia({video:{facingMode:'environment'}, audio:false});
    video.srcObject = stream;
    await video.play();
    status('Running…');
    loop();
  }catch(err){
    status('Camera failed: '+err.message);
  }
})();

/* ---------- Loop ---------- */
function loop(){
  requestAnimationFrame(loop);
  if(video.readyState < 2) return;

  const now = performance.now();
  if (now - lastT >= 1000){ fpsEl.textContent = String(frameCounter); frameCounter = 0; lastT = now; }

  const vw = video.videoWidth, vh = video.videoHeight;
  if (!vw || !vh) return;

  // Processing canvas size (downscaled)
  const scale = procWidth / (vw / Math.max(1, uiZoom)); // reflect zoom crop width
  const crop = computeCrop();

  const w = Math.max(2, Math.round((crop.sw) * scale));
  const h = Math.max(2, Math.round((crop.sh) * scale));
  off.width = w; off.height = h;
  const ctx = off.getContext('2d', {willReadFrequently:true});

  if (running){
    // Draw ONLY the cropped zoomed area into processing canvas
    ctx.drawImage(video, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, w, h);
  }
  resEl.textContent = w + '×' + h;

  if (!running) return;

  every = (every+1) % throttleN;
  if (every!==0) return;

  if (!pending){
    pending = true;
    const img = ctx.getImageData(0,0,w,h);
    worker.postMessage({pixels:img.data.buffer, width:w, height:h, algo, k:K, stride:2}, [img.data.buffer]);
  }
}

/* ---------- Worker response ---------- */
worker.onmessage = (e)=>{
  frameCounter++;
  const arr = new Uint8Array(e.data.palette||[]);
  const cols = [];
  for(let i=0;i<arr.length;i+=3) cols.push([arr[i],arr[i+1],arr[i+2]]);
  while(cols.length < K) cols.push(cols[cols.length-1] || [128,128,128]);
  lastPalette = cols.slice(0,K);
  renderPalette(lastPalette);
  pending = false;
};

/* ---------- Render palette (live) ---------- */
function toHex([r,g,b]){ return '#' + [r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
function renderPalette(palette){
  if(!palette || !palette.length){ swatchesEl.innerHTML = ''; gradientEl.hidden = true; return; }
  lastHexes = palette.map(toHex);

  // Discrete swatches
  swatchesEl.innerHTML = '';
  for(const h of lastHexes){
    const d = document.createElement('div');
    d.className = 'swatch';
    d.style.background = h;
    swatchesEl.appendChild(d);
  }

  // Gradient
  gradientEl.style.background = `linear-gradient(90deg, ${lastHexes.map((c,i)=>`${c} ${(i/(lastHexes.length-1))*100}%`).join(',')})`;

  // Toggle
  const gradientOn = modeChk.checked;
  swatchesEl.hidden = gradientOn;
  gradientEl.hidden = !gradientOn;

  // HEX codes (live view)
  codesEl.innerHTML = '';
  for(const h of lastHexes){
    const c = document.createElement('div');
    c.className='code';
    c.textContent = h.toUpperCase();
    codesEl.appendChild(c);
  }
}

/* ---------- Freeze → Fullscreen composite ---------- */
async function freezeNow(){
  // Use zoom crop for capture
  const crop = computeCrop();
  const w = Math.max(2, Math.round(procWidth)); // processing width target (not used here directly)
  // Capture the zoomed crop at processing scale using off (already cropped), just copy it:
  const offW = off.width, offH = off.height;
  capFrame.width = offW; capFrame.height = offH;
  const cctx = capFrame.getContext('2d'); cctx.drawImage(off, 0, 0);

  // Pause video + show frozen still (also cropped)
  frozenCanvas.width = crop.sw; frozenCanvas.height = crop.sh;
  const fctx = frozenCanvas.getContext('2d');
  fctx.drawImage(video, crop.sx, crop.sy, crop.sw, crop.sh, 0, 0, crop.sw, crop.sh);
  frozenCanvas.style.display = 'block';
  video.pause();

  const imageBitmap = await createImageBitmap(capFrame);
  frozen = { imageBitmap, palette: lastPalette.slice(), hexes: lastPalette.map(toHex) };
  running = false;
  status('Frozen');

  await renderCompositeFullscreen();
  compositeOverlay.style.display = 'flex';
}

function unfreeze(){
  compositeOverlay.style.display = 'none';
  frozenCanvas.style.display = 'none';
  video.play().catch(()=>{});
  frozen = null;
  running = true;
  status('Live');
}

/* ---------- Composite drawing ---------- */
async function renderCompositeFullscreen(){
  if (!frozen) return;
  const gradientOn = modeChk.checked;

  const deviceW = Math.min(window.innerWidth, 1600);
  const camW = deviceW - 48;                       // padding margin
  const camH = Math.round(camW * (frozen.imageBitmap.height / frozen.imageBitmap.width));
  const paletteH = 180;                            // color area
  const labelBand = 18;                            // tiny hex under colors
  const pad = 24, gutter = 24;

  const width = pad + camW + pad;
  const height = pad + camH + gutter + (paletteH + labelBand) + pad;

  const c = compositeCanvas;
  c.width = width; c.height = height;
  const g = c.getContext('2d');

  // BG
  g.fillStyle = '#000'; g.fillRect(0,0,width,height);

  // Camera (zoom-cropped frame already in frozen.imageBitmap)
  g.save(); g.translate(pad, pad);
  g.fillStyle = '#111'; g.fillRect(0,0,camW,camH);
  const sc = Math.min(camW/frozen.imageBitmap.width, camH/frozen.imageBitmap.height);
  const dw = Math.round(frozen.imageBitmap.width*sc);
  const dh = Math.round(frozen.imageBitmap.height*sc);
  const dx = Math.floor((camW-dw)/2), dy = Math.floor((camH-dh)/2);
  g.drawImage(frozen.imageBitmap, dx, dy, dw, dh);
  g.strokeStyle = '#222'; g.strokeRect(0.5,0.5,camW-1,camH-1);
  g.restore();

  // Palette
  g.save(); g.translate(pad, pad+camH+gutter);
  const N = frozen.hexes.length;
  if (gradientOn){
    const grad = g.createLinearGradient(0,0,camW,0);
    frozen.hexes.forEach((h,i)=> grad.addColorStop((i/(N-1)), h));
    g.fillStyle = grad; g.fillRect(0,0,camW,paletteH);
  } else {
    const w = Math.ceil(camW/N);
    for(let i=0;i<N;i++){ g.fillStyle = frozen.hexes[i]; g.fillRect(i*w,0,w,paletteH); }
  }
  g.strokeStyle = '#222'; g.strokeRect(0.5,0.5,camW-1,paletteH-1);

  // Tiny hex labels under palette (like requested)
  g.font = '11px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace';
  g.fillStyle = '#bdbdbd';
  g.textAlign = 'center';
  g.textBaseline = 'top';
  if (gradientOn){
    for(let i=0;i<N;i++){
      const x = Math.round((i/(N-1)) * camW);
      g.fillText(frozen.hexes[i].toUpperCase(), x, paletteH + 3);
    }
  } else {
    const w = Math.ceil(camW/N);
    for(let i=0;i<N;i++){
      const cx = Math.round(i*w + w/2);
      g.fillText(frozen.hexes[i].toUpperCase(), cx, paletteH + 3);
    }
  }
  g.restore();
}

/* ---------- Status ---------- */
function status(t){ statusEl.textContent = t; }
</script>
</body>
</html>