<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Value-Only HDR Brush â€” Safari 26 WebGPU</title>
<style>
  html,body{margin:0;background:#000;height:100dvh;overflow:hidden}
  canvas{
    display:block;width:100vw;height:100dvh;
    /* Safari 26+: allow HDR peaks to exceed SDR white */
    dynamic-range-limit: no-limit;
    touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none;
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<script>
(async () => {
  const cvs = document.getElementById('cv');

  // Block gestures that steal the pointer stream
  const stop = e => e.preventDefault();
  for (const ev of ['gesturestart','gesturechange','gestureend','touchstart','touchmove','touchend'])
    cvs.addEventListener(ev, stop, {passive:false});

  // Pointer state
  const MAX_PTR = 12;
  const ptrs = new Map();
  const now = () => performance.now()/1000;

  function fit() {
    const dpr = Math.max(1, devicePixelRatio||1);
    const w = Math.max(2, Math.floor(cvs.clientWidth  * dpr));
    const h = Math.max(2, Math.floor(cvs.clientHeight * dpr));
    if (cvs.width !== w || cvs.height !== h) { cvs.width = w; cvs.height = h; return true; }
    return false;
  }
  addEventListener('resize', () => { if (fit()) configure(); }, {passive:true});
  fit();

  // Brush feel
  const P = {
    ramp: 0.25,
    decayHalf: 1.2,
    flow: 0.70,
    sigmaPx: 130,
    longT: 0.6,
    longGain: 0.5,
    headroom: 3.5
  };

  if (!('gpu' in navigator)) { console.error('WebGPU unavailable'); return; }
  const adapter = await navigator.gpu.requestAdapter();
  if (!adapter) { console.error('No GPU adapter'); return; }
  const device  = await adapter.requestDevice();
  const ctx     = cvs.getContext('webgpu', { alphaMode:'opaque' });
  const format  = navigator.gpu.getPreferredCanvasFormat();

  function configure() {
    // configure ONLY when size/format changes
    ctx.configure({ device, format, alphaMode:'opaque' });
  }
  configure();

  // --- WGSL (explicit types; packed uniforms) ---
  const wgsl = /* wgsl */`
const MAX_PTR : u32 = ${MAX_PTR}u;

struct U0 {
  a : vec4<f32>; // time, W, H, headroom
  b : vec4<f32>; // ramp, decayK, flow, sigma
  c : vec4<f32>; // longT, longG, ditherA, pad
};

struct PRec {
  x : f32; y : f32; down : f32; up : f32;
  active : f32; _p1 : f32; _p2 : f32; _p3 : f32;
};

@group(0) @binding(0) var<uniform> U : U0;
@group(0) @binding(1) var<uniform> P : array<PRec, MAX_PTR>;

struct VSOut { @builtin(position) pos: vec4<f32>; @location(0) uv: vec2<f32>; };

@vertex fn vs(@builtin(vertex_index) i: u32) -> VSOut {
  let q : array<vec2<f32>,6> = array<vec2<f32>,6>(
    vec2<f32>(-1.0,-1.0), vec2<f32>( 1.0,-1.0), vec2<f32>(-1.0, 1.0),
    vec2<f32>(-1.0, 1.0), vec2<f32>( 1.0,-1.0), vec2<f32>( 1.0, 1.0)
  );
  var o: VSOut;
  o.pos = vec4<f32>(q[i], 0.0, 1.0);
  o.uv  = q[i]*0.5 + vec2<f32>(0.5,0.5);
  return o;
}

fn gauss(r:f32, s:f32) -> f32 { return exp(-0.5 * (r*r) / (s*s)); }

fn hsv2rgb(h:f32, s:f32, v:f32) -> vec3<f32> {
  let six = h * 6.0;
  let k   = vec4<f32>(0.0, 4.0, 2.0, 1.0);
  let t   = fract(vec4<f32>(k.x + six, k.y + six, k.z + six, k.w + six));
  let p   = abs(t * 6.0 - 3.0) - 1.0;
  let rgb = clamp(vec3<f32>(p.x,p.y,p.z), vec3<f32>(0.0,0.0,0.0), vec3<f32>(1.0,1.0,1.0));
  return v * mix(vec3<f32>(1.0,1.0,1.0), rgb, s);
}

fn hash21(p: vec2<f32>) -> f32 {
  let a = dot(p, vec2<f32>(127.1, 311.7));
  return fract(sin(a) * 43758.5453);
}

@fragment fn fs(@location(0) uv: vec2<f32>, @builtin(position) pos: vec4<f32>)
  -> @location(0) vec4<f32> {
  // SDR baseline: H=x, V=y, S=1-y
  let Hh = clamp(uv.x, 0.0, 1.0);
  let V0 = clamp(uv.y, 0.0, 1.0);
  let Ss = clamp(1.0 - uv.y, 0.0, 1.0);

  let x = uv.x * U.a.y; // W
  let y = uv.y * U.a.z; // H

  var lift = 0.0;
  for (var i:u32 = 0u; i < MAX_PTR; i = i + 1u) {
    let pr = P[i];
    if (pr.active == 0.0 && pr.down == 0.0 && pr.up == 0.0) { continue; }
    let dx = x - pr.x;
    let dy = y - pr.y;
    let r  = sqrt(dx*dx + dy*dy);

    let age   = max(0.0, U.a.x - pr.down);
    let lp    = clamp((age - U.c.x)/0.8, 0.0, 1.0); // longT
    let gain  = 1.0 + lp * U.c.y;                   // longG
    let sig   = U.b.w * gain;                       // sigma

    let rampT = clamp(age / max(U.b.x, 1e-4), 0.0, 1.0); // ramp
    let tUp   = max(0.0, U.a.x - pr.up);
    let decay = exp(-U.b.y * tUp);                        // decayK

    let center = U.b.z * (pr.active * rampT + (1.0 - pr.active) * rampT * decay); // flow
    lift += center * gauss(r, sig) * gain;
  }

  var V = min(V0 + lift, U.a.w);                  // headroom
  V = max(0.0, V + (hash21(pos.xy) - 0.5) * U.c.z); // ditherA

  let rgb = hsv2rgb(Hh, Ss, V);
  return vec4<f32>(rgb, 1.0);
}
`;

  const module   = device.createShaderModule({ code: wgsl });
  const pipeline = device.createRenderPipeline({
    layout: 'auto',
    vertex:   { module, entryPoint: 'vs' },
    fragment: { module, entryPoint: 'fs', targets: [{ format }] }
  });

  // Uniform buffers
  const U_BUF_SIZE = 256;
  const P_BUF_SIZE = 256 * Math.ceil((MAX_PTR * 32) / 256); // 12*32=384 -> 512 aligned
  const uBuf = device.createBuffer({ size: U_BUF_SIZE, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });
  const pBuf = device.createBuffer({ size: P_BUF_SIZE, usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST });

  const bind = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      { binding: 0, resource: { buffer: uBuf } },
      { binding: 1, resource: { buffer: pBuf } }
    ]
  });

  // Pointer events
  function canvasPos(e){
    const r = cvs.getBoundingClientRect(), dpr = Math.max(1, devicePixelRatio||1);
    return { x:(e.clientX - r.left)*dpr, y:(e.clientY - r.top)*dpr };
  }
  cvs.addEventListener('pointerdown', e => {
    e.preventDefault(); cvs.setPointerCapture(e.pointerId);
    const t = now(), p = canvasPos(e);
    ptrs.set(e.pointerId, { x:p.x, y:p.y, down:t, up:t, active:1 });
  }, {passive:false});
  cvs.addEventListener('pointermove', e => {
    e.preventDefault();
    const pt = ptrs.get(e.pointerId); if (!pt) return;
    const p = canvasPos(e); pt.x = p.x; pt.y = p.y;
  }, {passive:false});
  function end(e){ e.preventDefault(); const pt = ptrs.get(e.pointerId); if (pt){ pt.active = 0; pt.up = now(); } }
  cvs.addEventListener('pointerup', end,   {passive:false});
  cvs.addEventListener('pointercancel', end,{passive:false});

  // Uniform writers
  function writeUniforms() {
    const dpr = Math.max(1, devicePixelRatio||1);
    const decayK = Math.log(2) / Math.max(0.001, P.decayHalf);
    // Pack into 3 vec4s
    const U = new Float32Array([
      now(), cvs.width, cvs.height, P.headroom,
      P.ramp, decayK, P.flow, P.sigmaPx * dpr,
      P.longT, P.longGain, 1/1023, 0
    ]);
    device.queue.writeBuffer(uBuf, 0, U);

    const Pck = new Float32Array(MAX_PTR * 8);
    let i=0; for (const [,pt] of ptrs) {
      Pck[i*8+0]=pt.x; Pck[i*8+1]=pt.y; Pck[i*8+2]=pt.down; Pck[i*8+3]=pt.up;
      Pck[i*8+4]=pt.active?1:0; Pck[i*8+5]=0; Pck[i*8+6]=0; Pck[i*8+7]=0;
      i++; if (i>=MAX_PTR) break;
    }
    device.queue.writeBuffer(pBuf, 0, Pck);
  }

  function frame(){
    // prune faded pointers
    const t = now();
    for (const [id,pt] of [...ptrs]) if (!pt.active && (t - pt.up) > P.decayHalf*3) ptrs.delete(id);

    writeUniforms();

    const enc  = device.createCommandEncoder();
    const tex  = ctx.getCurrentTexture();
    const pass = enc.beginRenderPass({
      colorAttachments: [{
        view: tex.createView(),
        loadOp: 'clear',
        clearValue: {r:0,g:0,b:0,a:1},
        storeOp: 'store'
      }]
    });
    pass.setPipeline(pipeline);
    pass.setBindGroup(0, bind);
    pass.draw(6);
    pass.end();
    device.queue.submit([enc.finish()]);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>