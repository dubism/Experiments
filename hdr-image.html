<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>Draggable f, f′, f″ — Calculus Visualizer</title>
<style>
  :root{
    --bg:#0b0c10; --panel:#12141a; --ink:#dfe6ee; --muted:#8b94a1;
    --blue:#0d6efd; --green:#2fb357; --red:#e05050; --grid:#1e2530; --zeroline:#2a3342;
    --accent:#ffd166; --gutter:26px;
  }
  html,body{height:100%; margin:0; background:var(--bg); color:var(--ink);
    font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, Arial;}
  /* fit small screens without scrolling */
  .wrap{max-width:1100px; margin:0 auto; padding:10px; min-height:100svh; box-sizing:border-box;}
  header{display:flex; gap:8px; align-items:center; justify-content:space-between; margin-bottom:8px; flex-wrap:wrap}
  header .left{display:flex; gap:6px; align-items:center; flex-wrap:wrap}
  header .right{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .pill{padding:4px 8px; border:1px solid #2a3342; border-radius:999px; font-size:11px; color:var(--muted);}
  button, select, input[type="range"]{background:var(--panel); color:var(--ink);
    border:1px solid #2a3342; border-radius:8px; padding:6px 8px; font-size:14px;}
  button:hover{border-color:#3a465a; cursor:pointer}
  .row{display:grid; gap:8px;}
  .pane{background:var(--panel); border:1px solid #202736; border-radius:10px; overflow:hidden; position:relative;}
  .pane header{padding:6px 8px; border-bottom:1px solid #202736; background:linear-gradient(to bottom, rgba(255,255,255,0.02), transparent)}
  .pane header h2{margin:0; font-size:12px; letter-spacing:.02em; color:var(--muted); font-weight:600}
  .pane .active-dot{width:8px; height:8px; border-radius:50%; display:inline-block; margin-right:6px; translate:0 1px}
  .pane .canvas-wrap{position:relative; height:180px;}
  canvas{display:block; width:100%; height:100%; touch-action:none;}
  .legend{position:absolute; top:6px; right:6px; background:rgba(0,0,0,.35); border:1px solid rgba(255,255,255,.08);
    border-radius:8px; padding:2px 6px; font-size:11px; color:#cbd5e1}
  .legend .b{color:var(--blue)} .legend .g{color:var(--green)} .legend .r{color:var(--red)}
  .bar{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  .bar label{font-size:12px; color:var(--muted); display:flex; align-items:center; gap:6px}
  .bar small{color:var(--muted); font-size:11px}
  .sep{width:1px; height:20px; background:#2a3342}
  .note{font-size:11px; color:#94a3b8; margin-top:6px}
  /* iPhone 15 Pro tuning (393×852 logical) */
  @media (max-width:420px){
    .pane .canvas-wrap{height:165px;}
    .pill{display:none;} /* save vertical space */
    .wrap{padding:8px;}
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div class="left">
      <div class="pill">Drag knots to edit. Drag anchors in left gutter to set C₀ (f at x₀) and C₁ (f′ at x₀).</div>
    </div>
    <div class="right bar">
      <label>Preset
        <select id="preset">
          <option value="sine">Sine</option>
          <option value="quadratic">Quadratic</option>
          <option value="bump">Cubic S-curve</option>
          <option value="flat">Flat</option>
        </select>
      </label>
      <span class="sep"></span>
      <label>Tension <input id="tension" type="range" min="0" max="0.9" step="0.05" value="0.25"></label>
      <span class="sep"></span>
      <label>Knots <input id="knots" type="range" min="2" max="20" step="1" value="25"></label>
      <small id="knotsLabel">K=25</small>
      <span class="sep"></span>
      <button id="reset">Reset</button>
    </div>
  </header>

  <div class="row">
    <section class="pane" data-pane="f">
      <header><span class="active-dot" style="background:var(--blue)"></span><h2>f(x)</h2></header>
      <div class="canvas-wrap"><canvas id="cv-f"></canvas><div class="legend">Active: <span id="active-label">f</span></div></div>
    </section>
    <section class="pane" data-pane="fp">
      <header><span class="active-dot" style="background:var(--green)"></span><h2>f′(x) — anchor C₀ in left gutter (f at x₀)</h2></header>
      <div class="canvas-wrap"><canvas id="cv-fp"></canvas></div>
    </section>
    <section class="pane" data-pane="fpp">
      <header><span class="active-dot" style="background:var(--red)"></span><h2>f″(x) — anchors: C₁ in f′ gutter and C₀ in f gutter</h2></header>
      <div class="canvas-wrap"><canvas id="cv-fpp"></canvas></div>
    </section>
  </div>
  <div class="note">All three panes share x ∈ [−10, 10]. Knots have fixed x, draggable y. Constants apply at x₀ = x<sub>min</sub>.</div>
</div>

<script>
(function(){
  // ---------- Config ----------
  const xMin = -10, xMax = 10;
  const N = 801;                        // dense samples
  let   K = 25;                         // knots (mutable by UI)
  const padTop=12, padRight=10, padBottom=18, padLeft=10;
  const gutterPx = 26;
  const colors = { f:'#0d6efd', fp:'#2fb357', fpp:'#e05050' };
  const zeroLine = css('--zeroline'); const gridColor = css('--grid');
  const ink = css('--ink'); const muted = css('--muted');

  const ranges = { f:{min:-2,max:2}, fp:{min:-2,max:2}, fpp:{min:-2,max:2} };
  let C0 = 0, C1 = 0; // integration constants at x0 = xMin
  let active = 'f';

  // Dense x sampling
  const xs = linspace(xMin, xMax, N);
  // Knots (mutable count)
  let knotXs = linspace(xMin, xMax, K);

  // Knot Y values per curve (arrays with length K)
  let kF = new Array(K).fill(0);
  let kFp = new Array(K).fill(0);
  let kFpp = new Array(K).fill(0);

  // Dense samples per curve
  let sF = new Array(N).fill(0);
  let sFp = new Array(N).fill(0);
  let sFpp = new Array(N).fill(0);

  // UI elements
  const cvF   = document.getElementById('cv-f');
  const cvFp  = document.getElementById('cv-fp');
  const cvFpp = document.getElementById('cv-fpp');
  const presetSel = document.getElementById('preset');
  const tensionSlider = document.getElementById('tension');
  const knotsSlider = document.getElementById('knots');
  const knotsLabel = document.getElementById('knotsLabel');
  const resetBtn = document.getElementById('reset');
  const activeLabel = document.getElementById('active-label');

  const panes = [
    { id:'f',   canvas:cvF },
    { id:'fp',  canvas:cvFp },
    { id:'fpp', canvas:cvFpp }
  ];

  // Responsive sizing
  function resizeAll(){
    for(const p of panes){
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const rect = p.canvas.getBoundingClientRect();
      p.canvas.width  = Math.max(340, Math.floor(rect.width * dpr));
      p.canvas.height = Math.max(140, Math.floor(rect.height * dpr));
      p.dpr = dpr;
    }
    redraw();
  }
  window.addEventListener('resize', resizeAll, {passive:true});

  // Init
  applyPreset('sine');
  recalcAllFromActive();
  resizeAll();
  updateKnotsLabel();

  // ---------- Interaction ----------
  const drag = { kind:null, pane:null, idx:-1 }; // 'knot'|'C0'|'C1'

  for(const p of panes){
    p.canvas.addEventListener('pointerdown', (ev)=>{
      p.canvas.setPointerCapture(ev.pointerId);
      const local = localPos(p.canvas, ev);
      const panel = p.id;

      if(active !== panel){ active = panel; activeLabel.textContent=labelFor(active); recalcAllFromActive(); redraw(); }

      if(panel==='f' && inGutter(local.x, p.canvas)) {
        drag.kind='C0'; drag.pane='f';
        updateC0FromPointer(local.y, p.canvas);
        redraw(); return;
      }
      if(panel==='fp' && inGutter(local.x, p.canvas)) {
        drag.kind='C1'; drag.pane='fp';
        updateC1FromPointer(local.y, p.canvas);
        redraw(); return;
      }

      drag.kind='knot'; drag.pane=panel;
      drag.idx = nearestKnotIndex(local.x, p.canvas);
      updateKnotFromPointer(local.y, p.canvas, panel, drag.idx);
      recalcAllFromActive(); redraw();
    });

    p.canvas.addEventListener('pointermove', (ev)=>{
      if(!drag.kind) return;
      const local = localPos(p.canvas, ev);
      if(drag.kind==='knot'){
        updateKnotFromPointer(local.y, p.canvas, drag.pane, drag.idx);
        recalcAllFromActive(); redraw();
      }else if(drag.kind==='C0'){
        updateC0FromPointer(local.y, p.canvas);
        if(active!=='f') recalcAllFromActive();
        redraw();
      }else if(drag.kind==='C1'){
        updateC1FromPointer(local.y, p.canvas);
        if(active==='fpp') recalcAllFromActive();
        redraw();
      }
    });

    const end = ()=>{ drag.kind=null; drag.pane=null; drag.idx=-1; };
    p.canvas.addEventListener('pointerup', end);
    p.canvas.addEventListener('pointercancel', end);
  }

  // Controls
  presetSel.addEventListener('change', ()=>{ applyPreset(presetSel.value); recalcAllFromActive(); redraw(); });
  tensionSlider.addEventListener('input', ()=>{ recalcAllFromActive(); redraw(); });
  resetBtn.addEventListener('click', ()=>{ applyPreset('flat'); C0=0; C1=0; recalcAllFromActive(); redraw(); });

  knotsSlider.addEventListener('input', ()=>{
    const newK = parseInt(knotsSlider.value, 10);
    updateKnotsCount(newK);
    updateKnotsLabel();
  });

  function updateKnotsLabel(){ knotsLabel.textContent = `K=${K}`; }

  // ---------- Knots count change (2–20) ----------
  function updateKnotsCount(newK){
    newK = Math.max(2, Math.min(20, newK));
    if(newK === K) return;

    // Use currently authoritative dense sample to generate new knot Y arrays
    const t = parseFloat(tensionSlider.value);
    // Ensure dense arrays reflect the authoritative curve
    recalcAllFromActive();

    const newKnotXs = linspace(xMin, xMax, newK);
    const srcSamples = (active==='f') ? sF : (active==='fp') ? sFp : sFpp;

    const newKF   = new Array(newK);
    const newKFp  = new Array(newK);
    const newKFpp = new Array(newK);

    // Sample each curve at new knot positions so visual shape is preserved
    for(let i=0;i<newK;i++){
      const x = newKnotXs[i];
      newKF[i]   = sampleAtX(sF,   x);
      newKFp[i]  = sampleAtX(sFp,  x);
      newKFpp[i] = sampleAtX(sFpp, x);
    }

    // Commit
    K = newK;
    knotXs = newKnotXs;
    kF = newKF; kFp = newKFp; kFpp = newKFpp;

    // Recompute everything from the same active source to keep the pipeline consistent
    recalcAllFromActive();
    redraw();
  }

  // ---------- Calculus core ----------
  function recalcAllFromActive(){
    const t = parseFloat(tensionSlider.value);
    if(active==='f'){
      sF = sampleSpline(kF, t);                 // f
      sFp = differentiate(sF);                  // f'
      sFpp = differentiate(sFp);                // f''
      kFp = sampleAtKnots(sFp);
      kFpp = sampleAtKnots(sFpp);
    } else if(active==='fp'){
      sFp = sampleSpline(kFp, t);               // f'
      const integF = integrate(sFp);            // -> f (+C0)
      for(let i=0;i<N;i++) sF[i] = integF[i] + C0;
      sFpp = differentiate(sFp);                // -> f''
      kF = sampleAtKnots(sF);
      kFpp = sampleAtKnots(sFpp);
    } else { // f''
      sFpp = sampleSpline(kFpp, t);             // f''
      const integFp = integrate(sFpp);          // -> f' (+C1)
      for(let i=0;i<N;i++) sFp[i] = integFp[i] + C1;
      const integF = integrate(sFp);            // -> f (+C0)
      for(let i=0;i<N;i++) sF[i] = integF[i] + C0;
      kFp = sampleAtKnots(sFp);
      kF  = sampleAtKnots(sF);
    }
  }

  function differentiate(arr){
    const out = new Array(N);
    const dx = (xMax - xMin)/(N-1);
    out[0] = (arr[1]-arr[0])/dx;
    for(let i=1;i<N-1;i++) out[i] = (arr[i+1]-arr[i-1])/(2*dx);
    out[N-1] = (arr[N-1]-arr[N-2])/dx;
    return out;
  }

  function integrate(arr){
    const out = new Array(N);
    const dx = (xMax - xMin)/(N-1);
    let acc = 0; out[0]=0;
    for(let i=1;i<N;i++){ acc += (arr[i-1] + arr[i]) * 0.5 * dx; out[i]=acc; }
    return out;
  }

  // ---------- Spline sampling ----------
  function sampleSpline(kY, tension){
    const out = new Array(N);
    const segCount = K-1;
    for(let i=0;i<N;i++){
      const u = i/(N-1);
      let s = u * segCount;
      let j = Math.floor(s);
      if(j>=K-1){ j = K-2; s = K-1; }
      const tt = s - j;
      const j0 = Math.max(0, j-1);
      const j1 = j;
      const j2 = Math.min(K-1, j+1);
      const j3 = Math.min(K-1, j+2);
      const p0 = kY[j0], p1 = kY[j1], p2 = kY[j2], p3 = kY[j3];
      const sFactor = (1 - tension) * 0.5;
      const m1 = sFactor * (p2 - p0);
      const m2 = sFactor * (p3 - p1);
      const t2 = tt*tt, t3 = t2*tt;
      const h00 =  2*t3 - 3*t2 + 1;
      const h10 =      t3 - 2*t2 + tt;
      const h01 = -2*t3 + 3*t2;
      const h11 =      t3 -   t2;
      out[i] = h00*p1 + h10*m1 + h01*p2 + h11*m2;
    }
    return out;
  }

  function sampleAtKnots(samples){
    const out = new Array(K);
    for(let i=0;i<K;i++){
      out[i] = sampleAtX(samples, knotXs[i]);
    }
    return out;
  }

  function sampleAtX(samples, x){
    const u = (x - xMin) / (xMax - xMin);
    const pos = u*(N-1);
    const i0 = clamp(Math.floor(pos), 0, N-1);
    const i1 = clamp(i0+1, 0, N-1);
    const t = pos - i0;
    return samples[i0]*(1-t) + samples[i1]*t;
  }

  // ---------- Drawing ----------
  function redraw(){
    drawPane('f',   cvF,   sF,   kF,   colors.f);
    drawPane('fp',  cvFp,  sFp,  kFp,  colors.fp);
    drawPane('fpp', cvFpp, sFpp, kFpp, colors.fpp);
  }

  function drawPane(paneId, canvas, samples, knotsY, color){
    const ctx = canvas.getContext('2d');
    const w = canvas.width, h = canvas.height;
    ctx.clearRect(0,0,w,h);

    const left = gutterPx + padLeft, top = padTop, right = w - padRight, bottom = h - padBottom;
    const plotW = right - left, plotH = bottom - top;

    // Background
    ctx.fillStyle = css('--panel'); ctx.fillRect(0,0,w,h);

    // Grid
    ctx.save(); ctx.beginPath(); ctx.rect(left, top, plotW, plotH); ctx.clip();
    ctx.strokeStyle = gridColor; ctx.lineWidth = 1;

    const r = ranges[paneId];
    const yStep = niceStep((r.max - r.min)/5);
    for(let y = Math.ceil(r.min/yStep)*yStep; y <= r.max; y += yStep){
      const py = yToPx(y, r, top, bottom);
      ctx.beginPath(); ctx.moveTo(left, py); ctx.lineTo(right, py); ctx.stroke();
    }
    const xStep = niceStep((xMax - xMin)/7);
    for(let x = Math.ceil(xMin/xStep)*xStep; x <= xMax; x += xStep){
      const px = xToPx(x, left, right);
      ctx.beginPath(); ctx.moveTo(px, top); ctx.lineTo(px, bottom); ctx.stroke();
    }
    // Zero lines
    ctx.strokeStyle = css('--zeroline'); ctx.lineWidth = 1.2;
    const y0px = yToPx(0, r, top, bottom);
    ctx.beginPath(); ctx.moveTo(left, y0px); ctx.lineTo(right, y0px); ctx.stroke();
    const x0px = xToPx(0, left, right);
    ctx.beginPath(); ctx.moveTo(x0px, top); ctx.lineTo(x0px, bottom); ctx.stroke();
    ctx.restore();

    // Curve
    ctx.save();
    ctx.beginPath();
    for(let i=0;i<N;i++){
      const px = xToPx(xs[i], left, right);
      const py = yToPx(samples[i], r, top, bottom);
      if(i===0) ctx.moveTo(px, py); else ctx.lineTo(px, py);
    }
    ctx.lineWidth = 2.1; ctx.strokeStyle = color; ctx.stroke();
    ctx.restore();

    // Knots
    const isActive = (active===paneId);
    for(let i=0;i<K;i++){
      const px = xToPx(knotXs[i], left, right);
      const py = yToPx(knotsY[i], r, top, bottom);
      ctx.beginPath(); ctx.arc(px, py, isActive? 4.4:3.4, 0, Math.PI*2);
      ctx.fillStyle = isActive? color : 'rgba(255,255,255,0.45)'; ctx.fill();
      if(isActive){ ctx.lineWidth=1; ctx.strokeStyle='rgba(0,0,0,0.5)'; ctx.stroke(); }
    }

    // Left gutter and anchors
    drawGutter(ctx, paneId, canvas, samples);

    // Tiny labels
    ctx.fillStyle = muted; ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(`x:[${xMin},${xMax}]`, left, top-2);
    ctx.textAlign='right';
    ctx.fillText(`y:[${r.min.toFixed(1)},${r.max.toFixed(1)}]`, right, top-2);
    ctx.textAlign='left';
  }

  function drawGutter(ctx, paneId, canvas){
    const h = canvas.height;
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(0, 0, gutterPx, h);
    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
    ctx.beginPath(); ctx.moveTo(gutterPx+0.5, 0); ctx.lineTo(gutterPx+0.5, h); ctx.stroke();

    if(paneId==='f'){
      const py = yToPx(C0, ranges.f, padTop, h - padBottom);
      drawAnchor(ctx, 6, py, 'C₀', '#ffd166');
    }
    if(paneId==='fp'){
      const py = yToPx(C1, ranges.fp, padTop, h - padBottom);
      drawAnchor(ctx, 6, py, 'C₁', '#a78bfa');
    }
  }

  function drawAnchor(ctx, x, y, label, col){
    ctx.save();
    ctx.strokeStyle = 'rgba(148,163,184,0.35)';
    ctx.beginPath(); ctx.moveTo(x, padTop); ctx.lineTo(x, ctx.canvas.height - padBottom); ctx.stroke();

    ctx.fillStyle = col; ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.beginPath(); roundedRect(ctx, x-7, y-7, 14, 14, 3); ctx.fill(); ctx.stroke();

    ctx.fillStyle = 'rgba(203,213,225,0.95)'; ctx.font = '11px system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(label, x+16, y+4);
    ctx.restore();
  }

  function roundedRect(ctx, x,y,w,h,r){
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
  }

  // ---------- Mapping & helpers ----------
  function xToPx(x, left, right){ return left + ((x - xMin) / (xMax - xMin)) * (right - left); }
  function yToPx(y, range, top, bottom){
    const u = (y - range.min) / (range.max - range.min);
    return bottom - u * (bottom - top);
  }
  function pxToY(py, canvas, paneId){
    const top = padTop, bottom = canvas.height - padBottom;
    const r = ranges[paneId];
    const u = clamp((bottom - py) / (bottom - top), 0, 1);
    return r.min + u * (r.max - r.min);
  }
  function inGutter(px, canvas){ return px <= gutterPx; }
  function nearestKnotIndex(px, canvas){
    const left = gutterPx + padLeft, right = canvas.width - padRight;
    const u = clamp((px - left) / (right - left), 0, 1);
    return clamp(Math.round(u * (K-1)), 0, K-1);
  }
  function updateKnotFromPointer(py, canvas, pane, idx){
    const y = pxToY(py, canvas, pane);
    if(pane==='f')   kF[idx] = y;
    if(pane==='fp')  kFp[idx] = y;
    if(pane==='fpp') kFpp[idx] = y;
  }
  function updateC0FromPointer(py, canvas){ C0 = pxToY(py, canvas, 'f'); }
  function updateC1FromPointer(py, canvas){ C1 = pxToY(py, canvas, 'fp'); }

  function linspace(a,b,n){ const out=new Array(n); const step=(b-a)/(n-1); for(let i=0;i<n;i++) out[i]=a+i*step; return out; }
  function clamp(x, lo, hi){ return Math.max(lo, Math.min(hi, x)); }
  function localPos(canvas, ev){
    const r = canvas.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio||1);
    return { x:(ev.clientX - r.left) * dpr, y:(ev.clientY - r.top) * dpr };
  }
  function labelFor(a){ return a==='f'?'f':(a==='fp'?'f′':'f″'); }
  function niceStep(rough){
    const pow = Math.pow(10, Math.floor(Math.log10(rough)));
    const base = rough / pow;
    const niceBase = base<1.5?1: base<3?2: base<7?5:10;
    return niceBase * pow;
  }
  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }

  // ---------- Presets ----------
  function applyPreset(name){
    if(name==='sine'){
      for(let i=0;i<K;i++){ const x=knotXs[i]; kF[i]=Math.sin((Math.PI*2 * x)/(xMax-xMin)); }
      active='f'; activeLabel.textContent=labelFor(active); C0=0; C1=0;
    } else if(name==='quadratic'){
      for(let i=0;i<K;i++){ const x=knotXs[i]; kF[i]= 0.15*(x*x) - 3; }
      active='f'; activeLabel.textContent=labelFor(active); C0=0; C1=0;
    } else if(name==='bump'){
      for(let i=0;i<K;i++){ const x=(knotXs[i]-(-2))/3.2; kF[i]=Math.exp(-x*x)-0.2*Math.exp(-(x*1.7)*(x*1.7)); }
      active='f'; activeLabel.textContent=labelFor(active); C0=0; C1=0;
    } else { // flat
      for(let i=0;i<K;i++){ kF[i]=0; kFp[i]=0; kFpp[i]=0; }
      active='f'; activeLabel.textContent=labelFor(active); C0=0; C1=0;
    }
  }

})();
</script>
</body>
</html>