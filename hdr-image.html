<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>SDR→HDR Value-Only Brush (WebGPU)</title>
<style>
  html, body { margin:0; height:100%; background:#000; }
  body { overflow:hidden; }
  canvas {
    width:100vw; height:100vh; display:block;
    dynamic-range-limit: no-limit;
    touch-action: none;                 /* hint for Pointer Events */
    -webkit-touch-callout: none;        /* kill iOS magnifier */
    -webkit-user-select: none;
    user-select: none;
  }
  :root { color-gamut: p3; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(async () => {
  const canvas = document.getElementById('c');

  // Hard-stop default gestures (iOS)
  canvas.style.touchAction = 'none';
  const stop = e => { e.preventDefault(); };
  canvas.addEventListener('gesturestart', stop, {passive:false});
  canvas.addEventListener('gesturechange', stop, {passive:false});
  canvas.addEventListener('gestureend', stop, {passive:false});

  // --- If WebGPU is missing, show SDR baseline (still eats touches to avoid magnifier) ---
  const noGPUFallback = () => {
    const ctx = canvas.getContext('2d', { alpha:false });
    const hsv2rgb = (h,s,v) => {
      const i = Math.floor(h*6), f = h*6 - i;
      const p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
      switch (i%6) { case 0:return [v,t,p]; case 1:return [q,v,p];
        case 2:return [p,v,t]; case 3:return [p,q,v];
        case 4:return [t,p,v]; default:return [v,p,q]; }
    };
    const resize = () => {
      const dpr = Math.max(1, window.devicePixelRatio||1);
      canvas.width = Math.floor(canvas.clientWidth*dpr);
      canvas.height= Math.floor(canvas.clientHeight*dpr);
      const w=canvas.width,h=canvas.height, img=ctx.createImageData(w,h);
      for (let y=0;y<h;y++){
        const v=y/(h-1), s=Math.max(0,1-v);
        for (let x=0;x<w;x++){
          const H=x/(w-1), rgb=hsv2rgb(H,s,v), i=(y*w+x)*4;
          img.data[i]=rgb[0]*255; img.data[i+1]=rgb[1]*255; img.data[i+2]=rgb[2]*255; img.data[i+3]=255;
        }
      }
      ctx.putImageData(img,0,0);
    };
    window.addEventListener('resize', resize, {passive:true});
    resize();

    // Eat pointer events so iOS doesn’t show magnifier
    const eat = e => { e.preventDefault(); };
    canvas.addEventListener('pointerdown', eat, {passive:false});
    canvas.addEventListener('pointermove', eat, {passive:false});
    canvas.addEventListener('pointerup', eat, {passive:false});
    canvas.addEventListener('pointercancel', eat, {passive:false});
  };

  if (!('gpu' in navigator)) { noGPUFallback(); return; }

  // --- WebGPU path (same as before, with preventDefault on pointers) ---
  const adapter = await navigator.gpu.requestAdapter().catch(()=>null);
  if (!adapter) { noGPUFallback(); return; }
  const device = await adapter.requestDevice().catch(()=>null);
  if (!device) { noGPUFallback(); return; }

  const ctx = canvas.getContext('webgpu', { alphaMode:'opaque', colorSpace:'display-p3' });
  const preferredFormat = navigator.gpu.getPreferredCanvasFormat();
  const configure = () => {
    const dpr = Math.max(1, window.devicePixelRatio||1);
    canvas.width = Math.floor(canvas.clientWidth*dpr);
    canvas.height= Math.floor(canvas.clientHeight*dpr);
    ctx.configure({ device, format: preferredFormat, alphaMode:'opaque', colorSpace:'display-p3' });
    allocateLiftTextures();
  };

  const LIFT_SCALE = 0.5;
  let liftW=0,liftH=0,liftA=null,liftB=null;
  function allocateLiftTextures(){
    const w=Math.max(2, Math.floor(canvas.width*LIFT_SCALE));
    const h=Math.max(2, Math.floor(canvas.height*LIFT_SCALE));
    if (w===liftW && h===liftH && liftA) return;
    liftW=w; liftH=h;
    const desc={ size:[w,h], format:'rgba16float', usage: GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING };
    liftA?.destroy?.(); liftB?.destroy?.();
    liftA=device.createTexture(desc); liftB=device.createTexture(desc);
    const enc=device.createCommandEncoder();
    for (const tex of [liftA,liftB]){
      const pass=enc.beginRenderPass({colorAttachments:[{view:tex.createView(),loadOp:'clear',storeOp:'store',clearValue:{r:0,g:0,b:0,a:1}}]});
      pass.end();
    }
    device.queue.submit([enc.finish()]);
  }

  const MAX_PTR=10;
  let liftGlobalsBuf, liftPtrsBuf, compGlobalsBuf;
  const sampler = device.createSampler({ minFilter:'linear', magFilter:'linear' });
  const liftWGSL=`struct Globals{liftSize:vec2<f32>,canvasSize:vec2<f32>,dt:f32,ramp:f32,decayK:f32,flow:f32,headroom:f32;};
struct Ptr{x:f32;y:f32;age:f32;flags:f32;};
@group(0) @binding(0) var samp:sampler;
@group(0) @binding(1) var liftPrev:texture_2d<f16>;
@group(0) @binding(2) var<uniform> G:Globals;
@group(0) @binding(3) var<uniform> P:array<Ptr,${MAX_PTR}>;
struct V{ @builtin(position) p:vec4<f32>; @location(0) uv:vec2<f32>; };
@vertex fn vs(@builtin(vertex_index) i:u32)->V{ var q=array<vec2<f32>,6>(vec2(-1.,-1.),vec2(1.,-1.),vec2(-1.,1.),vec2(-1.,1.),vec2(1.,-1.),vec2(1.,1.)); var o:V; o.p=vec4(q[i],0.,1.); o.uv=q[i]*0.5+vec2(0.5); return o;}
fn gauss(r:f32,s:f32)->f32{ let s2=s*s; return exp(-0.5*(r*r)/s2); }
@fragment fn fs(@location(0) uv:vec2<f32>)->@location(0) vec4<f16>{
  let prev=textureSampleLevel(liftPrev,samp,uv,0.0).r;
  let decay=exp(-G.decayK*G.dt);
  var lift=f32(prev)*decay;
  let px=uv.x*G.liftSize.x; let py=uv.y*G.liftSize.y;
  for (var i=0u;i<${MAX_PTR}u;i=i+1u){
    let p=P[i];
    let active = select(0.0,1.0,(u32(p.flags)&1u)==1u);
    let rampT = clamp(p.age/max(G.ramp,1e-4),0.0,1.0);
    let lp = clamp((p.age-0.6)/0.8,0.0,1.0);
    let gain = 1.0 + lp*0.5;
    let sigma = (min(G.canvasSize.x,G.canvasSize.y)*${LIFT_SCALE.toFixed(2)}*0.06)*gain;
    let dx=px-(p.x*G.liftSize.x); let dy=py-(p.y*G.liftSize.y);
    let r=sqrt(dx*dx+dy*dy);
    let g=gauss(r,sigma);
    lift += active * rampT * G.flow * G.dt * g * gain;
  }
  return vec4<f16>(f16(lift), f16(0.), f16(0.), f16(1.));
}`;
  const compWGSL=`struct G{canvasSize:vec2<f32>;headroom:f32;ditherAmp:f32;};
@group(0) @binding(0) var samp:sampler;
@group(0) @binding(1) var L:texture_2d<f16>;
@group(0) @binding(2) var<uniform> U:G;
struct V{@builtin(position) p:vec4<f32>; @location(0) uv:vec2<f32>;};
@vertex fn vs(@builtin(vertex_index) i:u32)->V{ var q=array<vec2<f32>,6>(vec2(-1.,-1.),vec2(1.,-1.),vec2(-1.,1.),vec2(-1.,1.),vec2(1.,-1.),vec2(1.,1.)); var o:V; o.p=vec4(q[i],0.,1.); o.uv=q[i]*0.5+vec2(0.5); return o;}
fn hsv2rgb(h:f32,s:f32,v:f32)->vec3<f32>{ let six=h*6.0; let i=floor(six); let f=six-i; let p=v*(1.0-s); let q=v*(1.0-f*s); let t=v*(1.0-(1.0-f)*s);
  switch(i%6.0){ case 0.0:return vec3(v,t,p); case 1.0:return vec3(q,v,p); case 2.0:return vec3(p,v,t); case 3.0:return vec3(p,q,v); case 4.0:return vec3(t,p,v); default:return vec3(v,p,q);} }
fn hash21(p:vec2<f32>)->f32{ let a=dot(p,vec2(127.1,311.7)); return fract(sin(a)*43758.5453); }
@fragment fn fs(@location(0) uv:vec2<f32>, @builtin(position) pos:vec4<f32>)->@location(0) vec4<f32>{
  let H=clamp(uv.x,0.0,1.0);
  let V0=clamp(uv.y,0.0,1.0);
  let S=clamp(1.0-uv.y,0.0,1.0);
  let Lf=f32(textureSampleLevel(L,samp,uv,0.0).r);
  var V=V0+Lf;
  V=min(V,U.headroom);
  let d=(hash21(pos.xy)-0.5)*U.ditherAmp;
  V=max(0.0,V+d);
  let rgb=hsv2rgb(H,S,V);
  return vec4(rgb,1.0);
}`;
  const liftModule=device.createShaderModule({code:liftWGSL});
  const compModule=device.createShaderModule({code:compWGSL});
  const liftPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:liftModule,entryPoint:'vs'},fragment:{module:liftModule,entryPoint:'fs',targets:[{format:'rgba16float'}]}});
  const compPipeline=device.createRenderPipeline({layout:'auto',vertex:{module:compModule,entryPoint:'vs'},fragment:{module:compModule,entryPoint:'fs',targets:[{format:preferredFormat}]}});

  let bgLiftA,bgLiftB,bgCompFromA,bgCompFromB;
  function rebuildBindGroups(){
    liftGlobalsBuf=device.createBuffer({size:64,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});
    liftPtrsBuf   =device.createBuffer({size:16*MAX_PTR,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});
    compGlobalsBuf=device.createBuffer({size:32,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});
    bgLiftA=device.createBindGroup({layout:liftPipeline.getBindGroupLayout(0),entries:[
      {binding:0,resource:sampler}, {binding:1,resource:liftA.createView()},
      {binding:2,resource:{buffer:liftGlobalsBuf}}, {binding:3,resource:{buffer:liftPtrsBuf}}
    ]});
    bgLiftB=device.createBindGroup({layout:liftPipeline.getBindGroupLayout(0),entries:[
      {binding:0,resource:sampler}, {binding:1,resource:liftB.createView()},
      {binding:2,resource:{buffer:liftGlobalsBuf}}, {binding:3,resource:{buffer:liftPtrsBuf}}
    ]});
    bgCompFromA=device.createBindGroup({layout:compPipeline.getBindGroupLayout(0),entries:[
      {binding:0,resource:sampler},{binding:1,resource:liftA.createView()},{binding:2,resource:{buffer:compGlobalsBuf}}
    ]});
    bgCompFromB=device.createBindGroup({layout:compPipeline.getBindGroupLayout(0),entries:[
      {binding:0,resource:sampler},{binding:1,resource:liftB.createView()},{binding:2,resource:{buffer:compGlobalsBuf}}
    ]});
  }

  const pointers=new Map();
  const state={ lastTime: performance.now()/1000,
    ramp:0.25, decayHalfLife:1.2, flowPerSecond:0.7, headroom:3.5 };
  const toNorm=(cx,cy)=>{ const r=canvas.getBoundingClientRect(); const dpr=Math.max(1,window.devicePixelRatio||1);
    const x=(cx-r.left)*dpr, y=(cy-r.top)*dpr; return {nx:x/Math.max(1,Math.floor(canvas.width*LIFT_SCALE)), ny:y/Math.max(1,Math.floor(canvas.height*LIFT_SCALE))}; };

  const onDown=e=>{ e.preventDefault();
    canvas.setPointerCapture(e.pointerId);
    const t=performance.now()/1000; const {nx,ny}=toNorm(e.clientX,e.clientY);
    pointers.set(e.pointerId,{nx,ny,downTime:t,isActive:1});
  };
  const onMove=e=>{ e.preventDefault();
    const p=pointers.get(e.pointerId); if(!p) return;
    const {nx,ny}=toNorm(e.clientX,e.clientY); p.nx=nx; p.ny=ny;
  };
  const onUp=e=>{ e.preventDefault();
    const p=pointers.get(e.pointerId); if(p){ p.isActive=0; } canvas.releasePointerCapture?.(e.pointerId);
  };

  canvas.addEventListener('pointerdown', onDown, {passive:false});
  canvas.addEventListener('pointermove', onMove, {passive:false});
  canvas.addEventListener('pointerup', onUp, {passive:false});
  canvas.addEventListener('pointercancel', onUp, {passive:false});
  window.addEventListener('resize', () => { configure(); rebuildBindGroups(); }, {passive:true});

  const writeUniforms=(dt)=>{
    const decayK=Math.log(2)/Math.max(0.001,state.decayHalfLife);
    const g=new Float32Array([ Math.floor(canvas.width*LIFT_SCALE), Math.floor(canvas.height*LIFT_SCALE),
      canvas.width, canvas.height, dt, 0.25, decayK, state.flowPerSecond, state.headroom ]);
    device.queue.writeBuffer(liftGlobalsBuf,0,g);

    const now=performance.now()/1000; const P=new Float32Array(4*MAX_PTR); let i=0;
    for(const [id,p] of pointers){
      P[i*4+0]=p.nx; P[i*4+1]=p.ny; P[i*4+2]=now-p.downTime; P[i*4+3]=p.isActive?1:0; i++; if(i>=MAX_PTR)break;
      if(!p.isActive && now-p.downTime>4) pointers.delete(id);
    }
    device.queue.writeBuffer(liftPtrsBuf,0,P);

    const comp=new Float32Array([canvas.width,canvas.height,state.headroom,1/1023]);
    device.queue.writeBuffer(compGlobalsBuf,0,comp);
  };

  let useA=true;
  const frame=()=>{
    const t=performance.now()/1000;
    const dt=Math.min(0.05, Math.max(0.0005, t - state.lastTime));
    state.lastTime=t;
    writeUniforms(dt);

    const enc=device.createCommandEncoder();

    // update lift (ping-pong)
    const pass1=enc.beginRenderPass({colorAttachments:[{view:(useA?liftB:liftA).createView(),loadOp:'clear',storeOp:'store',clearValue:{r:0,g:0,b:0,a:1}}]});
    pass1.setPipeline(liftPipeline);
    pass1.setBindGroup(0, useA?bgLiftA:bgLiftB);
    pass1.draw(6);
    pass1.end();

    // composite
    const view=ctx.getCurrentTexture().createView();
    const pass2=enc.beginRenderPass({colorAttachments:[{view,loadOp:'clear',storeOp:'store',clearValue:{r:0,g:0,b:0,a:1}}]});
    pass2.setPipeline(compPipeline);
    pass2.setBindGroup(0, useA?bgCompFromA:bgCompFromB);
    pass2.draw(6);
    pass2.end();

    device.queue.submit([enc.finish()]);
    useA=!useA;
    requestAnimationFrame(frame);
  };

  configure(); rebuildBindGroups(); requestAnimationFrame(frame);
})();
</script>
</body>
</html>