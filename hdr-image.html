<!doctype html><html lang="en"><head>
<meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Value-Only HDR Brush â€” WebGL2 fast</title>
<style>
  html,body{margin:0;height:100%;background:#000} body{overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}
</style>
</head><body>
<canvas id="cv"></canvas>
<script>
(() => {
  const cvs = document.getElementById('cv');
  const stop=e=>e.preventDefault();
  for (const ev of ['gesturestart','gesturechange','gestureend','touchstart','touchmove','touchend'])
    cvs.addEventListener(ev, stop, {passive:false});
  cvs.addEventListener('pointerdown',e=>{e.preventDefault();cvs.setPointerCapture(e.pointerId);down(e)}, {passive:false});
  cvs.addEventListener('pointermove',e=>{e.preventDefault();move(e)}, {passive:false});
  cvs.addEventListener('pointerup',  e=>{e.preventDefault();up(e)},   {passive:false});
  cvs.addEventListener('pointercancel',e=>{e.preventDefault();up(e)}, {passive:false});

  // ---- GL init
  const gl = cvs.getContext('webgl2', {alpha:false,antialias:false,desynchronized:true});
  if (!gl) { document.body.style.background='#111'; return; }
  const fit = () => {
    const dpr = Math.max(1, devicePixelRatio||1);
    const w = Math.max(2, Math.floor(cvs.clientWidth*dpr));
    const h = Math.max(2, Math.floor(cvs.clientHeight*dpr));
    if (cvs.width!==w || cvs.height!==h) { cvs.width=w; cvs.height=h; gl.viewport(0,0,w,h); }
  };
  addEventListener('resize', fit, {passive:true}); fit();

  const MAX_PTR = 12;
  const VS = `#version 300 es
  layout(location=0) in vec2 a; out vec2 uv;
  void main(){ uv=a*0.5+0.5; gl_Position=vec4(a,0,1); }`;

  const FS = `#version 300 es
  precision highp float;
  in vec2 uv; out vec4 frag;
  uniform vec4 U0;   // time, W, H, headroom (unused in SDR)
  uniform vec4 U1;   // ramp, decayK, flow, sigma
  uniform vec4 U2;   // longT, longGain, ditherAmp, count
  // pointers packed as 2 vec4 each: (x,y,downT,upT) and (active,_,_,_)
  const int MAX_PTR = ${MAX_PTR};
  uniform vec4 PTR[${MAX_PTR*2}];

  float gauss(float r, float s){ return exp(-0.5*(r*r)/(s*s)); }
  vec3 hsv2rgb(float h,float s,float v){
    float six=h*6.0, i=floor(six), f=six-i;
    float p=v*(1.0-s), q=v*(1.0-f*s), t=v*(1.0-(1.0-f)*s);
    if (mod(i,6.0)==0.0) return vec3(v,t,p);
    if (mod(i,6.0)==1.0) return vec3(q,v,p);
    if (mod(i,6.0)==2.0) return vec3(p,v,t);
    if (mod(i,6.0)==3.0) return vec3(p,q,v);
    if (mod(i,6.0)==4.0) return vec3(t,p,v);
    return vec3(v,p,q);
  }
  float hash21(vec2 p){ return fract(sin(dot(p, vec2(127.1,311.7)))*43758.5453); }

  void main(){
    float time = U0.x, W = U0.y, H = U0.z;
    float ramp = U1.x, decayK = U1.y, flow = U1.z, sigma = U1.w;
    float longT = U2.x, longGain = U2.y, ditherAmp = U2.z, count = U2.w;

    // SDR rainbow baseline: H=x, V=y, S=1-y
    float Hh = clamp(uv.x,0.0,1.0);
    float V0 = clamp(uv.y,0.0,1.0);
    float Ss = clamp(1.0 - uv.y, 0.0, 1.0);

    // Pixel coords
    float x = uv.x * W, y = uv.y * H;

    // Analytic lift from all pointers
    float lift = 0.0;
    for (int i=0;i<MAX_PTR;i++){
      if (float(i) >= count) break;
      vec4 A = PTR[i*2+0];
      vec4 B = PTR[i*2+1];
      float px=A.x, py=A.y, downT=A.z, upT=A.w, active=B.x;

      float dx=x-px, dy=y-py, r=length(vec2(dx,dy));
      float age = time - downT;
      float lp  = clamp((age - longT)/0.8, 0.0, 1.0);
      float gain = 1.0 + lp*longGain;
      float sig  = sigma * gain;

      float rampT = clamp(age / max(ramp, 1e-4), 0.0, 1.0);
      float tUp = max(0.0, time - upT);
      float decayMul = exp(-decayK * tUp);

      float center = flow * (active * rampT + (1.0 - active) * rampT * decayMul);
      lift += center * gauss(r, sig) * gain;
    }

    float V = max(0.0, V0 + lift);
    // Tiny dither to reduce SDR banding
    V = max(0.0, V + (hash21(gl_FragCoord.xy)-0.5)*ditherAmp);

    frag = vec4(hsv2rgb(Hh,Ss,V), 1.0);
  }`;

  function sh(type,src){ const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(s)); return s; }
  const prog = gl.createProgram();
  gl.attachShader(prog, sh(gl.VERTEX_SHADER, VS));
  gl.attachShader(prog, sh(gl.FRAGMENT_SHADER, FS));
  gl.linkProgram(prog);
  if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
  gl.useProgram(prog);

  // Fullscreen tri
  const vb = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, vb);
  gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,-1, 3,-1, -1,3]), gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

  // Uniforms
  const U0=gl.getUniformLocation(prog,'U0');
  const U1=gl.getUniformLocation(prog,'U1');
  const U2=gl.getUniformLocation(prog,'U2');
  const U_PTR = Array.from({length:MAX_PTR*2},(_,i)=> gl.getUniformLocation(prog,`PTR[${i}]`));

  // Brush params (same feel as before)
  const P = { ramp:0.25, decayHalf:1.2, flow:0.7, baseSigma:130, longT:0.6, longGain:0.5 };
  const pointers = new Map();
  const now=()=>performance.now()/1000;

  function dprSigma(){ return P.baseSigma * Math.max(1, devicePixelRatio||1); }

  function pos(e){
    const r=cvs.getBoundingClientRect(), dpr=Math.max(1,devicePixelRatio||1);
    return {x:(e.clientX-r.left)*dpr, y:(e.clientY-r.top)*dpr};
  }
  function down(e){
    const t=now(), p=pos(e);
    pointers.set(e.pointerId, {x:p.x,y:p.y,down:t,up:t,active:1});
  }
  function move(e){
    const pt=pointers.get(e.pointerId); if(!pt) return;
    const p=pos(e); pt.x=p.x; pt.y=p.y;
  }
  function up(e){
    const pt=pointers.get(e.pointerId); if(pt){ pt.active=0; pt.up=now(); }
  }

  function frame(){
    fit();
    const t=now(), W=cvs.width, H=cvs.height;
    const decayK = Math.log(2)/Math.max(0.001, P.decayHalf);
    gl.uniform4f(U0, t, W, H, 3.5);
    gl.uniform4f(U1, P.ramp, decayK, P.flow, dprSigma());
    gl.uniform4f(U2, P.longT, P.longGain, 1/1023, Math.min(MAX_PTR, pointers.size));

    let i=0;
    for (const [,pt] of pointers){
      gl.uniform4f(U_PTR[i*2+0], pt.x, pt.y, pt.down, pt.up);
      gl.uniform4f(U_PTR[i*2+1], pt.active?1:0, 0,0,0);
      i++; if (i>=MAX_PTR) break;
    }
    // prune old
    for (const [id,pt] of pointers) if (!pt.active && (t-pt.up) > P.decayHalf*3) pointers.delete(id);

    gl.disable(gl.BLEND);
    gl.drawArrays(gl.TRIANGLES, 0, 3);
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body></html>