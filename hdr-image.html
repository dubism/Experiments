<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>HDR Brush — Safari 26 (DPR + vivid baseline)</title>
<style>
  html,body{margin:0;height:100vh;overflow:hidden;background:#000}
  html,body,canvas{
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none; -webkit-tap-highlight-color: rgba(0,0,0,0);
    touch-action:none; /* deliver pointer events to canvas */
  }
  canvas{display:block;width:100vw;height:100vh;dynamic-range-limit:no-limit}
  #log{
    position:fixed;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);
    color:#fff;font:12px ui-monospace,monospace;padding:6px 8px;max-height:45vh;
    overflow:auto;white-space:pre-wrap;pointer-events:none
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<pre id="log"></pre>
<script>
(async()=>{
  const cvs = document.getElementById('cv');
  const logEl = document.getElementById('log');
  const log = (...a)=>{ logEl.textContent += a.map(v=> typeof v==='string'? v: JSON.stringify(v)).join(' ') + '\n';
                        logEl.scrollTop = logEl.scrollHeight; console.log(...a); };

  // Block only pinch/rotate globally (do NOT block touchstart/move/end)
  const stop = e => e.preventDefault();
  for (const ev of ['gesturestart','gesturechange','gestureend'])
    addEventListener(ev, stop, {passive:false});

  // ---------- DPR-aware sizing ----------
  const dpr = ()=> Math.max(1, devicePixelRatio||1);
  function size(){
    const k = dpr();
    const w = Math.max(2, Math.round(cvs.clientWidth  * k));
    const h = Math.max(2, Math.round(cvs.clientHeight * k));
    const changed = (cvs.width!==w || cvs.height!==h);
    if (changed){ cvs.width = w; cvs.height = h; }
    return changed;
  }
  addEventListener('resize', ()=>{ if(size()) configure(); }, {passive:true});
  size();

  // ---------- WebGPU setup with guards ----------
  if (!('gpu' in navigator)) { log('ERR: navigator.gpu missing'); return; }
  const adapter = await navigator.gpu.requestAdapter().catch(e=>log('adapter err',e));
  if (!adapter) { log('ERR: requestAdapter() returned null'); return; }
  const device  = await adapter.requestDevice().catch(e=>log('device err',e));
  if (!device)  { log('ERR: requestDevice failed'); return; }

  const ctx = cvs.getContext('webgpu', {alphaMode:'opaque'});
  if (!ctx) { log('ERR: getContext("webgpu") failed'); return; }
  const format = navigator.gpu.getPreferredCanvasFormat();

  function configure(){
    try {
      ctx.configure({ device, format, alphaMode:'opaque' });
      log('configured', {w:cvs.width, h:cvs.height, format});
      // write size to uniforms after reconfigure
      writeU();
    } catch(e) { log('ERR configure', e); }
  }
  configure();

  // ---------- WGSL (no structs/varyings) ----------
  const wgsl = `
@group(0) @binding(0) var<uniform> Upos : vec4<f32>; // x,y,active,radius  (device px)
@group(0) @binding(1) var<uniform> Upar : vec4<f32>; // gain,headroom,width,height (device px)

@vertex
fn vs(@builtin(vertex_index) i:u32) -> @builtin(position) vec4<f32> {
  let q:array<vec2<f32>,6> = array<vec2<f32>,6>(
    vec2<f32>(-1.0,-1.0), vec2<f32>( 1.0,-1.0), vec2<f32>(-1.0, 1.0),
    vec2<f32>(-1.0, 1.0), vec2<f32>( 1.0,-1.0), vec2<f32>( 1.0, 1.0)
  );
  return vec4<f32>(q[i], 0.0, 1.0);
}

fn hsv2rgb(h:f32, s:f32, v:f32) -> vec3<f32> {
  let hh = h * 6.0;
  let i  = u32(floor(hh));
  let f  = fract(hh);
  let p  = v * (1.0 - s);
  let q  = v * (1.0 - f*s);
  let t  = v * (1.0 - (1.0 - f)*s);
  if (i == 0u) { return vec3<f32>(v, t, p); }
  else if (i == 1u) { return vec3<f32>(q, v, p); }
  else if (i == 2u) { return vec3<f32>(p, v, t); }
  else if (i == 3u) { return vec3<f32>(p, q, v); }
  else if (i == 4u) { return vec3<f32>(t, p, v); }
  else { return vec3<f32>(v, p, q); }
}

@fragment
fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
  // Reconstruct uv from framebuffer position (device px)
  let res = vec2<f32>(Upar.z, Upar.w);
  let uv  = pos.xy / res;

  // FULL-COLOR baseline: S=1, V=1 → vivid rainbow, not dim
  let base = hsv2rgb(clamp(uv.x,0.0,1.0), 1.0, 1.0);

  // Value-only lift under finger (same hue/sat, brighter)
  var factor = 1.0;
  if (Upos.z > 0.5) {
    let r = max(1.0, Upos.w);
    let d = distance(pos.xy, Upos.xy);
    let lift = exp(-0.5 * (d/r) * (d/r)) * Upar.x; // gain
    factor += lift;
  }

  // Clamp only to HDR headroom
  let rgb = min(base * factor, vec3<f32>(Upar.y, Upar.y, Upar.y));
  return vec4<f32>(rgb, 1.0);
}
`;
  const module = device.createShaderModule({code: wgsl});
  const info = await module.getCompilationInfo?.();
  if (info?.messages?.length) info.messages.forEach(m=>log(`${m.type} ${m.lineNum}:${m.linePos} ${m.message}`));

  let pipeline;
  try {
    pipeline = device.createRenderPipeline({
      layout:'auto',
      vertex:{module, entryPoint:'vs'},
      fragment:{module, entryPoint:'fs', targets:[{format}]}
    });
  } catch(e) { log('ERR createRenderPipeline', e); return; }

  // ---------- Uniforms (256B each for safety) ----------
  const bufA = device.createBuffer({size:256, usage:GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST});
  const bufB = device.createBuffer({size:256, usage:GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST});
  const bind = device.createBindGroup({
    layout: pipeline.getBindGroupLayout(0),
    entries: [
      {binding:0, resource:{buffer:bufA}},
      {binding:1, resource:{buffer:bufB}}
    ]
  });

  // State + writers
  const st = { x:0, y:0, active:0, radius:120, gain:0.9, headroom:3.5 };
  function writeU(){
    device.queue.writeBuffer(bufA, 0, new Float32Array([st.x, st.y, st.active, st.radius]));
    device.queue.writeBuffer(bufB, 0, new Float32Array([st.gain, st.headroom, cvs.width, cvs.height]));
  }
  writeU();

  // ---------- Pointer input (DPR-aligned) ----------
  function pt(e){
    const r = cvs.getBoundingClientRect(), k = dpr();
    const x = (e.clientX - r.left) * k, y = (e.clientY - r.top) * k;
    return { x: Math.min(Math.max(0,x), cvs.width-1), y: Math.min(Math.max(0,y), cvs.height-1) };
  }

  cvs.addEventListener('pointerdown', e=>{
    try{
      e.preventDefault();
      cvs.setPointerCapture?.(e.pointerId);
      const p = pt(e);
      st.x=p.x; st.y=p.y; st.active=1; writeU();
    }catch(err){ log('pd err',err); }
  }, {passive:false});

  cvs.addEventListener('pointermove', e=>{
    if(!st.active) return;
    e.preventDefault();
    const p = pt(e);
    st.x=p.x; st.y=p.y; writeU();
  }, {passive:false});

  const pend = e=>{ e.preventDefault(); st.active=0; writeU(); };
  cvs.addEventListener('pointerup', pend, {passive:false});
  cvs.addEventListener('pointercancel', pend, {passive:false});

  // ---------- Render loop with swapchain guard ----------
  function frame(){
    try{
      const enc = device.createCommandEncoder();
      const pass = enc.beginRenderPass({
        colorAttachments:[{
          view: ctx.getCurrentTexture().createView(),
          loadOp:'clear', clearValue:{r:0,g:0,b:0,a:1}, storeOp:'store'
        }]
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0, bind);
      pass.draw(6);
      pass.end();
      device.queue.submit([enc.finish()]);
    }catch(e){
      log('ERR frame, reconfiguring', e);
      configure();
    }
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>