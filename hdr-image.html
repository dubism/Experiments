<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>HDR Image — Live SDR Tone + HDR Toggle (iOS 26)</title>
<meta name="color-scheme" content="dark light">
<style>
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font:14px/1.5 -apple-system,system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
    background:#0b0b0d; color:#e9ecf1; display:flex; flex-direction:column;
  }

  /* Controls */
  .controls{
    position:sticky; top:0; z-index:10; padding:12px 16px; gap:10px; display:grid;
    background:rgba(12,12,14,.72); backdrop-filter:blur(10px) saturate(120%);
    border-bottom:1px solid rgba(255,255,255,.12);
  }
  .row{display:flex; flex-wrap:wrap; gap:14px 18px; align-items:center}
  .label{display:inline-flex; gap:8px; align-items:center; white-space:nowrap; font-variant-numeric:tabular-nums}
  input[type="range"]{inline-size:200px; accent-color:#62c1ff}
  .tag{font-size:12px; padding:2px 8px; border-radius:999px; border:1px solid rgba(255,255,255,.18); background:rgba(255,255,255,.06)}
  .warn{color:#ffd8a8} .muted{color:#b7bcc7}

  /* Stage */
  .stage{flex:1; display:grid; place-items:center; padding:20px 16px 40px}
  .frame{
    position:relative;
    width:min(92vw,1200px); height:56.25vw; /* temporary 16:9 until first image loads */
    max-width:1200px; max-height:80vh;
    background:#0f1013; border:1px solid rgba(255,255,255,.08);
    border-radius:12px; overflow:hidden;
    transition:width .12s ease, height .12s ease;
  }

  /* SDR base: canvas renderer */
  .base{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
  }
  canvas{display:block; width:100%; height:100%;}

  /* HDR overlay: identical image element, no filters */
  .hdr{
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    pointer-events:none; z-index:2;
    dynamic-range-limit:no-limit; /* iOS 26+ */
  }
  .hdr img{
    display:block; width:auto; height:auto; max-width:100%; max-height:100%;
    object-fit:contain; background:#0a0b0e;
  }

  .hdr-off .hdrBadge{display:none}
  .hdr-off .fallback{display:inline}

  .tips{max-width:920px; margin:12px auto 24px; padding:0 16px; color:#bfc4cf}
</style>
</head>
<body>

<!-- Controls -->
<div class="controls">
  <div class="row">
    <input id="file" type="file" accept="image/heic,image/heif,image/avif,image/jpeg,image/png,image/webp,image/*" />
    <label class="label"><input id="toggleHdr" type="checkbox" checked /> Show HDR overlay</label>
    <span class="tag hdrBadge">HDR overlay: <strong>no-limit</strong></span>
    <span class="tag fallback" style="display:none">⚠️ <span class="warn">No <code>dynamic-range-limit</code>. Showing SDR only.</span></span>
    <span class="muted">For visible HDR “pop”, upload an iPhone HEIC (Smart HDR).</span>
  </div>
  <div class="row">
    <label class="label"><input id="enableTone" type="checkbox" checked /> Apply SDR tone-curve</label>
    <span class="label">Black
      <input id="black" type="range" min="0" max="0.20" step="0.002" value="0.02" />
      <span id="blackVal" class="tag">0.020</span>
    </span>
    <span class="label">Mid (γ)
      <input id="gamma" type="range" min="0.40" max="2.50" step="0.02" value="1.00" />
      <span id="gammaVal" class="tag">1.00</span>
    </span>
    <span class="label">White
      <input id="white" type="range" min="0.80" max="1.20" step="0.01" value="1.00" />
      <span id="whiteVal" class="tag">1.00</span>
    </span>
  </div>
</div>

<div class="tips">
  Toggle <strong>Show HDR overlay</strong> to compare HDR vs SDR. Sliders update **live** in the SDR canvas underneath.
</div>

<!-- Stage -->
<div class="stage">
  <div class="frame" id="frame">
    <div class="base"><canvas id="canvasBase"></canvas></div>
    <div class="hdr" id="hdrLayer">
      <img id="imgHdr"
        src="https://images.unsplash.com/photo-1504384308090-c894fdcc538d?auto=format&fit=crop&w=1600&q=100"
        alt="HDR overlay">
    </div>
  </div>
</div>

<script>
(() => {
  const supportsHDR = CSS.supports('dynamic-range-limit: no-limit');
  if (!supportsHDR) {
    document.body.classList.add('hdr-off');
    document.querySelector('.fallback').style.display = 'inline';
  }

  const frame     = document.getElementById('frame');
  const canvas    = document.getElementById('canvasBase');
  const ctx       = canvas.getContext('2d', { willReadFrequently: true });
  const hdrLayer  = document.getElementById('hdrLayer');
  const imgHdr    = document.getElementById('imgHdr');
  const fileInput = document.getElementById('file');

  // Controls
  const toggleHdr = document.getElementById('toggleHdr');
  const enableTone = document.getElementById('enableTone');
  const black = document.getElementById('black');
  const white = document.getElementById('white');
  const gamma = document.getElementById('gamma');
  const blackVal = document.getElementById('blackVal');
  const whiteVal = document.getElementById('whiteVal');
  const gammaVal = document.getElementById('gammaVal');

  // Source image object for SDR canvas (separate from <img> to keep full control)
  const imgBase = new Image();
  imgBase.crossOrigin = 'anonymous'; // fine for local blobs; required for some remote images

  // Layout state for drawing
  let naturalW = 1600, naturalH = 900;
  let drawRect = { dx: 0, dy: 0, dw: 0, dh: 0 };

  // --- Fit frame to image; compute draw rect for contain-fit ---
  function fitFrameToImage(nw, nh){
    naturalW = nw; naturalH = nh;
    const maxW = Math.min(window.innerWidth * 0.92, 1200);
    const maxH = window.innerHeight * 0.80;
    const scale = Math.min(maxW / nw, maxH / nh);
    const w = Math.max(1, Math.floor(nw * scale));
    const h = Math.max(1, Math.floor(nh * scale));
    frame.style.width  = w + 'px';
    frame.style.height = h + 'px';

    // Canvas pixel size matches CSS box for crisp drawing
    canvas.width  = w;
    canvas.height = h;

    const dw = Math.floor(nw * scale);
    const dh = Math.floor(nh * scale);
    const dx = (w - dw) >> 1;
    const dy = (h - dh) >> 1;
    drawRect = { dx, dy, dw, dh };
  }

  // --- Live SDR rendering on Canvas ---
  // Compute LUT once per slider change for speed (0..255 → adjusted 0..255)
  function buildLUT(b, g, w){
    const lut = new Uint8ClampedArray(256);
    const denom = Math.max(0.001, w - b);
    const A = 1 / denom;
    const O = -b / denom;
    for (let i=0;i<256;i++){
      let x = i / 255;
      x = Math.pow(x, g);         // gamma
      x = A * x + O;              // black/white mapping
      lut[i] = Math.max(0, Math.min(255, Math.round(x * 255)));
    }
    return lut;
  }

  function drawSDR(){
    if (!imgBase || !imgBase.complete || !drawRect.dw || !drawRect.dh) return;

    const {dx, dy, dw, dh} = drawRect;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(imgBase, dx, dy, dw, dh);

    if (!enableTone.checked) return; // unmodified SDR

    // Read back the drawn region and apply LUT in-place
    const imgData = ctx.getImageData(dx, dy, dw, dh);
    const p = imgData.data;
    const b = parseFloat(black.value);
    const w = parseFloat(white.value);
    const g = parseFloat(gamma.value);

    const lut = buildLUT(b, g, w);
    for (let i=0;i<p.length;i+=4){
      p[i  ] = lut[p[i  ]]; // R
      p[i+1] = lut[p[i+1]]; // G
      p[i+2] = lut[p[i+2]]; // B
      // p[i+3] alpha unchanged
    }
    ctx.putImageData(imgData, dx, dy);

    // UI readouts
    blackVal.textContent = b.toFixed(3);
    whiteVal.textContent = w.toFixed(3);
    gammaVal.textContent = g.toFixed(2);
  }

  // rAF throttling for slider input
  let needsRedraw = false;
  function scheduleRedraw(){
    if (needsRedraw) return;
    needsRedraw = true;
    requestAnimationFrame(() => {
      needsRedraw = false;
      drawSDR();
    });
  }

  // --- Event wiring ---
  [enableTone, black, white, gamma].forEach(el => el.addEventListener('input', scheduleRedraw, {passive:true}));

  toggleHdr.addEventListener('input', () => {
    hdrLayer.style.display = toggleHdr.checked ? '' : 'none';
  }, {passive:true});

  // File upload → same blob for HDR <img> and SDR Image()
  fileInput.addEventListener('change', () => {
    const f = fileInput.files && fileInput.files[0]; if (!f) return;
    const url = URL.createObjectURL(f);
    imgHdr.src  = url;       // HDR overlay
    imgBase.src = url;       // SDR canvas source
  });

  // When either image loads, size frame & redraw
  imgBase.onload = () => {
    fitFrameToImage(imgBase.naturalWidth || 1600, imgBase.naturalHeight || 900);
    scheduleRedraw();
  };
  imgHdr.onload = () => {
    // Prefer sizing from the real image aspect as well
    fitFrameToImage(imgHdr.naturalWidth || imgBase.naturalWidth || 1600,
                    imgHdr.naturalHeight || imgBase.naturalHeight || 900);
    scheduleRedraw();
  };

  // Initial demo image (SDR-ish) to avoid empty box
  imgBase.src = "https://images.unsplash.com/photo-1504384308090-c894fdcc538d?auto=format&fit=crop&w=1600&q=85";

  // Resize handling
  window.addEventListener('resize', () => {
    fitFrameToImage(naturalW, naturalH);
    scheduleRedraw();
  }, {passive:true});
})();
</script>
</body>
</html>