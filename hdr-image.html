<!doctype html>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>WebGPU Present Sanity â€” iOS 26 Safari</title>
<style>
  html,body{margin:0;height:100vh;background:#222;overflow:hidden}
  /* Disable iOS selection/magnifier/tap highlight */
  html,body,canvas{
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none; -webkit-tap-highlight-color: rgba(0,0,0,0);
    touch-action:none;
  }
  #wrap{position:fixed;inset:0}
  #wgpu{position:absolute;inset:0;display:block;width:100vw;height:100vh;z-index:1}
  #log{
    position:fixed;left:0;right:0;bottom:0;
    font:12px ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    background:rgba(0,0,0,.7); color:#fff; padding:8px 10px; max-height:40vh; overflow:auto; z-index:2
  }
</style>
<div id="wrap">
  <canvas id="wgpu"></canvas>
</div>
<pre id="log"></pre>
<script>
(function(){
  const logEl = document.getElementById('log');
  const log = (...a)=>{ const s=a.map(v=> typeof v==='string'? v: JSON.stringify(v)).join(' ');
                        logEl.textContent += s+'\n'; console.log(...a); };

  // Kill magnifier by preventing default on all touch/gesture events
  const stop = e => { e.preventDefault(); };
  for (const ev of ['touchstart','touchmove','touchend','gesturestart','gesturechange','gestureend'])
    addEventListener(ev, stop, {passive:false});

  const cv = document.getElementById('wgpu');

  function size(){
    // Use layout size, then set backing size; reconfigure only when backing changes
    const w = Math.max(2, cv.clientWidth|0);
    const h = Math.max(2, cv.clientHeight|0);
    const changed = (cv.width!==w || cv.height!==h);
    if (changed){ cv.width=w; cv.height=h; }
    return changed;
  }

  let device, ctx, format;
  async function init(){
    size();
    addEventListener('resize', () => { if (size()) configure(); }, {passive:true});

    if (!('gpu' in navigator)){ log('ERR: navigator.gpu missing'); return; }
    const adapter = await navigator.gpu.requestAdapter().catch(e=>{log('ERR adapter', e);});
    if (!adapter){ log('ERR: requestAdapter() returned null'); return; }
    device = await adapter.requestDevice().catch(e=>{log('ERR device', e);});
    if (!device){ log('ERR: requestDevice failed'); return; }

    ctx = cv.getContext('webgpu', {alphaMode:'opaque'});
    if (!ctx){ log('ERR: getContext("webgpu") failed'); return; }
    format = navigator.gpu.getPreferredCanvasFormat();
    configure();
    frame();
  }

  function configure(){
    try{
      ctx.configure({ device, format, alphaMode:'opaque' });
      log('configured', {w:cv.width,h:cv.height,format});
    }catch(e){ log('ERR configure', e); }
  }

  function frame(){
    // If Safari invalidated the swapchain due to a relayout, reconfigure
    try{
      const tex = ctx.getCurrentTexture();
      const enc = device.createCommandEncoder();
      const pass = enc.beginRenderPass({
        colorAttachments: [{
          view: tex.createView(),
          loadOp: 'clear',
          clearValue: {r:1,g:0,b:1,a:1}, // MAGENTA
          storeOp: 'store'
        }]
      });
      pass.end();
      device.queue.submit([enc.finish()]);
    }catch(e){
      log('ERR frame; reconfiguring:', e);
      configure();
    }
    requestAnimationFrame(frame);
  }

  init();
})();
</script>