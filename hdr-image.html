<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>SDR→HDR Value-Only Brush (Safe 2D)</title>
<style>
  html, body { margin:0; height:100dvh; background:#000; }
  body { overflow:hidden; }
  canvas {
    display:block; width:100vw; height:100dvh;
    touch-action:none; -webkit-touch-callout:none; -webkit-user-select:none; user-select:none;
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<script>
(() => {
  const canvas = document.getElementById('cv');
  const ctx = canvas.getContext('2d', { alpha:false });
  canvas.style.touchAction = 'none';

  // eat iOS gestures to prevent loupe/zoom
  const stop = e => e.preventDefault();
  for (const evt of ['gesturestart','gesturechange','gestureend','touchstart','touchmove','touchend'])
    canvas.addEventListener(evt, stop, {passive:false});

  // robust sizing (handles WKWebView / iOS 100vh bugs)
  function fitCanvas(force=false){
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const w = Math.max(2, Math.floor(canvas.clientWidth  * dpr));
    const h = Math.max(2, Math.floor(canvas.clientHeight * dpr));
    if (force || canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; return true; }
    return false;
  }
  const ensureSize = () => { fitCanvas(true); drawBaseline(); };
  window.addEventListener('resize', () => { if (fitCanvas(true)) drawBaseline(); }, {passive:true});
  // run after layout & one micro-delay to avoid 0×0
  window.addEventListener('DOMContentLoaded', ensureSize);
  setTimeout(ensureSize, 0);

  // HSV baseline: H=x, V=y, S=1-y (bottom black → top white), tiny dither to avoid banding
  function hsv2rgb(h,s,v){
    const i=Math.floor(h*6), f=h*6-i, p=v*(1-s), q=v*(1-f*s), t=v*(1-(1-f)*s);
    switch(i%6){case 0:return[v,t,p];case 1:return[q,v,p];case 2:return[p,v,t];
      case 3:return[p,q,v];case 4:return[t,p,v];default:return[v,p,q];}
  }
  function drawBaseline(){
    const w=canvas.width, h=canvas.height;
    const img = ctx.createImageData(w,h);
    const dAmp = 1/1023;
    for(let y=0;y<h;y++){
      const V=y/(h-1), S=Math.max(0,1-V);
      for(let x=0;x<w;x++){
        const H=x/(w-1);
        const d = ((Math.sin((x*127.1 + y*311.7))*43758.5453)%1)-0.5; // tiny blue-noise-ish dither
        const rgb = hsv2rgb(H,S,Math.max(0,V + d*dAmp));
        const i=(y*w+x)*4;
        img.data[i  ]=rgb[0]*255; img.data[i+1]=rgb[1]*255; img.data[i+2]=rgb[2]*255; img.data[i+3]=255;
      }
    }
    ctx.putImageData(img,0,0);
  }

  // Brush: value-only lift with soft Gaussian, ramp/decay, long-press gentle gain
  const params = {
    ramp:0.25, decayHalf:1.2, flow:0.7, baseSigma:130, longT:0.6, longGain:0.5
  };
  const pointers = new Map();
  const now = () => performance.now()/1000;

  function normPos(clientX,clientY){
    const r=canvas.getBoundingClientRect(); const dpr=Math.max(1,window.devicePixelRatio||1);
    return { x:(clientX-r.left)*dpr, y:(clientY-r.top)*dpr };
  }
  canvas.addEventListener('pointerdown', e=>{
    e.preventDefault(); canvas.setPointerCapture(e.pointerId);
    const t=now(), p=normPos(e.clientX,e.clientY);
    pointers.set(e.pointerId,{x:p.x,y:p.y,down:t,up:t,active:1});
  }, {passive:false});
  canvas.addEventListener('pointermove', e=>{
    e.preventDefault();
    const P=pointers.get(e.pointerId); if(!P) return;
    const q=normPos(e.clientX,e.clientY); P.x=q.x; P.y=q.y;
  }, {passive:false});
  function end(e){ e.preventDefault(); const P=pointers.get(e.pointerId); if(P){ P.active=0; P.up=now(); } }
  canvas.addEventListener('pointerup', end, {passive:false});
  canvas.addEventListener('pointercancel', end, {passive:false});

  // Real-time painter: compute lift analytically and paint only a tight region for speed
  function frame(){
    // draw baseline once, then only paint deltas on top (fast path)
    // For simplicity & clarity, we repaint whole frame; if slow, could optimize region-of-interest.
    drawFrame();
    // prune old pointers
    const t=now();
    for(const [id,P] of pointers)
      if(!P.active && (t-P.up) > params.decayHalf*3) pointers.delete(id);
    requestAnimationFrame(frame);
  }

  function drawFrame(){
    const w=canvas.width, h=canvas.height;
    const img = ctx.getImageData(0,0,w,h); // start from baseline already drawn
    const data = img.data;
    const dAmp = 1/2047;

    // Precompute constants
    const decayK = Math.log(2)/Math.max(0.001, params.decayHalf);
    const dpr = Math.max(1, window.devicePixelRatio||1);
    const T = now();

    // For each pixel: baseline V plus lifts from pointers
    for(let y=0;y<h;y++){
      const V0=y/(h-1), S=Math.max(0,1-V0);
      for(let x=0;x<w;x++){
        let lift=0;
        for(const [,P] of pointers){
          const dx=x-P.x, dy=y-P.y, r=Math.hypot(dx,dy);
          const age=T-P.down;
          const lp=Math.max(0, Math.min(1,(age-params.longT)/0.8));
          const gain=1+lp*params.longGain;
          const sigma=params.baseSigma*dpr*gain;
          const rampT=Math.max(0, Math.min(1, age/Math.max(0.001, params.ramp)));
          const tUp=Math.max(0, T-P.up);
          const decay=Math.exp(-decayK*tUp);
          const center=params.flow*((P.active?1:0)*rampT + (1-(P.active?1:0))*rampT*decay);
          lift += center * Math.exp(-0.5*(r*r)/(sigma*sigma)) * gain;
        }
        let V = Math.max(0, V0 + lift);
        const H = x/(w-1);
        const d = ((Math.sin((x*127.1 + y*311.7))*43758.5453)%1)-0.5;
        V = Math.max(0, V + d*dAmp);
        const rgb = hsv2rgb(H,S,V);
        const i=(y*w+x)*4;
        data[i  ] = Math.min(255, rgb[0]*255);
        data[i+1] = Math.min(255, rgb[1]*255);
        data[i+2] = Math.min(255, rgb[2]*255);
        // alpha already 255
      }
    }
    ctx.putImageData(img,0,0);
  }

  // Draw once, then animate
  drawBaseline();
  // second pass after a tick in case initial layout was 0×0
  setTimeout(() => { if (fitCanvas()) drawBaseline(); }, 30);
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>
bb