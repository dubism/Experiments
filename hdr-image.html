<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>HDR Brush — HUD + Toggles</title>
<style>
  html,body{margin:0;height:100vh;overflow:hidden;background:#000}
  html,body,canvas{
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none; -webkit-tap-highlight-color: rgba(0,0,0,0);
    touch-action:none;
  }
  canvas{display:block;width:100vw;height:100vh;dynamic-range-limit:no-limit}
  #ui{
    position:fixed;top:10px;right:10px;z-index:20;display:flex;flex-direction:column;gap:8px
  }
  #ui button{
    font:12px system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    padding:6px 8px;border-radius:8px;border:0;cursor:pointer;background:#222;color:#fff;opacity:.9
  }
  #ui button.active{background:#0a6;opacity:1}
  #hud{
    position:fixed;left:10px;top:10px;z-index:20;background:rgba(0,0,0,.55);
    color:#fff;font:12px ui-monospace,monospace;padding:8px 10px;border-radius:8px;pointer-events:none;
    line-height:1.35
  }
  #log{
    position:fixed;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);
    color:#fff;font:12px ui-monospace,monospace;padding:6px 8px;max-height:40vh;
    overflow:auto;white-space:pre-wrap;pointer-events:none
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="ui">
  <button id="sdr">SDR test: OFF</button>
  <button id="clamp">Force SDR clamp: OFF</button>
</div>
<div id="hud">
  <div><b>P3 requested:</b> <span id="p3">yes</span></div>
  <div><b>DPR:</b> <span id="dpr">-</span></div>
  <div><b>Canvas:</b> <span id="size">-</span></div>
  <div><b>Format:</b> <span id="fmt">-</span></div>
  <div><b>Gain:</b> <span id="gain">0.9</span></div>
  <div><b>Headroom:</b> <span id="hdr">3.5</span></div>
</div>
<pre id="log"></pre>
<script>
(async()=>{
  const cvs=document.getElementById('cv');
  const logEl=document.getElementById('log');
  const btnSDR=document.getElementById('sdr');
  const btnClamp=document.getElementById('clamp');
  const hud={p3:document.getElementById('p3'),dpr:document.getElementById('dpr'),
             size:document.getElementById('size'),fmt:document.getElementById('fmt'),
             gain:document.getElementById('gain'),hdr:document.getElementById('hdr')};
  const log=(...a)=>{logEl.textContent+=a.map(v=>typeof v==='string'?v:JSON.stringify(v)).join(' ')+'\n';
                     logEl.scrollTop=logEl.scrollHeight;};

  // Only block pinch/rotate gestures
  const stop=e=>e.preventDefault();
  for(const ev of ['gesturestart','gesturechange','gestureend'])
    addEventListener(ev, stop, {passive:false});

  // DPR-aware sizing
  const DPR=()=>Math.max(1, devicePixelRatio||1);
  function size(){
    const k=DPR();
    const w=Math.max(2, Math.round(cvs.clientWidth*k));
    const h=Math.max(2, Math.round(cvs.clientHeight*k));
    const changed=(cvs.width!==w||cvs.height!==h);
    if(changed){cvs.width=w;cvs.height=h;}
    hud.dpr.textContent=k.toFixed(2);
    hud.size.textContent=`${w}×${h}`;
    return changed;
  }
  addEventListener('resize', ()=>{ if(size()) configure(); }, {passive:true});
  size();

  // WebGPU
  if(!('gpu'in navigator)){log('ERR: navigator.gpu missing');return;}
  const adapter=await navigator.gpu.requestAdapter().catch(e=>log('adapter err',e));
  if(!adapter){log('ERR: adapter null');return;}
  const device=await adapter.requestDevice().catch(e=>log('device err',e));
  if(!device){log('ERR: device null');return;}
  const ctx=cvs.getContext('webgpu',{alphaMode:'opaque',colorSpace:'display-p3'});
  if(!ctx){log('ERR: getContext failed');return;}
  const format=navigator.gpu.getPreferredCanvasFormat();
  hud.fmt.textContent=String(format);
  hud.p3.textContent='yes';

  function configure(){
    try{
      ctx.configure({device,format,alphaMode:'opaque',colorSpace:'display-p3'});
      log('configured', {w:cvs.width,h:cvs.height,format});
      writeU();
    }catch(e){log('ERR configure', e||{});}
  }
  configure();

  // WGSL (saturation bottom→top; HDR lift; optional SDR dim + clamp)
  const wgsl=`
@group(0) @binding(0) var<uniform> Upos : vec4<f32>; // x,y,active,radius  (device px)
@group(0) @binding(1) var<uniform> Upar : vec4<f32>; // gain,headroom,width,height (device px)
@group(0) @binding(2) var<uniform> Uopt : vec4<f32>; // x: sdrAid(0/1), y: baselineScale, z: forceSDR(0/1), w: unused

@vertex
fn vs(@builtin(vertex_index) i:u32) -> @builtin(position) vec4<f32> {
  let q:array<vec2<f32>,6>=array<vec2<f32>,6>(
    vec2<f32>(-1.0,-1.0), vec2<f32>( 1.0,-1.0), vec2<f32>(-1.0, 1.0),
    vec2<f32>(-1.0, 1.0), vec2<f32>( 1.0,-1.0), vec2<f32>( 1.0, 1.0)
  );
  return vec4<f32>(q[i],0.0,1.0);
}

fn hsv2rgb(h:f32,s:f32,v:f32)->vec3<f32>{
  let hh=h*6.0; let i=u32(floor(hh)); let f=fract(hh);
  let p=v*(1.0-s); let q=v*(1.0-f*s); let t=v*(1.0-(1.0-f)*s);
  if(i==0u){ return vec3<f32>(v,t,p); }
  else if(i==1u){ return vec3<f32>(q,v,p); }
  else if(i==2u){ return vec3<f32>(p,v,t); }
  else if(i==3u){ return vec3<f32>(p,q,v); }
  else if(i==4u){ return vec3<f32>(t,p,v); }
  else{ return vec3<f32>(v,p,q); }
}

@fragment
fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32> {
  // Reconstruct uv from framebuffer position (device px)
  let res = vec2<f32>(Upar.z, Upar.w);
  let uv  = pos.xy / res;

  // Baseline: hue across X, saturation bottom→top, value=1
  let sat = clamp(uv.y, 0.0, 1.0);
  let base0 = hsv2rgb(clamp(uv.x,0.0,1.0), sat, 1.0);
  let base  = mix(base0, base0 * Uopt.y, Uopt.x); // SDR test dims baseline if enabled

  // Value-only multiplicative lift under finger (same hue/sat)
  var factor = 1.0;
  if (Upos.z > 0.5) {
    let r = max(1.0, Upos.w);
    let d = distance(pos.xy, Upos.xy);
    let lift = exp(-0.5 * (d/r) * (d/r)) * Upar.x; // gain
    factor += lift;
  }

  var rgb = min(base * factor, vec3<f32>(Upar.y)); // clamp to HDR headroom
  // Optional: force SDR preview (clip to 1.0)
  if (Uopt.z > 0.5) {
    rgb = min(rgb, vec3<f32>(1.0,1.0,1.0));
  }
  return vec4<f32>(rgb, 1.0);
}
`;
  const module=device.createShaderModule({code:wgsl});
  const info=await module.getCompilationInfo?.();
  if(info?.messages?.length) info.messages.forEach(m=>log(`${m.type} ${m.lineNum}:${m.linePos} ${m.message}`));

  let pipeline;
  try{
    pipeline=device.createRenderPipeline({
      layout:'auto',
      vertex:{module,entryPoint:'vs'},
      fragment:{module,entryPoint:'fs',targets:[{format}]}
    });
  }catch(e){log('ERR createRenderPipeline',e);return;}

  // Uniforms
  const bufA=device.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}); // Upos
  const bufB=device.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}); // Upar
  const bufC=device.createBuffer({size:256,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}); // Uopt
  const bind=device.createBindGroup({
    layout:pipeline.getBindGroupLayout(0),
    entries:[
      {binding:0,resource:{buffer:bufA}},
      {binding:1,resource:{buffer:bufB}},
      {binding:2,resource:{buffer:bufC}},
    ]
  });

  // State
  const st={
    x:0,y:0,active:0,
    radius:140,
    gain:0.9,
    headroom:3.5,
    sdrAid:false,
    baselineScale:0.85,
    forceSDR:false
  };
  function updateHUD(){
    hud.gain.textContent=st.gain.toFixed(2);
    hud.hdr.textContent=st.headroom.toFixed(2);
  }
  function writeU(){
    device.queue.writeBuffer(bufA,0,new Float32Array([st.x,st.y,st.active,st.radius]));
    device.queue.writeBuffer(bufB,0,new Float32Array([st.gain,st.headroom,cvs.width,cvs.height]));
    device.queue.writeBuffer(bufC,0,new Float32Array([st.sdrAid?1:0, st.baselineScale, st.forceSDR?1:0, 0]));
    updateHUD();
  }
  writeU();

  // UI toggles
  function refreshButtons(){
    btnSDR.textContent=`SDR test: ${st.sdrAid?'ON':'OFF'}`;
    btnSDR.classList.toggle('active', st.sdrAid);
    btnClamp.textContent=`Force SDR clamp: ${st.forceSDR?'ON':'OFF'}`;
    btnClamp.classList.toggle('active', st.forceSDR);
  }
  btnSDR.addEventListener('click', ()=>{ st.sdrAid=!st.sdrAid; refreshButtons(); writeU(); });
  btnClamp.addEventListener('click', ()=>{ st.forceSDR=!st.forceSDR; refreshButtons(); writeU(); });
  refreshButtons();

  // Input (DPR-aligned)
  function pt(e){
    const r=cvs.getBoundingClientRect(), k=DPR();
    const x=(e.clientX-r.left)*k, y=(e.clientY-r.top)*k;
    return {x:Math.min(Math.max(0,x),cvs.width-1), y:Math.min(Math.max(0,y),cvs.height-1)};
  }
  cvs.addEventListener('pointerdown', e=>{
    e.preventDefault(); cvs.setPointerCapture?.(e.pointerId);
    const p=pt(e); st.x=p.x; st.y=p.y; st.active=1; writeU();
  }, {passive:false});
  cvs.addEventListener('pointermove', e=>{
    if(!st.active) return; e.preventDefault();
    const p=pt(e); st.x=p.x; st.y=p.y; writeU();
  }, {passive:false});
  const pend=e=>{ e.preventDefault(); st.active=0; writeU(); };
  cvs.addEventListener('pointerup', pend, {passive:false});
  cvs.addEventListener('pointercancel', pend, {passive:false});

  // Render loop with guard
  function frame(){
    try{
      const enc=device.createCommandEncoder();
      const pass=enc.beginRenderPass({
        colorAttachments:[{
          view:ctx.getCurrentTexture().createView(),
          loadOp:'clear', clearValue:{r:0,g:0,b:0,a:1}, storeOp:'store'
        }]
      });
      pass.setPipeline(pipeline);
      pass.setBindGroup(0,bind);
      pass.draw(6);
      pass.end();
      device.queue.submit([enc.finish()]);
    }catch(e){log('ERR frame, reconfiguring', e||{}); configure();}
    requestAnimationFrame(frame);
  }
  requestAnimationFrame(frame);
})();
</script>
</body>
</html>