<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>HDR Brush â€” DPR-aligned</title>
<style>
  html,body{margin:0;height:100vh;overflow:hidden;background:#000}
  html,body,canvas{
    -webkit-user-select:none; user-select:none;
    -webkit-touch-callout:none; -webkit-tap-highlight-color: rgba(0,0,0,0);
    touch-action:none;
  }
  canvas{display:block;width:100vw;height:100vh;dynamic-range-limit:no-limit}
  #log{
    position:fixed;left:0;right:0;bottom:0;background:rgba(0,0,0,.7);
    color:#fff;font:12px ui-monospace,monospace;padding:6px;max-height:45vh;
    overflow:auto;white-space:pre-wrap;pointer-events:none
  }
</style>
</head>
<body>
<canvas id="cv"></canvas>
<pre id="log"></pre>
<script>
(async()=>{
  const cvs=document.getElementById('cv');
  const logEl=document.getElementById('log');
  const log=(...a)=>{logEl.textContent+=a.join(' ')+'\n'; logEl.scrollTop=logEl.scrollHeight;};

  // Block only pinch/rotate
  const stop=e=>e.preventDefault();
  for(const ev of ['gesturestart','gesturechange','gestureend'])
    addEventListener(ev, stop, {passive:false});

  // --- DPR-aware sizing ---
  function dpr(){ return Math.max(1, window.devicePixelRatio||1); }
  function size(){
    const k=dpr();
    const w=Math.max(2, Math.round(cvs.clientWidth  * k));
    const h=Math.max(2, Math.round(cvs.clientHeight * k));
    if (cvs.width!==w || cvs.height!==h){ cvs.width=w; cvs.height=h; return true; }
    return false;
  }
  addEventListener('resize', ()=>{ if(size()) configure(); }, {passive:true});
  size();

  if(!('gpu' in navigator)){ log('ERR navigator.gpu missing'); return; }
  const adapter = await navigator.gpu.requestAdapter(); if(!adapter){ log('ERR adapter null'); return; }
  const device  = await adapter.requestDevice();
  const ctx     = cvs.getContext('webgpu', {alphaMode:'opaque'}); if(!ctx){ log('ERR getContext'); return; }
  const format  = navigator.gpu.getPreferredCanvasFormat();
  function configure(){ try{ ctx.configure({device, format, alphaMode:'opaque'}); }catch(e){ log('ERR configure', e); } }
  configure(); log('configured', JSON.stringify({w:cvs.width,h:cvs.height,format}));

  // ---- WGSL (no structs/varyings) ----
  const wgsl=`
@group(0) @binding(0) var<uniform> Upos : vec4<f32>; // x,y,active,radius (device px)
@group(0) @binding(1) var<uniform> Upar : vec4<f32>; // gain,headroom,width,height (device px)

@vertex
fn vs(@builtin(vertex_index) i:u32) -> @builtin(position) vec4<f32> {
  let q:array<vec2<f32>,6>=array<vec2<f32>,6>(
    vec2<f32>(-1.0,-1.0), vec2<f32>( 1.0,-1.0), vec2<f32>(-1.0, 1.0),
    vec2<f32>(-1.0, 1.0), vec2<f32>( 1.0,-1.0), vec2<f32>( 1.0, 1.0)
  );
  return vec4<f32>(q[i],0.0,1.0);
}

fn hsv2rgb(h:f32,s:f32,v:f32)->vec3<f32>{
  let hh=h*6.0; let i=u32(floor(hh)); let f=fract(hh);
  let p=v*(1.0-s); let q=v*(1.0-f*s); let t=v*(1.0-(1.0-f)*s);
  if(i==0u){ return vec3<f32>(v,t,p); }
  else if(i==1u){ return vec3<f32>(q,v,p); }
  else if(i==2u){ return vec3<f32>(p,v,t); }
  else if(i==3u){ return vec3<f32>(p,q,v); }
  else if(i==4u){ return vec3<f32>(t,p,v); }
  else{ return vec3<f32>(v,p,q); }
}

@fragment
fn fs(@builtin(position) pos: vec4<f32>) -> @location(0) vec4<f32>{
  let res = vec2<f32>(Upar.z, Upar.w);      // device px
  let uv  = pos.xy / res;

  // baseline rainbow
  let H=clamp(uv.x,0.0,1.0);
  let V0=clamp(uv.y,0.0,1.0);
  let S=clamp(1.0-uv.y,0.0,1.0);

  // value lift
  var V=V0;
  if(Upos.z>0.5){
    let d=distance(pos.xy, Upos.xy);        // both in device px
    let r=max(1.0,Upos.w);
    let lift=exp(-0.5*(d