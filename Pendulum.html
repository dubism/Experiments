<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no"/>
  <title>Pendulum Physics — iPhone Gravity (1–3 segments, pivot accel)</title>
  <style>
    :root{ --bg:#0b0f12; --fg:#eaf2ff; --muted:#8ea0bb; --accent:#51F093; --panel:rgba(18,23,30,.66); --outline:rgba(255,255,255,.08); }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--fg);
      font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;
      -webkit-text-size-adjust:100%; touch-action:none; overscroll-behavior:none; }
    canvas{ position:fixed; inset:0; display:block; }
    .pivot{ position:fixed; left:50%; top:50%; width:6px; height:6px; margin:-3px 0 0 -3px; background:var(--accent); border-radius:50%;
      box-shadow:0 0 14px rgba(81,240,147,.65); pointer-events:none; }
    .hud{ position:fixed; left:12px; bottom:12px; padding:10px 12px; border-radius:12px; background:var(--panel); border:1px solid var(--outline); color:var(--muted); }
    .hud strong{ color:var(--fg); }
    .ui{ position:fixed; right:12px; top:12px; z-index:10; display:grid; gap:8px; width:min(360px,92vw); }
    .card{ background:var(--panel); border:1px solid var(--outline); border-radius:14px; padding:10px 12px; }
    .row{ display:flex; align-items:center; gap:8px; }
    .row>label{ min-width:132px; color:var(--muted); }
    input[type="range"]{ width:100%; }
    .seg{ display:flex; gap:6px; }
    .seg button{ appearance:none; background:#1a232e; color:var(--fg); border:1px solid rgba(255,255,255,.12); padding:8px 10px; border-radius:10px; font-weight:600; min-width:44px; }
    .seg button[aria-pressed="true"]{ background:#223144; border-color:#385372; }
    .row .right{ margin-left:auto; color:var(--muted); }
    .gate{ position:fixed; inset:0; display:grid; place-items:center; background:linear-gradient(180deg,rgba(0,0,0,.85),rgba(0,0,0,.6)); z-index:20; }
    .panel{ width:min(520px,90vw); padding:16px 18px; border-radius:14px; background:var(--panel); border:1px solid var(--outline); text-align:center; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    h1{ margin:0 0 10px; font:600 18px/1.2 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; } p{ margin:.4em 0; color:var(--muted); }
    .rowBtns{ display:flex; gap:10px; justify-content:center; margin-top:12px; }
    button.primary{ background:#1a232e; border:1px solid rgba(255,255,255,.12); padding:10px 14px; border-radius:10px; color:var(--fg); font-weight:700; }
    button.secondary{ background:#111820; border:1px solid rgba(255,255,255,.1); padding:10px 14px; border-radius:10px; color:var(--fg); }
    .note{ font-size:12px; color:#9fb0ca; }
  </style>
</head>
<body>
  <canvas id="c"></canvas>
  <div class="pivot" aria-hidden="true"></div>

  <div class="ui">
    <div class="card">
      <div class="row" style="justify-content:space-between;">
        <div class="seg" id="segButtons" role="group" aria-label="Segments">
          <button data-n="1" aria-pressed="true">1</button>
          <button data-n="2" aria-pressed="false">2</button>
          <button data-n="3" aria-pressed="false">3</button>
        </div>
        <div class="right" id="fps">— fps</div>
      </div>
      <div class="row">
        <label for="len">Total length</label>
        <input id="len" type="range" min="0.2" max="0.7" step="0.01" value="0.40"/>
        <span class="right" id="lenVal">40%</span>
      </div>
      <div class="row">
        <label for="damp">Damping (vel. decay)</label>
        <input id="damp" type="range" min="0" max="0.06" step="0.001" value="0.010"/>
        <span class="right" id="dampVal">0.010</span>
      </div>
      <div class="row">
        <label for="iter">Iterations (stiffness)</label>
        <input id="iter" type="range" min="4" max="28" step="1" value="14"/>
        <span class="right" id="iterVal">14</span>
      </div>
      <div class="row">
        <label for="smooth">Sensor smoothing</label>
        <input id="smooth" type="range" min="0" max="0.5" step="0.01" value="0.15"/>
        <span class="right" id="smoothVal">0.15</span>
      </div>
      <div class="row" style="justify-content:space-between; margin-top:6px;">
        <button id="btnReset" class="secondary">Reset</button>
        <div style="display:flex; gap:8px;">
          <button id="btnMotion" class="primary">Enable motion</button>
          <button id="btnDemo" class="secondary" title="Run without sensors">Demo</button>
        </div>
      </div>
    </div>
  </div>

  <div class="hud" id="hud">g: <strong>—</strong></div>

  <div class="gate" id="gate">
    <div class="panel">
      <h1>Enable Motion Sensors</h1>
      <p>Uses your iPhone’s motion data to set gravity and base acceleration.</p>
      <div class="rowBtns">
        <button id="gateMotion" class="primary">Enable motion</button>
        <button id="gateDemo" class="secondary">Demo mode</button>
      </div>
      <p class="note">iOS: tap to allow, use HTTPS, enable “Motion &amp; Orientation Access”.</p>
    </div>
  </div>

<script>
(()=>{
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha:false, desynchronized:true });
  const gate = document.getElementById('gate');
  const hud = document.getElementById('hud');
  const fpsEl = document.getElementById('fps');

  const segButtons = document.getElementById('segButtons');
  const btns = [...segButtons.querySelectorAll('button')];
  const R = (id)=>document.getElementById(id);
  const sliders = { len:R('len'), damp:R('damp'), iter:R('iter'), smooth:R('smooth') };
  const labels  = { lenVal:R('lenVal'), dampVal:R('dampVal'), iterVal:R('iterVal'), smoothVal:R('smoothVal') };
  const btnReset = R('btnReset'); const btnMotion = R('btnMotion'); const btnDemo = R('btnDemo');
  const gateMotion = R('gateMotion'); const gateDemo = R('gateDemo');

  const state = {
    dpr: Math.max(1, Math.min(3, devicePixelRatio||1)),
    w:0,h:0,cx:0,cy:0,
    pxPerMeter: 400,
    // Gravity and base acceleration (screen plane, m/s^2)
    gVec:{x:0,y:1}, gMag:9.81, base:{x:0,y:0},
    // Low-pass gravity (device coords) for linear-accel fallback
    gLP3:{x:0,y:0,z:0},
    smooth: parseFloat(sliders.smooth.value),
    motionSeen:false, enabled:false, demo:false,
    // Chain
    N:1, totalLenPx:0, segLen:[], points:[],
    iters: sliders.iter.value|0, damp: parseFloat(sliders.damp.value),
    lastT: performance.now(), fps:0, _fpsCount:0, _fpsLast:performance.now()
  };

  function resize(){
    const dpr = state.dpr = Math.max(1, Math.min(3, devicePixelRatio||1));
    canvas.width  = Math.floor(innerWidth * dpr);
    canvas.height = Math.floor(innerHeight * dpr);
    canvas.style.width = innerWidth+'px'; canvas.style.height = innerHeight+'px';
    state.w = canvas.width; state.h = canvas.height;
    state.cx = (state.w>>1); state.cy = (state.h>>1);
    state.pxPerMeter = Math.min(state.w, state.h) / 2.8;
    rebuildChain();
  }
  addEventListener('resize', resize, {passive:true}); resize();

  function setSegments(n){
    state.N = n|0;
    btns.forEach(b=>b.setAttribute('aria-pressed', String((b.dataset.n|0)===n)));
    rebuildChain();
  }
  segButtons.addEventListener('click', e=>{
    const b = e.target.closest('button'); if(!b) return;
    setSegments(b.dataset.n|0);
  });

  function updateLabels(){
    labels.lenVal.textContent   = Math.round(sliders.len.value*100)+'%';
    labels.dampVal.textContent  = parseFloat(sliders.damp.value).toFixed(3);
    labels.iterVal.textContent  = sliders.iter.value;
    labels.smoothVal.textContent= parseFloat(sliders.smooth.value).toFixed(2);
  }
  Object.values(sliders).forEach(s=>{
    s.addEventListener('input', ()=>{
      state.damp  = parseFloat(sliders.damp.value);
      state.iters = sliders.iter.value|0;
      state.smooth= parseFloat(sliders.smooth.value);
      state.totalLenPx = Math.min(state.w, state.h) * parseFloat(sliders.len.value);
      const per = state.totalLenPx / state.N;
      state.segLen = Array.from({length:state.N}, _=> per);
      updateLabels();
    });
  });
  updateLabels();

  btnReset.addEventListener('click', ()=>rebuildChain(true));
  btnMotion.addEventListener('click', enableMotion);
  btnDemo.addEventListener('click', enableDemo);
  gateMotion.addEventListener('click', enableMotion);
  gateDemo.addEventListener('click', enableDemo);

  function rebuildChain(){
    state.totalLenPx = Math.min(state.w,state.h) * parseFloat(sliders.len.value);
    const per = state.totalLenPx / state.N;
    state.segLen = Array.from({length:state.N}, _=> per);
    const pts=[]; let x=state.cx, y=state.cy, dx=state.gVec.x, dy=state.gVec.y;
    for(let i=1;i<=state.N;i++){ x+=dx*per; y+=dy*per; pts[i]={x,y,px:x,py:y}; }
    state.points = pts;
  }

  function screenAngleRad(){
    const ang = (screen.orientation && typeof screen.orientation.angle==='number') ? screen.orientation.angle :
                (typeof window.orientation==='number' ? window.orientation : 0);
    return (ang||0)*Math.PI/180;
  }
  function rotate2D(x,y,a){ const c=Math.cos(a), s=Math.sin(a); return {x:x*c - y*s, y:x*s + y*c}; }

  const LP = 0.90; // gravity low-pass (for linear fallback)
  function onMotion(e){
    state.motionSeen = true;
    const inc = e.accelerationIncludingGravity || {x:0,y:0,z:0};
    // Low-pass gravity in device coords
    state.gLP3.x = LP*state.gLP3.x + (1-LP)*(inc.x||0);
    state.gLP3.y = LP*state.gLP3.y + (1-LP)*(inc.y||0);
    state.gLP3.z = LP*state.gLP3.z + (1-LP)*(inc.z||0);

    // Gravity direction from low-passed gravity
    let gx = state.gLP3.x, gy = -state.gLP3.y;
    const rg = rotate2D(gx, gy, -screenAngleRad()); gx = rg.x; gy = rg.y;
    const gm = Math.hypot(gx,gy) || 1e-6;
    const dirx = gx/gm, diry = gy/gm;
    const S = state.smooth;
    state.gVec.x = state.gVec.x*(1-S) + dirx*S;
    state.gVec.y = state.gVec.y*(1-S) + diry*S;
    state.gMag   = Math.hypot(state.gLP3.x, state.gLP3.y, state.gLP3.z) || 9.81;

    // Linear acceleration (device accel without gravity)
    let lin = e.acceleration && (e.acceleration.x!=null) ? e.acceleration : {
      x:(inc.x||0)-state.gLP3.x, y:(inc.y||0)-state.gLP3.y, z:(inc.z||0)-state.gLP3.z
    };
    let bx = (lin.x||0), by = -(lin.y||0);
    const rb = rotate2D(bx, by, -screenAngleRad()); bx = rb.x; by = rb.y;
    state.base.x = state.base.x*(1-S) + bx*S;
    state.base.y = state.base.y*(1-S) + by*S;

    updateHUD();
  }
  function onOrientation(e){
    if(state.motionSeen) return;
    const beta=(e.beta||0)*Math.PI/180, gamma=(e.gamma||0)*Math.PI/180;
    let gx=Math.sin(gamma), gy=Math.sin(beta);
    const r=rotate2D(gx,gy,-screenAngleRad()); const m=Math.hypot(r.x,r.y)||1e-6;
    const S = state.smooth;
    state.gVec.x = state.gVec.x*(1-S) + (r.x/m)*S;
    state.gVec.y = state.gVec.y*(1-S) + (r.y/m)*S;
    state.gMag = 9.81; state.base.x = 0; state.base.y = 0;
    updateHUD();
  }
  function updateHUD(){
    hud.innerHTML = `g≈ <strong>${state.gMag.toFixed(2)}</strong> m/s² · accel≈ <strong>${Math.hypot(state.base.x,state.base.y).toFixed(2)}</strong> m/s² · seg <strong>${state.N}</strong>`;
  }

  async function enableMotion(){
    try{
      if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        const r = await DeviceMotionEvent.requestPermission(); if(r!=='granted') throw new Error('Permission denied');
      }
      addEventListener('devicemotion', onMotion, {passive:true});
      addEventListener('deviceorientation', onOrientation, {passive:true});
      state.enabled=true; state.demo=false; gate.style.display='none'; updateHUD();
    }catch(err){
      alert('Motion access failed: '+err.message+'\nTip: Safari on iPhone, HTTPS, Motion & Orientation Access enabled.');
    }
  }
  function enableDemo(){ state.enabled=false; state.demo=true; gate.style.display='none'; updateHUD(); }

  // Verlet + constraints
  function step(dt){
    const pts = state.points; if(!pts.length) return;
    // Total acceleration in px/s^2 = gravity + inertial(-base)
    const ax = (state.gVec.x*state.gMag - state.base.x) * state.pxPerMeter;
    const ay = (state.gVec.y*state.gMag - state.base.y) * state.pxPerMeter;
    const damp = state.damp;

    // Integrate
    for(let i=1;i<=state.N;i++){
      const p=pts[i], vx=(p.x-p.px), vy=(p.y-p.py), decay=Math.exp(-damp*dt);
      const nx = p.x + vx*decay + ax*dt*dt;
      const ny = p.y + vy*decay + ay*dt*dt;
      p.px=p.x; p.py=p.y; p.x=nx; p.y=ny;
    }
    // Enforce lengths
    const per = state.segLen, iters=state.iters|0, px0=state.cx, py0=state.cy;
    for(let k=0;k<iters;k++){
      // pivot->first
      { const p1=pts[1]; const dx=p1.x-px0, dy=p1.y-py0; const d=Math.hypot(dx,dy)||1e-6;
        const diff=(d-per[0])/d; p1.x -= dx*diff; p1.y -= dy*diff; }
      // links
      for(let i=2;i<=state.N;i++){
        const a=pts[i-1], b=pts[i]; const dx=b.x-a.x, dy=b.y-a.y; const d=Math.hypot(dx,dy)||1e-6;
        const diff=(d-per[i-1])/d; const cx=dx*diff*0.5, cy=dy*diff*0.5; a.x+=cx; a.y+=cy; b.x-=cx; b.y-=cy;
      }
    }
  }

  function draw(){
    const w=state.w,h=state.h; ctx.fillStyle='#0b0f12'; ctx.fillRect(0,0,w,h);
    ctx.lineCap='round'; ctx.lineJoin='round'; ctx.strokeStyle='#a9b6cc'; ctx.lineWidth=Math.max(1.5,2.0*state.dpr);
    let x0=state.cx, y0=state.cy;
    for(let i=1;i<=state.N;i++){ const p=state.points[i]; ctx.beginPath(); ctx.moveTo(x0,y0); ctx.lineTo(p.x,p.y); ctx.stroke(); x0=p.x; y0=p.y; }
    for(let i=1;i<=state.N;i++){ const p=state.points[i]; const r=Math.max(8,12*state.dpr)*(i===state.N?1.1:0.9);
      ctx.beginPath(); ctx.arc(p.x,p.y,r*1.8,0,Math.PI*2); ctx.fillStyle='rgba(81,240,147,0.09)'; ctx.fill();
      ctx.beginPath(); ctx.arc(p.x,p.y,r,0,Math.PI*2);
      const g=ctx.createRadialGradient(p.x-r*0.4,p.y-r*0.4,r*0.2,p.x,p.y,r); g.addColorStop(0,'#c4ffd9'); g.addColorStop(1,'#2a3645');
      ctx.fillStyle=g; ctx.fill();
    }
    const now=performance.now(); if(now-state._fpsLast>500){ state.fps=(state._fpsCount*1000)/(now-state._fpsLast); state._fpsCount=0; state._fpsLast=now; fpsEl.textContent=(state.fps|0)+' fps'; } else state._fpsCount++;
  }

  const MAX_DT=0.05, STEP=1/120; let acc=0;
  function loop(t){
    requestAnimationFrame(loop);
    let dt=Math.min(MAX_DT,(t-state.lastT)/1000); if(dt<0) dt=0; state.lastT=t; acc+=dt;
    while(acc>=STEP){
      if(state.demo){ const ang=t/1000*0.6; state.gVec.x=Math.cos(ang); state.gVec.y=Math.sin(ang); state.gMag=9.81; state.base.x=0; state.base.y=0; }
      step(STEP); acc-=STEP;
    }
    draw();
  }
  requestAnimationFrame(loop);

  setSegments(1); updateHUD();

  (async()=>{ try{
    if(typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission!=='function'){ await enableMotion(); }
  }catch{} })();

  document.addEventListener('visibilitychange', ()=>{ if(document.visibilityState!=='visible') return; state.points.forEach(p=>{p.px=p.x; p.py=p.y;}); });
})();
</script>
</body>
</html>