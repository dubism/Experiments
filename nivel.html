<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>RGB String-Dots — fast spikes, audible reaction, precise sliders</title>
<style>
  :root{ --bg:#000; --ink:#fff; --muted:#a6b0bf; --line:rgba(255,255,255,.14); --panel:rgba(16,18,24,.78); }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);overflow:hidden;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;}

  .hud{
    position:fixed; left:10px; bottom:10px; z-index:3; display:grid; gap:8px 10px;
    grid-template-columns:auto 170px 54px; align-items:center;
    background:var(--panel); border:1px solid var(--line); border-radius:12px; padding:10px 12px;
    backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
  }
  .hud label{color:#d6deea;font-size:12px;white-space:nowrap}
  .hud input[type=range]{width:170px}
  .hud .val{color:#cfd7e3;font-size:12px;min-width:54px;text-align:right}
  .pill{position:fixed; right:10px; bottom:10px; z-index:3; background:rgba(255,255,255,.08);
    border:1px solid var(--line); border-radius:999px; padding:7px 10px; color:#cfd7e3; font-size:12px;}

  #overlay{position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg, rgba(0,0,0,.9), rgba(0,0,0,.65)); z-index:5; transition:opacity .25s}
  #overlay.hide{opacity:0; pointer-events:none}
  .panel{background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:16px 18px; text-align:center; width:min(92vw,380px)}
  .row{display:flex; gap:10px; justify-content:center}
  button{appearance:none;border:0;border-radius:999px;padding:10px 14px;font-weight:650;cursor:pointer;background:#e6f0ff;color:#0b1220}
  .chips{display:flex; gap:8px; justify-content:center; margin-top:8px}
  .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
    border:1px solid var(--line); background:rgba(255,255,255,.06); font-size:12px; color:#cfd7e3}
  .dot{width:8px;height:8px;border-radius:50%;background:#999}
  .ok .dot{background:#39d98a} .err .dot{background:#ff6b6b}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <!-- Controls: Looseness (↓k), Bounce (↓damping), Grid spacing, Dot size -->
  <div class="hud" id="hud">
    <label for="loose">Looseness</label><input id="loose" type="range" min="0" max="100" value="45"><span id="looseV" class="val">45</span>
    <label for="bounce">Bounce</label>   <input id="bounce" type="range" min="0" max="100" value="35"><span id="bounceV" class="val">35</span>
    <label for="space">Grid</label>      <input id="space"  type="range" min="12" max="60" value="28"><span id="spaceV"  class="val">28</span>
    <label for="dot">Dot</label>         <input id="dot"    type="range" min="1"  max="8"  value="3"><span  id="dotV"    class="val">3</span>
  </div>
  <div class="pill" id="pill">Mic – • Motion –</div>

  <div id="overlay">
    <div class="panel">
      <div style="font-weight:650;margin-bottom:6px">Enable sensors</div>
      <div style="color:#c9d2df;margin-bottom:10px">Tap once to allow microphone & motion (iOS requires this).</div>
      <div class="row">
        <button id="enable">Enable mic + motion</button>
        <button id="skip" style="background:#d7ddea">Skip</button>
      </div>
      <div class="chips">
        <div id="stMic" class="chip"><span class="dot"></span><span>Mic</span></div>
        <div id="stMot" class="chip"><span class="dot"></span><span>Motion</span></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===== Canvas =====
  const cvs = document.getElementById('cv');
  const ctx  = cvs.getContext('2d', { alpha:false });
  let dpr = Math.max(1, devicePixelRatio || 1);
  let needsLayout = false;

  function resize(){
    const r = cvs.getBoundingClientRect();
    cvs.width  = Math.floor(r.width  * dpr);
    cvs.height = Math.floor(r.height * dpr);
    needsLayout = true;
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // ===== UI (precise mappings, labels are literal) =====
  const ui = {
    loose:  document.getElementById('loose'),   // higher -> looser -> LOWER stiffness
    bounce: document.getElementById('bounce'),  // higher -> MORE bounce -> LOWER damping
    space:  document.getElementById('space'),
    dot:    document.getElementById('dot'),
    looseV: document.getElementById('looseV'),
    bounceV:document.getElementById('bounceV'),
    spaceV: document.getElementById('spaceV'),
    dotV:   document.getElementById('dotV'),
  };
  function syncVals(){
    ui.looseV.textContent  = ui.loose.value;
    ui.bounceV.textContent = ui.bounce.value;
    ui.spaceV.textContent  = ui.space.value;
    ui.dotV.textContent    = ui.dot.value;
  }
  ['input','change'].forEach(ev=>{
    ui.loose .addEventListener(ev, syncVals);
    ui.bounce.addEventListener(ev, syncVals);
    ui.space .addEventListener(ev, ()=>{ spacing = Number(ui.space.value); needsLayout = true; syncVals(); });
    ui.dot   .addEventListener(ev, ()=>{ radius  = Number(ui.dot.value);  syncVals(); });
  });
  syncVals();

  // Derived physics params from sliders — linear and *literal*:
  // k = k_min .. k_max, Looseness higher -> smaller k
  // damping c = c_min .. c_max, Bounce higher -> smaller c (more oscillation)
  const K_MIN = 6,  K_MAX = 120;  // higher = snappier
  const C_MIN = 0.02, C_MAX = 2.2;

  function params(){
    const L = Number(ui.loose.value);   // 0..100
    const B = Number(ui.bounce.value);  // 0..100
    const k = K_MIN + (100 - L) * (K_MAX - K_MIN) / 100;               // Looseness↑ → k↓
    const c = C_MIN + (100 - B) * (C_MAX - C_MIN) / 100;               // Bounce↑   → c↓
    return { k, c };
  }

  // ===== Grid (triangular) =====
  const dots = [];  // {rx,ry,x,y,vx,vy}
  let spacing = Number(ui.space.value); // CSS px
  let radius  = Number(ui.dot.value);   // CSS px
  function S(){ return spacing * dpr; }
  function R(){ return radius  * dpr; }

  function buildTriGrid(){
    dots.length = 0;
    const W = cvs.width, H = cvs.height, s = S();
    const rowH = s * Math.sqrt(3)/2;
    const cols = Math.floor(W / s);
    const rows = Math.floor(H / rowH);
    const offX = (W - cols * s) / 2;
    const offY = (H - rows * rowH) / 2;
    for (let j=0; j<=rows; j++){
      const y = offY + j * rowH;
      const xShift = (j % 2) ? s/2 : 0;
      for (let i=0; i<=cols; i++){
        const x = offX + xShift + i * s;
        dots.push({ rx:x, ry:y, x, y, vx:0, vy:0 });
      }
    }
  }
  buildTriGrid();

  // ===== Inputs =====
  // Touch → sharp impulses (spiky)
  let ripples = []; // {x,y,t,amp,life}
  function addImpulse(cssX, cssY, amp = 1){
    const rect = cvs.getBoundingClientRect();
    ripples.push({
      x: (cssX - rect.left) * dpr,
      y: (cssY - rect.top)  * dpr,
      t: performance.now()/1000,
      amp,
      life: 0.45 // seconds — short, punchy
    });
  }
  let dragging = false;
  cvs.addEventListener('pointerdown', e => { dragging = true; addImpulse(e.clientX,e.clientY, 1.3); });
  cvs.addEventListener('pointermove', e => { if (dragging) addImpulse(e.clientX,e.clientY, 0.7); });
  ['pointerup','pointercancel','pointerleave'].forEach(ev => cvs.addEventListener(ev, ()=> dragging=false));
  cvs.style.touchAction = 'none';

  // Microphone → audible spikes (attack/decay envelope + transient detector)
  let audioEnv = 0, micOK = false;
  let audioPeak = 0;
  function enableMic(){
    return new Promise(async (resolve) => {
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        const ac = new AC();
        await ac.resume();
        const stream = await navigator.mediaDevices.getUserMedia({audio:true});
        const src = ac.createMediaStreamSource(stream);
        const ana = ac.createAnalyser();
        ana.fftSize = 1024;
        src.connect(ana);
        const buf = new Uint8Array(ana.fftSize);
        micOK = true;

        const ATTACK = 0.08, RELEASE = 0.20; // fast attack, short sustain
        const THRESH = 0.04;                 // gate to avoid noise floor
        const GAIN   = 6.5;                  // audible reaction gain

        (function tick(){
          ana.getByteTimeDomainData(buf);
          let sum=0;
          for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
          const rms = Math.sqrt(sum/buf.length);        // 0..~0.7
          // envelope follower (attack/decay)
          audioEnv = (rms > audioEnv) ? (audioEnv + (rms - audioEnv)* (1 - Math.exp(-1/ (60*ATTACK))))
                                      : (audioEnv + (rms - audioEnv)* (1 - Math.exp(-1/ (60*RELEASE))));
          // simple transient: rising edge over threshold
          const spike = Math.max(0, rms - Math.max(THRESH, audioPeak*0.9));
          audioPeak = Math.max(rms, audioPeak*0.92);

          // If a spike, inject a brief global impulse around center
          if (spike > 0.015){
            const cx = cvs.width*0.5, cy = cvs.height*0.5;
            ripples.push({ x:cx, y:cy, t:performance.now()/1000, amp: GAIN * spike, life: 0.30 });
          }
          requestAnimationFrame(tick);
        })();
        resolve(true);
      }catch(e){ micOK = false; resolve(false); }
    });
  }

  // Motion
  let tilt = {x:0,y:0}, motOK=false;
  function enableMotion(){
    return new Promise(async (resolve) => {
      try{
        if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
          const res = await DeviceMotionEvent.requestPermission();
          if (res!=='granted') throw new Error('denied');
        }
        let got = false;
        const handler = (e)=>{
          const g = e.accelerationIncludingGravity || {};
          tilt.x = g.x || 0; tilt.y = -(g.y || 0);
          motOK = true; got = true;
        };
        addEventListener('devicemotion', handler, {passive:true});
        setTimeout(()=>{ resolve(got); }, 800);
      }catch(e){ motOK=false; resolve(false); }
    });
  }

  // Overlay / permissions — never block UI
  const overlay = document.getElementById('overlay');
  const stMicEl = document.getElementById('stMic');
  const stMotEl = document.getElementById('stMot');
  const skipBtn = document.getElementById('skip');
  function mark(el, cls){ el.classList.remove('ok','err'); if (cls) el.classList.add(cls); }
  document.getElementById('enable').addEventListener('click', async ()=>{
    mark(stMicEl,''); mark(stMotEl,'');
    const [m1,m2] = await Promise.allSettled([enableMic(), enableMotion()]);
    mark(stMicEl, (m1.status==='fulfilled' && m1.value) ? 'ok' : 'err');
    mark(stMotEl, (m2.status==='fulfilled' && m2.value) ? 'ok' : 'err');
    overlay.classList.add('hide');
  });
  skipBtn.addEventListener('click', ()=> overlay.classList.add('hide'));
  const pill = document.getElementById('pill');
  function setPill(){ pill.textContent = `Mic ${micOK?'✓':'–'} • Motion ${motOK?'✓':'–'}`; }

  // ===== Simulation (spiky, short-lived) =====
  let lastT = performance.now()/1000;

  function step(){
    const now = performance.now()/1000;
    let dt = now - lastT; if (dt > 0.033) dt = 0.033; lastT = now;

    if (needsLayout){ buildTriGrid(); needsLayout=false; }

    // short, punchy ripples
    ripples = ripples.filter(r => now - r.t < r.life);

    const {k, c} = params();
    const s = S();

    // Audio force magnitude — noticeable
    const audioMag = audioEnv * 1.4 * s;  // boosted
    const tiltMag  = 0.08 * s;

    // Two substeps for snappier stability at high k
    const sub = 2;
    const h = dt / sub;

    for (let ss=0; ss<sub; ss++){
      for (let i=0;i<dots.length;i++){
        const d = dots[i];

        // Hooke to rest + damping (semi-implicit Euler)
        let fx = -k * (d.x - d.rx) - c * d.vx;
        let fy = -k * (d.y - d.ry) - c * d.vy;

        // Ripples: very sharp Gaussian shell (narrow sigma)
        for (let j=0;j<ripples.length;j++){
          const r = ripples[j];
          const age = now - r.t + ss*h;
          const rr = Math.hypot(d.x - r.x, d.y - r.y) + 1e-6;
          const travel = (age * (2.2 * s)); // faster wavefront
          const sigma  = 0.45 * s;          // tight
          const g = Math.exp(-((rr - travel)*(rr - travel)) / (2 * sigma * sigma)) * r.amp;
          const ux = (d.x - r.x)/rr, uy=(d.y - r.y)/rr;
          fx += ux * g * 2.1 * s;
          fy += uy * g * 2.1 * s;
        }

        // Audio swirl (add a *kick* feel)
        fx += Math.sin((d.rx + d.ry + now*900)*0.004) * audioMag;
        fy += Math.cos((d.rx - d.ry - now*900)*0.004) * audioMag;

        // Tilt
        fx += tilt.x * tiltMag;
        fy += tilt.y * tiltMag;

        // Integrate
        d.vx += fx * h;
        d.vy += fy * h;
        d.x  += d.vx * h;
        d.y  += d.vy * h;
      }
    }
  }

  // ===== Render (no trails, full redraw) =====
  function render(){
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cvs.width,cvs.height);

    ctx.globalCompositeOperation = 'lighter';
    const r = R();

    for (let i=0;i<dots.length;i++){
      const d = dots[i];
      const dx = d.x - d.rx, dy = d.y - d.ry;
      const disp = Math.hypot(dx,dy);
      const baseAngle = disp < 1e-6 ? 0 : Math.atan2(dy, dx);

      // Channel separation: directly proportional, clamped
      const sep = Math.min(disp * 0.70, 0.8 * S());

      const channels = [
        { ang: baseAngle + 0,                col:'rgb(255,0,0)', scale: 1.00 },
        { ang: baseAngle + 2*Math.PI/3,     col:'rgb(0,255,0)', scale: 0.94 },
        { ang: baseAngle - 2*Math.PI/3,     col:'rgb(0,0,255)', scale: 1.06 }
      ];
      for (let k=0;k<3;k++){
        const a = channels[k];
        const offx = Math.cos(a.ang) * sep * a.scale;
        const offy = Math.sin(a.ang) * sep * a.scale;
        ctx.fillStyle = a.col;
        ctx.beginPath(); ctx.arc(d.x + offx, d.y + offy, r, 0, Math.PI*2); ctx.fill();
      }

      // Snap clean to white when nearly still
      if (disp < 0.35 * dpr){
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(d.rx, d.ry, r, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'lighter';
      }
    }
  }

  // ===== Loop =====
  function loop(){ step(); render(); setPill(); requestAnimationFrame(loop); }
  loop();

  // ===== Permissions wiring =====
  const overlay = document.getElementById('overlay');
  document.getElementById('enable').addEventListener('click', async ()=>{
    const stMicEl = document.getElementById('stMic');
    const stMotEl = document.getElementById('stMot');
    stMicEl.classList.remove('ok','err'); stMotEl.classList.remove('ok','err');
    const [m1,m2] = await Promise.allSettled([enableMic(), enableMotion()]);
    stMicEl.classList.add((m1.status==='fulfilled' && m1.value)?'ok':'err');
    stMotEl.classList.add((m2.status==='fulfilled' && m2.value)?'ok':'err');
    overlay.classList.add('hide'); // never block
  });
  document.getElementById('skip').addEventListener('click', ()=> overlay.classList.add('hide'));
})();
</script>
</body>
</html>