<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>RGB String-Dots — mobile CC, precise sliders</title>
<style>
  :root{ --bg:#000; --ink:#fff; --muted:#a6b0bf; --line:rgba(255,255,255,.14); --panel:rgba(16,18,24,.78); }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);overflow:hidden;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;}

  /* Control Center (CC) */
  .cc{
    position:fixed; left:10px; right:10px; bottom:10px; z-index:3;
    background:var(--panel); border:1px solid var(--line); border-radius:14px;
    backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
    box-shadow:0 8px 24px rgba(0,0,0,.35);
  }
  .cc__head{ display:flex; align-items:center; justify-content:space-between; gap:8px; padding:10px 12px; cursor:pointer; }
  .cc__title{ font-weight:650; letter-spacing:.2px; }
  .cc__chev{ width:22px; height:22px; border-radius:999px; display:grid; place-items:center; border:1px solid var(--line); background:rgba(255,255,255,.06); }
  .cc__body{ padding:6px 12px 10px; display:grid; gap:10px; grid-template-columns:1fr; }
  .ctrl{
    display:grid; grid-template-columns:auto 1fr auto; gap:8px; align-items:center;
    background:rgba(255,255,255,.03); border:1px solid rgba(255,255,255,.08);
    border-radius:10px; padding:8px 10px;
  }
  .ctrl--withbtn{ grid-template-columns:auto 1fr auto auto; }
  .ctrl__label{ color:#d6deea; font-size:12px; white-space:nowrap; }
  .ctrl__val{ color:#cfd7e3; font-size:12px; min-width:42px; text-align:right; }
  .ctrl input[type=range]{ width:100%; }
  .btn{
    appearance:none; border:1px solid var(--line); background:rgba(255,255,255,.08); color:#e8eef7;
    padding:6px 10px; border-radius:9px; cursor:pointer; font-weight:600; font-size:12px;
  }
  .btn.ok{ background:rgba(57,217,138,.14); border-color:rgba(57,217,138,.4) }
  .btn.err{ background:rgba(255,107,107,.14); border-color:rgba(255,107,107,.4) }
  .meter{ position:relative; height:6px; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden; grid-column:1 / -1; }
  .meter__fill{ position:absolute; left:0; top:0; bottom:0; width:0%; background:#9bd2ff; }

  .cc[data-collapsed="true"] .cc__body{ display:none; }
  .cc[data-collapsed="true"] .cc__chev{ transform:rotate(180deg); }

  @media (min-width:520px){
    .cc__body{ grid-template-columns:1fr 1fr; }
    .ctrl{ grid-column:span 1; }
    .ctrl.span2{ grid-column:span 2; }
  }
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <section class="cc" id="cc" data-collapsed="false">
    <div class="cc__head" id="ccHead">
      <div class="cc__title">Controls</div><div class="cc__chev" aria-hidden="true">▾</div>
    </div>
    <div class="cc__body">
      <!-- Defaults: Looseness 20, Bounce 20, Grid 25, Dot 7 -->
      <div class="ctrl"><div class="ctrl__label">Looseness</div><input id="loose" type="range" min="0" max="100" value="20"><div id="looseV" class="ctrl__val">20</div></div>
      <div class="ctrl"><div class="ctrl__label">Bounce</div>   <input id="bounce" type="range" min="0" max="100" value="20"><div id="bounceV" class="ctrl__val">20</div></div>
      <div class="ctrl"><div class="ctrl__label">Grid</div>     <input id="space"  type="range" min="12" max="60" value="25"><div id="spaceV"  class="ctrl__val">25</div></div>
      <div class="ctrl"><div class="ctrl__label">Dot</div>      <input id="dot"    type="range" min="1"  max="10" value="7"><div  id="dotV"    class="ctrl__val">7</div></div>

      <!-- Motion sensitivity (default 0.50) + permission -->
      <div class="ctrl ctrl--withbtn span2">
        <div class="ctrl__label">Motion sensitivity</div>
        <input id="motionSens" type="range" min="0" max="100" value="50" step="1">
        <div id="motionSensV" class="ctrl__val">0.50</div>
        <button class="btn" id="motionBtn" type="button">Motion</button>
      </div>

      <!-- Sound sensitivity (default 0.35) + permission -->
      <div class="ctrl ctrl--withbtn span2">
        <div class="ctrl__label">Sound sensitivity</div>
        <input id="soundSens" type="range" min="0" max="100" value="35" step="1">
        <div id="soundSensV" class="ctrl__val">0.35</div>
        <button class="btn" id="micBtn" type="button">Mic</button>
      </div>

      <!-- Touch controls -->
      <div class="ctrl"><div class="ctrl__label">Touch sensitivity</div><input id="touchSens" type="range" min="0" max="100" value="70"><div id="touchSensV" class="ctrl__val">0.70</div></div>
      <div class="ctrl"><div class="ctrl__label">Touch radius</div><input id="touchRad" type="range" min="10" max="100" value="45"><div id="touchRadV" class="ctrl__val">0.45</div></div>

      <!-- Live mic level meter -->
      <div class="meter span2" aria-hidden="true"><div class="meter__fill" id="meterFill"></div></div>
    </div>
  </section>

<script>
(() => {
  // ===== Canvas =====
  const cvs = document.getElementById('cv');
  const ctx  = cvs.getContext('2d', { alpha:false });
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let needsLayout = false;

  function resize(){
    const r = cvs.getBoundingClientRect();
    cvs.width  = Math.floor(r.width  * dpr);
    cvs.height = Math.floor(r.height * dpr);
    needsLayout = true;
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // ===== CC collapse =====
  const cc = document.getElementById('cc');
  document.getElementById('ccHead').addEventListener('click', () => {
    cc.dataset.collapsed = (cc.dataset.collapsed === 'true') ? 'false' : 'true';
  });

  // ===== UI =====
  const ui = {
    loose:  document.getElementById('loose'),
    bounce: document.getElementById('bounce'),
    space:  document.getElementById('space'),
    dot:    document.getElementById('dot'),
    looseV: document.getElementById('looseV'),
    bounceV:document.getElementById('bounceV'),
    spaceV: document.getElementById('spaceV'),
    dotV:   document.getElementById('dotV'),
    motionSens: document.getElementById('motionSens'),
    soundSens:  document.getElementById('soundSens'),
    motionSensV:document.getElementById('motionSensV'),
    soundSensV: document.getElementById('soundSensV'),
    touchSens:  document.getElementById('touchSens'),
    touchRad:   document.getElementById('touchRad'),
    touchSensV: document.getElementById('touchSensV'),
    touchRadV:  document.getElementById('touchRadV'),
    micBtn:     document.getElementById('micBtn'),
    motionBtn:  document.getElementById('motionBtn'),
    meterFill:  document.getElementById('meterFill'),
  };

  function syncVals(){
    ui.looseV.textContent   = ui.loose.value;
    ui.bounceV.textContent  = ui.bounce.value;
    ui.spaceV.textContent   = ui.space.value;
    ui.dotV.textContent     = ui.dot.value;
    ui.motionSensV.textContent = (Number(ui.motionSens.value)/100).toFixed(2);
    ui.soundSensV.textContent  = (Number(ui.soundSens.value)/100).toFixed(2);
    ui.touchSensV.textContent  = (Number(ui.touchSens.value)/100).toFixed(2);
    ui.touchRadV.textContent   = (Number(ui.touchRad.value)/100).toFixed(2);
  }
  ['input','change'].forEach(ev=>{
    ui.loose .addEventListener(ev, syncVals);
    ui.bounce.addEventListener(ev, syncVals);
    ui.space .addEventListener(ev, ()=>{ spacing = Number(ui.space.value); needsLayout = true; syncVals(); });
    ui.dot   .addEventListener(ev, ()=>{ radius  = Number(ui.dot.value);  syncVals(); });
    ui.motionSens.addEventListener(ev, syncVals);
    ui.soundSens .addEventListener(ev, syncVals);
    ui.touchSens .addEventListener(ev, syncVals);
    ui.touchRad  .addEventListener(ev, syncVals);
  });
  syncVals();

  // ===== Physics params =====
  const K_MIN = 6,  K_MAX = 160;
  const C_MIN = 0.01, C_MAX = 2.2;
  function params(){
    const L = Number(ui.loose.value);
    const B = Number(ui.bounce.value);
    const k = K_MIN + (100 - L) * (K_MAX - K_MIN) / 100; // Looseness↑ → k↓
    const c = C_MIN + (100 - B) * (C_MAX - C_MIN) / 100; // Bounce↑   → c↓
    return { k, c };
  }

  // ===== Grid (triangular) =====
  const dots = [];  // {rx,ry,x,y,vx,vy}
  let spacing = Number(ui.space.value);
  let radius  = Number(ui.dot.value);
  function S(){ return spacing * dpr; }
  function R(){ return radius  * dpr; }

  function buildTriGrid(){
    dots.length = 0;
    const W = cvs.width, H = cvs.height, s = S();
    const rowH = s * Math.sqrt(3)/2;
    const cols = Math.floor(W / s);
    const rows = Math.floor(H / rowH);
    const offX = (W - cols * s) / 2;
    const offY = (H - rows * rowH) / 2;
    for (let j=0; j<=rows; j++){
      const y = offY + j * rowH;
      const xShift = (j % 2) ? s/2 : 0;
      for (let i=0; i<=cols; i++){
        const x = offX + xShift + i * s;
        dots.push({ rx:x, ry:y, x, y, vx:0, vy:0 });
      }
    }
  }
  buildTriGrid();

  // ===== Inputs =====
  // Touch → impulse; slider control
  let ripples = []; // {x,y,t,amp,life, sigma}
  function addImpulse(cssX, cssY, baseAmp){
    const rect = cvs.getBoundingClientRect();
    const sens = Number(ui.touchSens.value)/100;   // 0..1
    const sigma = (Number(ui.touchRad.value)/100) * S(); // 0..1 of grid spacing
    ripples.push({
      x: (cssX - rect.left) * dpr,
      y: (cssY - rect.top)  * dpr,
      t: performance.now()/1000,
      amp: baseAmp * (0.5 + 1.5*sens), // 0.5..2.0x
      life: 0.35,
      sigma
    });
  }
  let dragging = false;
  cvs.addEventListener('pointerdown', e => { dragging = true; addImpulse(e.clientX,e.clientY, 1.3); });
  cvs.addEventListener('pointermove', e => { if (dragging) addImpulse(e.clientX,e.clientY, 0.7); });
  ['pointerup','pointercancel','pointerleave'].forEach(ev => cvs.addEventListener(ev, ()=> dragging=false));
  cvs.style.touchAction = 'none';

  // ===== Microphone (unchanged pipeline) =====
  let micOK = false;
  let rms = 0, noise = 0.01, env = 0, peak = 0, strength = 0;
  function enableMic(){
    return new Promise(async (resolve) => {
      try{
        const AC = window.AudioContext || window.webkitAudioContext;
        const ac = new AC(); await ac.resume();
        const stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true, noiseSuppression:true}});
        const src = ac.createMediaStreamSource(stream);
        const ana = ac.createAnalyser(); ana.fftSize = 1024; src.connect(ana);
        const buf = new Uint8Array(ana.fftSize);
        micOK = true; ui.micBtn.classList.add('ok'); ui.micBtn.textContent='Mic ✓';

        const ATTACK = 0.05, RELEASE = 0.15;
        const NOISE_TC = 0.995, GAIN = 22, RIPPLE_GAIN = 8, SPIKE_GATE = 0.006;

        (function tick(){
          ana.getByteTimeDomainData(buf);
          let sum=0; for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
          rms = Math.sqrt(sum/buf.length);
          noise = (rms < noise) ? (NOISE_TC*noise + (1-NOISE_TC)*rms) : (0.999*noise + 0.001*rms);
          const atk = 1 - Math.exp(-1/(60*ATTACK));
          const rel = 1 - Math.exp(-1/(60*RELEASE));
          env = (rms > env) ? env + (rms - env)*atk : env + (rms - env)*rel;
          const relAmp = Math.max(0, rms - noise);
          strength = Math.min(1.5, Math.sqrt(relAmp * GAIN));
          const spike = Math.max(0, rms - Math.max(noise*1.2, peak*0.92));
          peak = Math.max(rms, peak*0.92);
          if (spike > SPIKE_GATE){
            const cx = cvs.width*0.5, cy = cvs.height*0.5;
            ripples.push({ x:cx, y:cy, t:performance.now()/1000, amp: RIPPLE_GAIN * spike, life: 0.25, sigma: 0.42*S() });
          }
          ui.meterFill.style.width = (Math.min(1, (rms - noise)*40) * 100).toFixed(1) + '%';
          requestAnimationFrame(tick);
        })();
        resolve(true);
      }catch(e){ micOK=false; ui.micBtn.classList.add('err'); ui.micBtn.textContent='Mic ⚠︎'; resolve(false); }
    });
  }
  ui.micBtn.addEventListener('click', enableMic);

  // ===== Motion: orientation + linear acceleration =====
  let tilt = {x:0,y:0}, shake = 0, motOK=false;
  function enableMotion(){
    return new Promise(async (resolve) => {
      try{
        if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
          const res = await DeviceMotionEvent.requestPermission();
          if (res!=='granted') throw new Error('denied');
        }
        let got = false;
        // High-pass for linear acceleration magnitude (shake)
        let hp = 0;
        addEventListener('devicemotion', e=>{
          const g = e.accelerationIncludingGravity || {};
          tilt.x = g.x || 0; tilt.y = -(g.y || 0);  // orientation vector

          const a = e.acceleration || {};           // gravity-removed (linear)
          const mag = Math.hypot(a.x||0, a.y||0, a.z||0); // m/s^2
          // simple high-pass / decay
          hp = Math.max(0, mag - 0.8) * 0.6 + hp * 0.85;
          shake = hp; // 0..~several; we’ll scale later

          motOK = true; got = true;
          ui.motionBtn.classList.add('ok'); ui.motionBtn.textContent='Motion ✓';
        }, {passive:true});
        setTimeout(()=>{ if(!got){ ui.motionBtn.classList.add('err'); ui.motionBtn.textContent='Motion ⚠︎'; } resolve(got); }, 800);
      }catch(e){ motOK=false; ui.motionBtn.classList.add('err'); ui.motionBtn.textContent='Motion ⚠︎'; resolve(false); }
    });
  }
  ui.motionBtn.addEventListener('click', enableMotion);

  // ===== Simulation (same dynamics; inputs scaled by sliders) =====
  let lastT = performance.now()/1000;

  function step(){
    const now = performance.now()/1000;
    let dt = now - lastT; if (dt > 0.033) dt = 0.033; lastT = now;
    if (needsLayout){ buildTriGrid(); needsLayout=false; }

    ripples = ripples.filter(r => now - r.t < r.life);

    const {k, c} = params();
    const s = S();

    // Slider sensitivities
    const motionSens = Number(ui.motionSens.value) / 100; // 0..1
    const soundSens  = Number(ui.soundSens.value)  / 100; // 0..1

    // Audio → target displacement (k-independent)
    const x_target = soundSens * strength * 0.40 * s;
    const tiltMag  = motionSens * (0.08 * s);
    const shakeMag = motionSens * (Math.min(1.0, shake / 5) * 0.60 * s); // fast spikes

    const sub = 2; const h = dt / sub;

    for (let ss=0; ss<sub; ss++){
      for (let i=0;i<dots.length;i++){
        const d = dots[i];

        let fx = -k * (d.x - d.rx) - c * d.vx;
        let fy = -k * (d.y - d.ry) - c * d.vy;

        // Touch ripples
        for (let j=0;j<ripples.length;j++){
          const r = ripples[j];
          const age = now - r.t + ss*h;
          const rr = Math.hypot(d.x - r.x, d.y - r.y) + 1e-6;
          const travel = (age * (2.4 * s));
          const sigma  = r.sigma ?? (0.42 * s);
          const g = Math.exp(-((rr - travel)*(rr - travel)) / (2 * sigma * sigma)) * r.amp;
          const ux = (d.x - r.x)/rr, uy=(d.y - r.y)/rr;
          fx += ux * g * 2.2 * s;
          fy += uy * g * 2.2 * s;
        }

        // Audio swirl (k * x_target)
        if (x_target > 0){
          const sx = Math.sin((d.rx + d.ry + now*900)*0.004);
          const sy = Math.cos((d.rx - d.ry - now*900)*0.004);
          fx += sx * (k * x_target);
          fy += sy * (k * x_target);
        }

        // Tilt (orientation) + shake (linear acceleration)
        if (motionSens > 0){
          fx += tilt.x * tiltMag;
          fy += tilt.y * tiltMag;
          // add brief omnidirectional push from shakes
          fx += (Math.sin(now*40 + d.rx*0.002) * shakeMag);
          fy += (Math.cos(now*40 - d.ry*0.002) * shakeMag);
        }

        d.vx += fx * h;
        d.vy += fy * h;
        d.x  += d.vx * h;
        d.y  += d.vy * h;
      }
    }
  }

  // ===== Render (no trails) =====
  function render(){
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cvs.width,cvs.height);

    ctx.globalCompositeOperation = 'lighter';
    const r = R();

    for (let i=0;i<dots.length;i++){
      const d = dots[i];
      const dx = d.x - d.rx, dy = d.y - d.ry;
      const disp = Math.hypot(dx,dy);
      const baseAngle = disp < 1e-6 ? 0 : Math.atan2(dy, dx);
      const sep = Math.min(disp * 0.70, 0.8 * S());

      const channels = [
        { ang: baseAngle + 0,                col:'rgb(255,0,0)', scale: 1.00 },
        { ang: baseAngle + 2*Math.PI/3,     col:'rgb(0,255,0)', scale: 0.94 },
        { ang: baseAngle - 2*Math.PI/3,     col:'rgb(0,0,255)', scale: 1.06 }
      ];
      for (let k=0;k<3;k++){
        const a = channels[k];
        const offx = Math.cos(a.ang) * sep * a.scale;
        const offy = Math.sin(a.ang) * sep * a.scale;
        ctx.fillStyle = a.col;
        ctx.beginPath(); ctx.arc(d.x + offx, d.y + offy, r, 0, Math.PI*2); ctx.fill();
      }

      if (disp < 0.35 * dpr){
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(d.rx, d.ry, r, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'lighter';
      }
    }
  }

  // ===== Loop =====
  function loop(){ step(); render(); requestAnimationFrame(loop); }
  loop();
})();
</script>
</body>
</html>