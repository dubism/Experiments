<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>RGB String-Dots — motion vector spread</title>
<style>
  :root{ --bg:#000; --ink:#fff; --line:rgba(255,255,255,.14); --panel:rgba(16,18,24,.78); }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);overflow:hidden;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}

  .cc{
    position:fixed; left:10px; right:10px; bottom:10px; z-index:3;
    background:var(--panel); border:1px solid var(--line); border-radius:14px;
    backdrop-filter:blur(10px); -webkit-backdrop-filter:blur(10px);
  }
  .cc__head{display:flex;align-items:center;justify-content:space-between;gap:8px;padding:10px 12px;cursor:pointer}
  .cc__title{font-weight:650}
  .cc__chev{width:22px;height:22px;border-radius:999px;display:grid;place-items:center;border:1px solid var(--line);background:rgba(255,255,255,.06)}
  .cc__body{padding:6px 12px 10px;display:grid;gap:10px;grid-template-columns:1fr}
  .ctrl{display:grid;grid-template-columns:auto 1fr auto;gap:8px;align-items:center;background:rgba(255,255,255,.03);border:1px solid rgba(255,255,255,.08);border-radius:10px;padding:8px 10px}
  .ctrl--withbtn{grid-template-columns:auto 1fr auto auto}
  .ctrl__label{font-size:12px;color:#d6deea}
  .ctrl__val{font-size:12px;color:#cfd7e3;min-width:42px;text-align:right}
  .ctrl input[type=range]{width:100%}
  .btn{appearance:none;border:1px solid var(--line);background:rgba(255,255,255,.08);color:#e8eef7;padding:6px 10px;border-radius:9px;cursor:pointer;font-weight:600;font-size:12px}
  .btn.ok{background:rgba(57,217,138,.14);border-color:rgba(57,217,138,.4)}
  .btn.err{background:rgba(255,107,107,.14);border-color:rgba(255,107,107,.4)}

  .meter{position:relative;height:6px;background:rgba(255,255,255,.08);border-radius:999px;overflow:hidden;grid-column:1/-1}
  .meter__fill{position:absolute;left:0;top:0;bottom:0;width:0%;background:#9bd2ff}

  .cc[data-collapsed="true"] .cc__body{display:none}
  .cc[data-collapsed="true"] .cc__chev{transform:rotate(180deg)}

  @media (min-width:520px){
    .cc__body{grid-template-columns:1fr 1fr}
    .ctrl{grid-column:span 1}
    .ctrl.span2{grid-column:span 2}
  }

  video.cam, canvas.cam { position:fixed; left:-9999px; top:-9999px; width:1px; height:1px; opacity:0; pointer-events:none }
</style>
</head>
<body>
<canvas id="cv"></canvas>

<section class="cc" id="cc" data-collapsed="false">
  <div class="cc__head" id="ccHead">
    <div class="cc__title">Controls</div><div class="cc__chev" aria-hidden="true">▾</div>
  </div>
  <div class="cc__body">
    <div class="ctrl"><div class="ctrl__label">Looseness</div><input id="loose" type="range" min="0" max="100" value="20"><div id="looseV" class="ctrl__val">20</div></div>
    <div class="ctrl"><div class="ctrl__label">Bounce</div>   <input id="bounce" type="range" min="0" max="100" value="20"><div id="bounceV" class="ctrl__val">20</div></div>
    <div class="ctrl"><div class="ctrl__label">Grid</div>     <input id="space"  type="range" min="12" max="60" value="25"><div id="spaceV"  class="ctrl__val">25</div></div>
    <div class="ctrl"><div class="ctrl__label">Dot</div>      <input id="dot"    type="range" min="1"  max="10" value="7"><div  id="dotV"    class="ctrl__val">7</div></div>

    <div class="ctrl ctrl--withbtn span2">
      <div class="ctrl__label">Motion sensitivity</div>
      <input id="motionSens" type="range" min="0" max="100" value="50" step="1">
      <div id="motionSensV" class="ctrl__val">0.50</div>
      <button class="btn" id="motionBtn" type="button">Motion</button>
    </div>

    <div class="ctrl ctrl--withbtn span2">
      <div class="ctrl__label">Sound sensitivity</div>
      <input id="soundSens" type="range" min="0" max="100" value="35" step="1">
      <div id="soundSensV" class="ctrl__val">0.35</div>
      <button class="btn" id="micBtn" type="button">Mic</button>
    </div>

    <div class="ctrl ctrl--withbtn span2">
      <div class="ctrl__label">Camera sensitivity</div>
      <input id="camSens" type="range" min="0" max="100" value="60" step="1">
      <div id="camSensV" class="ctrl__val">0.60</div>
      <button class="btn" id="camBtn" type="button">Camera</button>
    </div>

    <div class="ctrl"><div class="ctrl__label">Touch sensitivity</div><input id="touchSens" type="range" min="0" max="100" value="70"><div id="touchSensV" class="ctrl__val">0.70</div></div>
    <div class="ctrl"><div class="ctrl__label">Touch radius</div><input id="touchRad" type="range" min="10" max="100" value="45"><div id="touchRadV" class="ctrl__val">0.45</div></div>

    <div class="meter span2" aria-hidden="true"><div class="meter__fill" id="meterFill"></div></div>
  </div>
</section>

<video id="camVideo" class="cam" playsinline muted autoplay></video>
<canvas id="camCanvas" class="cam"></canvas>

<script>
"use strict";
(function(){
  /* ---------- Canvas ---------- */
  var cvs = document.getElementById('cv');
  var ctx = cvs.getContext('2d', { alpha:false });
  var dpr = Math.max(1, window.devicePixelRatio || 1);
  var needsLayout = false;

  function resize(){
    var r = cvs.getBoundingClientRect();
    cvs.width  = Math.max(1, Math.floor(r.width  * dpr));
    cvs.height = Math.max(1, Math.floor(r.height * dpr));
    needsLayout = true;
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  /* ---------- CC collapse ---------- */
  var cc = document.getElementById('cc');
  document.getElementById('ccHead').addEventListener('click', function(){
    cc.dataset.collapsed = (cc.dataset.collapsed === 'true') ? 'false' : 'true';
  });

  /* ---------- UI ---------- */
  var ui = {
    loose:  document.getElementById('loose'),
    bounce: document.getElementById('bounce'),
    space:  document.getElementById('space'),
    dot:    document.getElementById('dot'),
    looseV: document.getElementById('looseV'),
    bounceV:document.getElementById('bounceV'),
    spaceV: document.getElementById('spaceV'),
    dotV:   document.getElementById('dotV'),
    motionSens: document.getElementById('motionSens'),
    soundSens:  document.getElementById('soundSens'),
    motionSensV:document.getElementById('motionSensV'),
    soundSensV: document.getElementById('soundSensV'),
    touchSens:  document.getElementById('touchSens'),
    touchRad:   document.getElementById('touchRad'),
    touchSensV: document.getElementById('touchSensV'),
    touchRadV:  document.getElementById('touchRadV'),
    camSens:    document.getElementById('camSens'),
    camSensV:   document.getElementById('camSensV'),
    micBtn:     document.getElementById('micBtn'),
    motionBtn:  document.getElementById('motionBtn'),
    camBtn:     document.getElementById('camBtn'),
    meterFill:  document.getElementById('meterFill')
  };

  function syncVals(){
    ui.looseV.textContent   = ui.loose.value;
    ui.bounceV.textContent  = ui.bounce.value;
    ui.spaceV.textContent   = ui.space.value;
    ui.dotV.textContent     = ui.dot.value;
    ui.motionSensV.textContent = (Number(ui.motionSens.value)/100).toFixed(2);
    ui.soundSensV.textContent  = (Number(ui.soundSens.value)/100).toFixed(2);
    ui.touchSensV.textContent  = (Number(ui.touchSens.value)/100).toFixed(2);
    ui.touchRadV.textContent   = (Number(ui.touchRad.value)/100).toFixed(2);
    ui.camSensV.textContent    = (Number(ui.camSens.value)/100).toFixed(2);
  }
  ['input','change'].forEach(function(ev){
    ui.loose .addEventListener(ev, syncVals);
    ui.bounce.addEventListener(ev, syncVals);
    ui.motionSens.addEventListener(ev, syncVals);
    ui.soundSens .addEventListener(ev, syncVals);
    ui.touchSens .addEventListener(ev, syncVals);
    ui.touchRad  .addEventListener(ev, syncVals);
    ui.camSens   .addEventListener(ev, syncVals);
    ui.space.addEventListener(ev, function(){ spacing = Number(ui.space.value); needsLayout = true; syncVals(); });
    ui.dot  .addEventListener(ev, function(){ radius  = Number(ui.dot.value);  syncVals(); });
  });
  syncVals();

  /* ---------- Physics ---------- */
  var K_MIN = 6,  K_MAX = 160;
  var C_MIN = 0.01, C_MAX = 2.2;
  function params(){
    var L = Number(ui.loose.value);
    var B = Number(ui.bounce.value);
    return {
      k: K_MIN + (100 - L) * (K_MAX - K_MIN) / 100,
      c: C_MIN + (100 - B) * (C_MAX - C_MIN) / 100
    };
  }

  /* ---------- Grid (triangular) ---------- */
  var dots = [];  // {rx,ry,x,y,vx,vy,ci,rj,camScale,camTarget}
  var spacing = Number(ui.space.value);
  var radius  = Number(ui.dot.value);
  var gridCols = 0, gridRows = 0;

  function S(){ return spacing * dpr; }
  function R(){ return radius  * dpr; }

  function buildTriGrid(){
    dots.length = 0;
    var W = cvs.width, H = cvs.height, s = S();
    var rowH = s * Math.sqrt(3)/2;

    var cols = Math.max(1, Math.floor(W / s));
    var rows = Math.max(1, Math.floor(H / rowH));
    gridCols = cols + 1;
    gridRows = rows + 1;

    var offX = (W - cols * s) / 2;
    var offY = (H - rows * rowH) / 2;

    for (var j=0; j<=rows; j++){
      var y = offY + j * rowH;
      var xShift = (j % 2) ? s/2 : 0;
      for (var i=0; i<=cols; i++){
        var x = offX + xShift + i * s;
        dots.push({ rx:x, ry:y, x:x, y:y, vx:0, vy:0, ci:i + (j%2?0.5:0), rj:j, camScale:1, camTarget:1 });
      }
    }
  }
  buildTriGrid();

  /* ---------- Touch ---------- */
  var ripples = []; // {x,y,t,amp,life,sigma}
  function addImpulse(cssX, cssY, baseAmp){
    var rect = cvs.getBoundingClientRect();
    var sens = Number(ui.touchSens.value)/100;
    var sigma = (Number(ui.touchRad.value)/100) * S();
    ripples.push({
      x: (cssX - rect.left) * dpr,
      y: (cssY - rect.top)  * dpr,
      t: performance.now()/1000,
      amp: baseAmp * (0.5 + 1.5*sens),
      life: 0.35,
      sigma: sigma
    });
  }
  var dragging = false;
  cvs.addEventListener('pointerdown', function(e){ dragging = true; addImpulse(e.clientX,e.clientY, 1.3); });
  cvs.addEventListener('pointermove', function(e){ if (dragging) addImpulse(e.clientX,e.clientY, 0.7); });
  ['pointerup','pointercancel','pointerleave'].forEach(function(ev){ cvs.addEventListener(ev, function(){ dragging=false; }); });
  cvs.style.touchAction = 'none';

  /* ---------- Mic ---------- */
  var micOK = false;
  var rms = 0, noise = 0.01, env = 0, peak = 0, strength = 0;
  function enableMic(){
    var AC = window.AudioContext || window.webkitAudioContext;
    try{
      var ac = new AC();
      ac.resume().then(function(){
        return navigator.mediaDevices.getUserMedia({audio:{echoCancellation:true, noiseSuppression:true}});
      }).then(function(stream){
        var src = ac.createMediaStreamSource(stream);
        var ana = ac.createAnalyser(); ana.fftSize = 1024; src.connect(ana);
        var buf = new Uint8Array(ana.fftSize);
        micOK = true; ui.micBtn.classList.add('ok'); ui.micBtn.textContent='Mic ✓';

        var ATTACK = 0.05, RELEASE = 0.15, NOISE_TC = 0.995, GAIN = 22, RIPPLE_GAIN = 8, SPIKE_GATE = 0.006;
        (function tick(){
          ana.getByteTimeDomainData(buf);
          var sum=0; for(var i=0;i<buf.length;i++){ var v=(buf[i]-128)/128; sum+=v*v; }
          rms = Math.sqrt(sum/buf.length);
          noise = (rms < noise) ? (NOISE_TC*noise + (1-NOISE_TC)*rms) : (0.999*noise + 0.001*rms);
          var atk = 1 - Math.exp(-1/(60*ATTACK));
          var rel = 1 - Math.exp(-1/(60*RELEASE));
          env = (rms > env) ? env + (rms - env)*atk : env + (rms - env)*rel;
          var relAmp = Math.max(0, rms - noise);
          strength = Math.min(1.5, Math.sqrt(relAmp * GAIN));
          var spike = Math.max(0, rms - Math.max(noise*1.2, peak*0.92));
          peak = Math.max(rms, peak*0.92);
          if (spike > SPIKE_GATE){
            var cx = cvs.width*0.5, cy = cvs.height*0.5;
            ripples.push({ x:cx, y:cy, t:performance.now()/1000, amp: RIPPLE_GAIN * spike, life: 0.25, sigma: 0.42*S() });
          }
          ui.meterFill.style.width = (Math.min(1, (rms - noise)*40) * 100).toFixed(1) + '%';
          requestAnimationFrame(tick);
        })();
      }).catch(function(){ ui.micBtn.classList.add('err'); ui.micBtn.textContent='Mic ⚠︎'; });
    }catch(_){ ui.micBtn.classList.add('err'); ui.micBtn.textContent='Mic ⚠︎'; }
  }
  ui.micBtn.addEventListener('click', enableMic);

  /* ---------- Motion (vector) ---------- */
  // Orientation vector (tilt) + linear acceleration vector (gravity removed)
  var tilt = {x:0, y:0}, acc = {x:0, y:0}; // store components for vector
  function enableMotion(){
    function start(){
      var got=false, hp=0;
      window.addEventListener('devicemotion', function(e){
        var g = e.accelerationIncludingGravity || {};
        tilt.x = g.x || 0; tilt.y = -(g.y || 0);
        var a = e.acceleration || {};
        // low-pass linear acceleration for stability
        acc.x = 0.85*acc.x + 0.15*(a.x || 0);
        acc.y = 0.85*acc.y + 0.15*(-(a.y || 0));
        got=true; ui.motionBtn.classList.add('ok'); ui.motionBtn.textContent='Motion ✓';
      }, {passive:true});
      setTimeout(function(){ if(!got){ ui.motionBtn.classList.add('err'); ui.motionBtn.textContent='Motion ⚠︎'; } }, 800);
    }
    if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
      DeviceMotionEvent.requestPermission().then(function(res){ if (res==='granted') start(); else ui.motionBtn.classList.add('err'); }).catch(function(){ ui.motionBtn.classList.add('err'); });
    } else { start(); }
  }
  ui.motionBtn.addEventListener('click', enableMotion);

  /* ---------- Camera (keep previous behavior: skip+normalize+smooth) ---------- */
  var camVideo = document.getElementById('camVideo');
  var camCanvas = document.getElementById('camCanvas');
  var camCtx = camCanvas.getContext('2d');
  var camOK = false;
  var camLuma = [], camNorm = [];
  function ensureBuffers(){
    var need = gridCols * gridRows;
    if (camLuma.length !== need){ camLuma = new Array(need); for (var i=0;i<need;i++) camLuma[i]=0.5; }
    if (camNorm.length !== need){ camNorm = new Array(need); for (var j=0;j<need;j++) camNorm[j]=0.5; }
  }
  function enableCamera(){
    var constraints = { video:{ facingMode:{ ideal:'environment' }, width:{ ideal:4096 }, height:{ ideal:4096 } }, audio:false };
    navigator.mediaDevices.getUserMedia(constraints).then(function(stream){
      camVideo.srcObject = stream;
      camVideo.play().then(function(){
        try{
          var tracks = stream.getVideoTracks();
          if (tracks && tracks[0] && tracks[0].getCapabilities){
            var caps = tracks[0].getCapabilities();
            if (caps.zoom && typeof caps.zoom.min !== 'undefined'){
              tracks[0].applyConstraints({ advanced:[{ zoom: caps.zoom.min }] }).catch(function(){});
            }
          }
        }catch(_){}
        camOK = true; ui.camBtn.classList.add('ok'); ui.camBtn.textContent='Camera ✓';
      });
    }).catch(function(){ ui.camBtn.classList.add('err'); ui.camBtn.textContent='Camera ⚠︎'; });
  }
  document.getElementById('camBtn').addEventListener('click', enableCamera);

  var frameCount = 0, CAM_SMOOTH = 0.18;
  function sampleCameraToGrid(){
    if (!camOK || gridCols<=0 || gridRows<=0) return;
    if (camVideo.readyState < 2) return;
    ensureBuffers();

    if (camCanvas.width !== gridCols || camCanvas.height !== gridRows){
      camCanvas.width = gridCols; camCanvas.height = gridRows;
    }
    var vw = camVideo.videoWidth || 640;
    var vh = camVideo.videoHeight || 480;
    if (!vw || !vh) return;

    var cw = camCanvas.width, ch = camCanvas.height;
    var rVideo = vw/vh, rCanvas = cw/ch;
    var sx, sy, sw, sh;
    if (rVideo > rCanvas){ sh = vh; sw = sh * rCanvas; sx = (vw - sw)/2; sy = 0; }
    else { sw = vw; sh = sw / rCanvas; sx = 0; sy = (vh - sh)/2; }

    camCtx.drawImage(camVideo, sx, sy, sw, sh, 0, 0, cw, ch);
    var img = camCtx.getImageData(0,0,cw,ch).data;

    var minV = 1e9, maxV = -1e9, p = 0;
    for (var j=0;j<ch;j++){
      for (var i=0;i<cw;i++){
        var idx = (j*cw + i) * 4;
        var r = img[idx], g = img[idx+1], b = img[idx+2];
        var y = (0.2126*r + 0.7152*g + 0.0722*b) / 255;
        camLuma[p++] = y;
        if (y < minV) minV = y;
        if (y > maxV) maxV = y;
      }
    }
    var span = maxV - minV;
    if (span > 1e-6){
      for (var n=0;n<camLuma.length;n++) camNorm[n] = (camLuma[n] - minV) / span;
    } else {
      for (var m=0;m<camLuma.length;m++) camNorm[m] = 0.5;
    }
  }

  /* ---------- Simulation ---------- */
  var lastT = performance.now()/1000;

  function step(){
    var now = performance.now()/1000;
    var dt = now - lastT; if (dt > 0.033) dt = 0.033; lastT = now;

    if (needsLayout){
      buildTriGrid();
      ensureBuffers();
      needsLayout = false;
    }

    // camera every 3rd frame + smoothing into per-dot camScale
    var camSens = Number(ui.camSens.value)/100;
    if (camOK && camSens > 0 && (frameCount % 3 === 0)) sampleCameraToGrid();
    frameCount++;
    if (camSens > 0 && camNorm.length === gridCols*gridRows){
      for (var i=0;i<dots.length;i++){
        var d = dots[i];
        var ci = Math.max(0, Math.min(gridCols-1, Math.round(d.ci)));
        var rj = Math.max(0, Math.min(gridRows-1, Math.round(d.rj)));
        var lum = camNorm[rj*gridCols + ci]; if (lum === undefined) lum = 0.5;
        var target = 1 + camSens * (lum*2 - 1); if (target<0) target=0; if (target>2) target=2;
        d.camTarget = target;
        d.camScale += (d.camTarget - d.camScale) * CAM_SMOOTH;
      }
    } else {
      for (var j=0;j<dots.length;j++){ var dj = dots[j]; dj.camScale += (1 - dj.camScale) * CAM_SMOOTH; }
    }

    // prune ripples
    ripples = ripples.filter(function(r){ return now - r.t < r.life; });

    var pc = params(), k = pc.k, c = pc.c;
    var s = S();

    // ***** Motion gain: 5× stronger *****
    var motionSensBase = Number(ui.motionSens.value)/100;
    var motionGain = motionSensBase * 5;  // boost

    // previous physics (kept), scaled by boosted gain
    var x_target = (Number(ui.soundSens.value)/100) * Math.min(1.5, Math.sqrt(Math.max(0, rms - noise) * 22)) * 0.40 * s;
    var tiltMag  = motionGain * (0.08 * s);
    var shakeMag = motionGain * (0.60 * s) * Math.min(1.0, Math.hypot(acc.x, acc.y) / 5);

    var sub = 2, h = dt / sub;

    for (var ss=0; ss<sub; ss++){
      for (var q=0;q<dots.length;q++){
        var d2 = dots[q];

        var fx = -k * (d2.x - d2.rx) - c * d2.vx;
        var fy = -k * (d2.y - d2.ry) - c * d2.vy;

        for (var r=0;r<ripples.length;r++){
          var rp = ripples[r];
          var age = now - rp.t + ss*h;
          var rr = Math.hypot(d2.x - rp.x, d2.y - rp.y) + 1e-6;
          var travel = (age * (2.4 * s));
          var sigma  = (rp.sigma != null ? rp.sigma : (0.42 * s));
          var g = Math.exp(-((rr - travel)*(rr - travel)) / (2 * sigma * sigma)) * rp.amp;
          var ux = (d2.x - rp.x)/rr, uy=(d2.y - rp.y)/rr;
          fx += ux * g * 2.2 * s;
          fy += uy * g * 2.2 * s;
        }

        if (x_target > 0){
          var sx = Math.sin((d2.rx + d2.ry + now*900)*0.004);
          var sy = Math.cos((d2.rx - d2.ry - now*900)*0.004);
          fx += sx * (k * x_target);
          fy += sy * (k * x_target);
        }

        if (motionGain > 0){
          fx += tilt.x * tiltMag;
          fy += tilt.y * tiltMag;
          fx += (Math.sin(now*40 + d2.rx*0.002) * shakeMag);
          fy += (Math.cos(now*40 - d2.ry*0.002) * shakeMag);
        }

        d2.vx += fx * h; d2.vy += fy * h; d2.x += d2.vx * h; d2.y += d2.vy * h;
      }
    }

    // cache motion vector for render channel spread
    // combine tilt (slow) + linear acceleration (fast)
    var ACCEL_GAIN = 0.6; // weight of acceleration vs tilt
    motionVec.x = tilt.x + acc.x * ACCEL_GAIN;
    motionVec.y = tilt.y + acc.y * ACCEL_GAIN;
    motionVecGain = motionGain;
  }

  /* ---------- Motion vector → RGB spread ---------- */
  var motionVec = {x:0,y:0}, motionVecGain = 0;

  /* ---------- Render ---------- */
  function render(){
    ctx.globalCompositeOperation = 'source-over';
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cvs.width,cvs.height);

    ctx.globalCompositeOperation = 'lighter';
    var rNom = R();
    var s = S();

    // unit direction from motion vector
    var mvx = motionVec.x, mvy = motionVec.y;
    var mmag = Math.hypot(mvx, mvy);
    var ux = 0, uy = 0;
    if (mmag > 1e-6){ ux = mvx / mmag; uy = mvy / mmag; }

    // map vector magnitude -> separation length (in grid units), scaled 5×
    // cap magnitude to keep within visual bounds
    var sepMotion = motionVecGain * 0.50 * s * Math.min(1.0, mmag / 6); // up to ~0.5s at strong motion

    for (var i=0;i<dots.length;i++){
      var d = dots[i];
      var dx = d.x - d.rx, dy = d.y - d.ry;
      var disp = Math.hypot(dx,dy);
      var baseAngle = disp < 1e-6 ? 0 : Math.atan2(dy, dx);
      var sep = Math.min(disp * 0.70, 0.8 * s);

      // camera-scaled radius
      var r = rNom * d.camScale;

      // per-channel offsets:
      // 1) original “string angle” displacement-based chroma (sep & baseAngle)
      // 2) PLUS motion-vector spread along (ux,uy): blue=0, green=0.5, red=1
      var channels = [
        { ang: baseAngle + 0,               col:'rgb(255,0,0)', mult:1.00, mvw:1.00 }, // Red max
        { ang: baseAngle + 2*Math.PI/3,    col:'rgb(0,255,0)', mult:0.94, mvw:0.50 }, // Green mid
        { ang: baseAngle - 2*Math.PI/3,    col:'rgb(0,0,255)', mult:1.06, mvw:0.00 }  // Blue fixed
      ];

      for (var k=0;k<3;k++){
        var a = channels[k];
        var offx = Math.cos(a.ang) * sep * a.mult;
        var offy = Math.sin(a.ang) * sep * a.mult;

        // motion spread
        var mx = ux * sepMotion * a.mvw;
        var my = uy * sepMotion * a.mvw;

        ctx.fillStyle = a.col;
        ctx.beginPath(); ctx.arc(d.x + offx + mx, d.y + offy + my, r, 0, Math.PI*2); ctx.fill();
      }

      if (disp < 0.35 * dpr){
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(d.rx, d.ry, r, 0, Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = 'lighter';
      }
    }
  }

  /* ---------- Loop ---------- */
  function loop(){ step(); render(); requestAnimationFrame(loop); }
  loop();
})();
</script>
</body>
</html>