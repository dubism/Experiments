<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>RGB String-Dots — touch / sound / motion</title>
<style>
  :root{
    --bg:#000; --ink:#fff; --muted:#a6b0bf;
    --panel:rgba(16,18,24,.78); --line:rgba(255,255,255,.12);
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);overflow:hidden;
    font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  canvas{display:block;width:100vw;height:100vh;touch-action:none; }

  /* Minimal controls */
  .hud{
    position:fixed; left:10px; bottom:10px; z-index:3;
    background:var(--panel); border:1px solid var(--line); border-radius:12px;
    padding:10px 12px; backdrop-filter:blur(8px); -webkit-backdrop-filter:blur(8px);
  }
  .row{display:grid; grid-template-columns:auto 1fr; gap:8px 10px; align-items:center}
  label{color:#d6deea; font-size:12px; white-space:nowrap}
  input[type=range]{width:160px}
  .pill{position:fixed; right:10px; bottom:10px; z-index:3;
    background:rgba(255,255,255,.08); border:1px solid var(--line); border-radius:999px;
    padding:7px 10px; color:#cfd7e3; font-size:12px; }

  /* Permission overlay (one tap on iOS) */
  #overlay{position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
    background:linear-gradient(180deg, rgba(0,0,0,.9), rgba(0,0,0,.65)); z-index:5; transition:opacity .25s}
  #overlay.hide{opacity:0; pointer-events:none}
  .panel{background:var(--panel); border:1px solid var(--line); border-radius:14px; padding:16px 18px; text-align:center}
  button{appearance:none; border:0; border-radius:999px; padding:10px 14px; font-weight:650; cursor:pointer;
    background:#e6f0ff; color:#0b1220}
  .chips{display:flex; gap:8px; justify-content:center; margin-top:8px}
  .chip{display:inline-flex; align-items:center; gap:6px; padding:6px 10px; border-radius:999px;
    border:1px solid var(--line); background:rgba(255,255,255,.06); font-size:12px; color:#cfd7e3}
  .dot{width:8px;height:8px;border-radius:50%;background:#999}
  .ok .dot{background:#39d98a} .err .dot{background:#ff6b6b}
</style>
</head>
<body>
  <canvas id="cv"></canvas>

  <div class="hud" id="hud">
    <div class="row">
      <label for="stiff">String looseness</label>
      <input id="stiff" type="range" min="0" max="100" value="45" />
      <label for="damp">Bounce</label>
      <input id="damp" type="range" min="0" max="100" value="35" />
    </div>
  </div>
  <div class="pill" id="pill">Mic – • Motion –</div>

  <div id="overlay">
    <div class="panel">
      <div style="font-weight:650;margin-bottom:6px">Enable sensors</div>
      <div style="color:#c9d2df;margin-bottom:10px">Tap once to allow microphone & motion (iOS requires this).</div>
      <button id="enable">Enable mic + motion</button>
      <div class="chips">
        <div id="stMic" class="chip"><span class="dot"></span><span>Mic</span></div>
        <div id="stMot" class="chip"><span class="dot"></span><span>Motion</span></div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Canvas & sizing ----------
  const cvs = document.getElementById('cv');
  const ctx = cvs.getContext('2d', { alpha:false });
  let dpr = Math.max(1, devicePixelRatio || 1);
  let needsLayout = false;

  function resize(){
    const r = cvs.getBoundingClientRect();
    cvs.width  = Math.floor(r.width  * dpr);
    cvs.height = Math.floor(r.height * dpr);
    needsLayout = true;
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // ---------- Triangular grid (hex packing) ----------
  const dots = [];  // {rx,ry,x,y,vx,vy}
  let spacing = 28; // CSS px between horizontal neighbors
  let radius  = 2.6; // CSS px dot radius
  function S(){ return spacing * dpr; }
  function R(){ return radius  * dpr; }

  function buildTriGrid(){
    dots.length = 0;
    const W = cvs.width, H = cvs.height, s = S();
    const rowH = s * Math.sqrt(3)/2;  // vertical distance between rows
    const offX = (W % s) / 2;
    const offY = (H % rowH) / 2;

    // Fill rows; odd rows are horizontally shifted by s/2
    for (let j = 0, y = offY; y <= H - offY + 1; j++, y += rowH){
      const xShift = (j % 2) ? s/2 : 0;
      for (let x = offX + xShift; x <= W - offX + 1; x += s){
        dots.push({ rx:x, ry:y, x, y, vx:0, vy:0 });
      }
    }
  }
  buildTriGrid();

  // ---------- Physics ("strings"): spring + damping ----------
  // We expose two user sliders: looseness (inverse stiffness) and bounce (damping).
  const uiStiff = document.getElementById('stiff');
  const uiDamp  = document.getElementById('damp');

  function params(){
    // Map looseness slider (0..100) → stiffness k (N): lower k = looser.
    // Choose stable range for dt ~ 16ms: k in [2, 40] scaled by dpi/spacing.
    const loose = Number(uiStiff.value); // 0..100 (looser to tighter visually)
    const k = 2 + (100 - loose) * 0.38;   // 2..40
    // Bounce slider → damping ratio-ish c. 0..1.4
    const b = Number(uiDamp.value);
    const c = 0.02 + b * 0.013;          // ~0.02..1.32
    return { k, c };
  }

  // ---------- Inputs → external disturbances ----------
  let ripples = []; // {x,y,t,amp}
  function addRipple(cssX, cssY, amp = 1){
    const rect = cvs.getBoundingClientRect();
    ripples.push({
      x: (cssX - rect.left) * dpr,
      y: (cssY - rect.top)  * dpr,
      t: performance.now()/1000,
      amp
    });
  }
  // Touch / pointer
  let dragging = false;
  cvs.addEventListener('pointerdown', e => { dragging = true; addRipple(e.clientX,e.clientY, 1.0); });
  cvs.addEventListener('pointermove', e => { if (dragging) addRipple(e.clientX,e.clientY, 0.5); });
  ['pointerup','pointercancel','pointerleave'].forEach(ev => cvs.addEventListener(ev, ()=> dragging=false));
  cvs.style.touchAction = 'none';

  // Mic
  let audioLevel = 0, micOK = false;
  async function enableMic(){
    try{
      const AC = window.AudioContext || window.webkitAudioContext;
      const ac = new AC();
      await ac.resume();
      const stream = await navigator.mediaDevices.getUserMedia({audio:true});
      const src = ac.createMediaStreamSource(stream);
      const ana = ac.createAnalyser();
      ana.fftSize = 1024;
      src.connect(ana);
      const buf = new Uint8Array(ana.fftSize);
      micOK = true;
      function tick(){
        ana.getByteTimeDomainData(buf);
        let sum=0;
        for(let i=0;i<buf.length;i++){ const v=(buf[i]-128)/128; sum+=v*v; }
        const rms=Math.sqrt(sum/buf.length);
        audioLevel = audioLevel*0.86 + rms*0.14; // smooth
        requestAnimationFrame(tick);
      }
      tick();
    }catch(e){ micOK = false; }
  }

  // Motion
  let tilt = {x:0,y:0}, motOK=false;
  async function enableMotion(){
    try{
      if (typeof DeviceMotionEvent!=='undefined' && typeof DeviceMotionEvent.requestPermission==='function'){
        const res = await DeviceMotionEvent.requestPermission();
        if (res!=='granted') throw new Error('denied');
      }
      addEventListener('devicemotion', e=>{
        const g = e.accelerationIncludingGravity || {};
        tilt.x = g.x || 0;
        tilt.y = -(g.y || 0);
        motOK = true;
      }, {passive:true});
      setTimeout(()=>{ if(!motOK){ /* probably denied */ } }, 800);
    }catch(e){ motOK=false; }
  }

  // Overlay buttons
  const overlay = document.getElementById('overlay');
  const stMicEl = document.getElementById('stMic');
  const stMotEl = document.getElementById('stMot');
  function mark(el, cls){ el.classList.remove('ok','err'); if (cls) el.classList.add(cls); }

  document.getElementById('enable').addEventListener('click', async ()=>{
    mark(stMicEl,''); mark(stMotEl,'');
    await Promise.allSettled([enableMic(), enableMotion()]);
    mark(stMicEl, micOK ? 'ok' : 'err');
    // motion flag set upon first event; give it a moment:
    setTimeout(()=> mark(stMotEl, motOK ? 'ok' : 'err'), 500);
    overlay.classList.add('hide');
  });

  // Status pill
  const pill = document.getElementById('pill');
  function setPill(){ pill.textContent = `Mic ${micOK?'✓':'–'} • Motion ${motOK?'✓':'–'}`; }

  // ---------- Simulation step ----------
  let lastT = performance.now()/1000;

  function step(){
    const now = performance.now()/1000;
    let dt = now - lastT;
    lastT = now;
    if (dt > 0.05) dt = 0.05;

    // (Re)layout if needed
    if (needsLayout){ buildTriGrid(); needsLayout=false; }

    // External fields
    const s = S();
    const rippleDecay = 1.8; // seconds
    ripples = ripples.filter(r => now - r.t < rippleDecay);

    const {k, c} = params();

    // Integrate each dot (mass = 1)
    // Force = -k*(x - rx) - c*vx + Fext
    // Fext from ripples (radial), audio (swirl), and tilt (constant).
    const audioMag = audioLevel * 0.28 * s; // scale
    const tiltMag  = 0.10 * s;

    for (let i=0;i<dots.length;i++){
      const d = dots[i];

      // Spring force to rest
      let fx = -k * (d.x - d.rx) - c * d.vx;
      let fy = -k * (d.y - d.ry) - c * d.vy;

      // Ripples
      for (let j=0;j<ripples.length;j++){
        const r = ripples[j];
        const age = now - r.t;
        const rr = Math.hypot(d.x - r.x, d.y - r.y) + 1e-6;
        // traveling wavefront envelope
        const travel = (age * (1.5 * s)); // wavefront radius
        const g = Math.exp(-((rr - travel)*(rr - travel)) / (2 * (0.9*s)*(0.9*s)));
        const amp = r.amp * g;
        const ux = (d.x - r.x)/rr, uy=(d.y - r.y)/rr;
        fx += ux * amp * 1.6 * s;
        fy += uy * amp * 1.6 * s;
      }

      // Audio swirl (perpendicular components)
      fx += Math.sin((d.rx + d.ry + now*420)*0.003) * audioMag;
      fy += Math.cos((d.rx - d.ry - now*420)*0.003) * audioMag;

      // Tilt (gravity-like)
      fx += tilt.x * tiltMag;
      fy += tilt.y * tiltMag;

      // Integrate (semi-implicit Euler)
      d.vx += fx * dt;
      d.vy += fy * dt;
      d.x  += d.vx * dt;
      d.y  += d.vy * dt;
    }
  }

  // ---------- Render ----------
  function render(){
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = '#000';
    ctx.fillRect(0,0,cvs.width,cvs.height);

    // For each dot, draw three additive layers (R,G,B) with slight per-channel
    // offset based on displacement vector angle, each rotated by ±120°.
    ctx.globalCompositeOperation = 'lighter';
    const r = R();

    for (let i=0;i<dots.length;i++){
      const d = dots[i];
      // Displacement vector from rest
      const dx = d.x - d.rx, dy = d.y - d.ry;
      const disp = Math.hypot(dx,dy);
      const baseAngle = Math.atan2(dy, dx);

      // Chromatic separation proportional to displacement, clamped
      const sep = Math.min(disp * 0.65, 0.9 * S()); // channel distance

      // Channel angles: base ±120°, base
      const A = [
        { ang: baseAngle + 0,                col:'rgb(255,0,0)', scale: 1.00 },
        { ang: baseAngle + 2*Math.PI/3,     col:'rgb(0,255,0)', scale: 0.92 },
        { ang: baseAngle - 2*Math.PI/3,     col:'rgb(0,0,255)', scale: 1.08 }
      ];

      for (let k=0;k<3;k++){
        const a = A[k];
        const offx = Math.cos(a.ang) * sep * a.scale;
        const offy = Math.sin(a.ang) * sep * a.scale;
        ctx.fillStyle = a.col;
        ctx.beginPath();
        ctx.arc(d.x + offx, d.y + offy, r, 0, Math.PI*2);
        ctx.fill();
      }

      // When very still, ensure crisp white dot
      if (disp < 0.35 * dpr){
        ctx.globalCompositeOperation = 'source-over';
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(d.rx, d.ry, r, 0, Math.PI*2);
        ctx.fill();
        ctx.globalCompositeOperation = 'lighter';
      }
    }
  }

  // ---------- Main loop ----------
  function loop(){
    step();
    render();
    setPill();
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>