<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Concave Mirror • Live Front Camera + Device Motion (robust)</title>
<style>
  :root{--ui-bg:#0b0c10;--ui-fg:#e6e6e6;--gap:10px}
  html,body{margin:0;height:100%;background:#000;color:var(--ui-fg);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{position:fixed;inset:0;display:grid;grid-template-rows:1fr auto}
  canvas{width:100vw;height:100dvh;display:block;touch-action:none}
  .panel{background:color-mix(in oklab,#000 70%,var(--ui-bg) 30%);backdrop-filter:blur(8px);border-top:1px solid #222;padding:8px 12px calc(env(safe-area-inset-bottom)+10px);display:grid;gap:var(--gap)}
  .grid{display:grid;grid-template-columns:repeat(12,1fr);gap:8px;align-items:center}
  .grid label{grid-column:span 3;white-space:nowrap}
  .grid input[type="range"]{grid-column:span 7;width:100%}
  .grid output{grid-column:span 2;text-align:right;font-variant-numeric:tabular-nums}
  .row{display:contents}
  .section{grid-column:1 / -1;margin-top:2px;color:#9fb7ff;font-weight:600}
  .btns{display:flex;gap:8px;justify-content:space-between;align-items:center}
  button{all:unset;background:#1f2533;color:#fff;padding:6px 10px;border-radius:6px;cursor:pointer;border:1px solid #2b3244}
  button:active{transform:translateY(1px)}
  .small{color:#8fb3ff;text-decoration:none;font-size:12px;margin-left:8px}
  .hud{position:fixed;left:8px;top:env(safe-area-inset-top,8px);padding:6px 8px;background:rgba(0,0,0,.5);border:1px solid #222;border-radius:6px;font-size:12px;color:#ddd;pointer-events:none;user-select:none}
  .inline{display:flex;gap:10px;align-items:center}
  .inline input[type="checkbox"]{transform:translateY(1px)}
  .banner{position:fixed;left:0;right:0;top:0;z-index:10;display:none;padding:10px 14px;background:#5c0b0b;color:#ffe9e9;border-bottom:1px solid #7a1a1a;font-size:13px}
  .banner.show{display:block}
  .k{color:#9fd0ff}
</style>
</head>
<body>
<div class="banner" id="banner"></div>
<div class="wrap">
  <canvas id="gl"></canvas>

  <div class="panel">
    <div class="btns">
      <div class="inline">
        <strong>Concave Mirror • Live Camera Reflection</strong>
        <label class="inline" title="Use motion sensors to drive camera"><input id="useSensors" type="checkbox" checked>Use sensors</label>
        <label class="inline" title="Mirror incoming video (typical front cam)"><input id="mirrorVideo" type="checkbox" checked>Mirror video</label>
        <label class="inline" title="Planar for normal camera; Equirect for 360 feeds">
          Mode:
          <select id="envMode">
            <option value="0" selected>Planar</option>
            <option value="1">Equirectangular</option>
          </select>
        </label>
      </div>
      <div>
        <button id="enable">Enable camera & sensors</button>
        <button id="reset">Reset</button>
        <a class="small" href="#" id="save">Save frame</a>
      </div>
    </div>

    <div class="grid" id="controls">
      <div class="section">Simulate motion (fallback / additive)</div>
      <div class="row"><label for="camYaw">Yaw (°)</label><input id="camYaw" type="range" min="-180" max="180" step="0.1" value="0"><output>0.0</output></div>
      <div class="row"><label for="camPitch">Pitch (°)</label><input id="camPitch" type="range" min="-89" max="89" step="0.1" value="0"><output>0.0</output></div>
      <div class="row"><label for="camRoll">Roll (°)</label><input id="camRoll" type="range" min="-180" max="180" step="0.1" value="0"><output>0.0</output></div>
      <div class="row"><label for="fov">FOV (°)</label><input id="fov" type="range" min="20" max="100" step="0.1" value="60"><output>60.0</output></div>

      <div class="section">Mirror geometry</div>
      <div class="row"><label for="radius">Radius</label><input id="radius" type="range" min="0.2" max="2.0" step="0.01" value="0.8"><output>0.80</output></div>
      <div class="row"><label for="sphereZ">Z pos</label><input id="sphereZ" type="range" min="-2.0" max="2.0" step="0.01" value="0.0"><output>0.00</output></div>
      <div class="row"><label for="aperture">Aperture (°)</label><input id="aperture" type="range" min="10" max="180" step="0.5" value="120"><output>120.0</output></div>
      <div class="row"><label for="reflect">Reflectivity</label><input id="reflect" type="range" min="0.0" max="1.0" step="0.01" value="1.0"><output>1.00</output></div>

      <div class="section">Environment mapping (UV)</div>
      <div class="row"><label for="envYaw">Env Yaw (°)</label><input id="envYaw" type="range" min="-180" max="180" step="0.1" value="0"><output>0.0</output></div>
      <div class="row"><label for="envPitch">Env Pitch (°)</label><input id="envPitch" type="range" min="-90" max="90" step="0.1" value="0"><output>0.0</output></div>
      <div class="row"><label for="uScale">U scale</label><input id="uScale" type="range" min="0.25" max="4.0" step="0.01" value="1.0"><output>1.00</output></div>
      <div class="row"><label for="vScale">V scale</label><input id="vScale" type="range" min="0.25" max="4.0" step="0.01" value="1.0"><output>1.00</output></div>
      <div class="row"><label for="uOff">U offset</label><input id="uOff" type="range" min="-1.0" max="1.0" step="0.001" value="0.0"><output>0.000</output></div>
      <div class="row"><label for="vOff">V offset</label><input id="vOff" type="range" min="-1.0" max="1.0" step="0.001" value="0.0"><output>0.000</output></div>

      <div class="section">Planar mode tuning (camera-as-billboard)</div>
      <div class="row"><label for="planeDist">Plane dist</label><input id="planeDist" type="range" min="0.3" max="5.0" step="0.01" value="1.2"><output>1.20</output></div>
      <div class="row"><label for="planeScale">Plane scale</label><input id="planeScale" type="range" min="0.2" max="3.0" step="0.01" value="1.0"><output>1.00</output></div>
    </div>
  </div>

  <div class="hud" id="hud">⏱︎ 0.0 ms • FPS 0 • Sensors: off • Camera: off</div>
</div>

<script>
(() => {
  'use strict';

  // ===== Utilities =====
  const clamp = (x,a,b)=>Math.min(Math.max(x,a),b);
  const deg2rad = d=>d*Math.PI/180, rad2deg = r=>r*180/Math.PI;
  const smooth = (k, prev, next)=>prev + k*(next - prev);

  // ===== WebGL2 setup =====
  const canvas = document.getElementById('gl');
  let gl = canvas.getContext('webgl2', {antialias:true,alpha:false,desynchronized:true});
  if(!gl){ alert('WebGL2 required'); return; }
  canvas.addEventListener('webglcontextlost', (e)=>{ e.preventDefault(); showBanner('WebGL context lost — reloading…'); setTimeout(()=>location.reload(), 200); });

  const banner = document.getElementById('banner');
  function showBanner(msg){ banner.textContent = msg; banner.classList.add('show'); }
  function clearBanner(){ banner.classList.remove('show'); banner.textContent=''; }

  const quadVS = `#version 300 es
  precision highp float;
  const vec2 verts[4]=vec2[4](vec2(-1,-1),vec2(1,-1),vec2(-1,1),vec2(1,1));
  out vec2 vUV;
  void main(){ gl_Position=vec4(verts[gl_VertexID],0.0,1.0); vUV=verts[gl_VertexID]*0.5+0.5; }`;

  const quadFS = `#version 300 es
  precision highp float;
  in vec2 vUV;
  out vec4 frag;

  uniform vec3  u_camPos;
  uniform mat3  u_camR;
  uniform float u_fovTan;
  uniform vec2  u_resolution;

  uniform vec3  u_sphereC;
  uniform float u_sphereR;
  uniform float u_apertureCos;
  uniform float u_reflect;

  uniform sampler2D u_env;     // video frame or placeholder
  uniform vec2  u_uvScale;
  uniform vec2  u_uvOffset;
  uniform mat3  u_envR;
  uniform int   u_envMode;     // 0=planar billboard, 1=equirect
  uniform float u_planeDist;   // distance to env plane (planar)
  uniform float u_planeScale;  // scale of env plane
  uniform int   u_mirrorU;     // mirror horizontally?

  vec2 dirToEquirect(vec3 d){
    d = normalize(d);
    float u = atan(d.z, d.x) / (2.0*3.141592653589793) + 0.5;
    float v = asin(clamp(d.y,-1.0,1.0)) / 3.141592653589793 + 0.5;
    return vec2(u,v);
  }
  vec3 rot(mat3 R, vec3 v){ return R*v; }

  vec3 sampleEnv(vec3 dir){
    dir = rot(u_envR, dir); // rotate env
    vec2 uv;
    if(u_envMode==1){
      uv = dirToEquirect(dir);
    }else{
      float t = (-u_planeDist - 0.0) / max(dir.z, -1e-4);
      vec3 hit = vec3(0.0) + dir * t;
      uv = hit.xy * (0.5/u_planeScale) + 0.5;
    }
    if(u_mirrorU==1){ uv.x = 1.0 - uv.x; }
    uv = uv * u_uvScale + u_uvOffset;
    uv = fract(uv);
    return texture(u_env, uv).rgb;
  }

  void main(){
    vec2 ndc = vUV*2.0-1.0;
    float aspect = u_resolution.x/u_resolution.y;
    vec3 rd_cam = normalize(vec3(ndc.x*aspect*u_fovTan, -ndc.y*u_fovTan, -1.0));
    vec3 rd = normalize(u_camR * rd_cam);
    vec3 ro = u_camPos;

    // Ray-sphere
    vec3 oc = ro - u_sphereC;
    float b = dot(oc, rd);
    float c = dot(oc, oc) - u_sphereR*u_sphereR;
    float h = b*b - c;
    if(h < 0.0){ frag = vec4(sampleEnv(rd),1.0); return; }
    h = sqrt(h);
    float t = -b - h;
    if(t < 0.0) t = -b + h;
    if(t < 0.0){ frag = vec4(sampleEnv(rd),1.0); return; }
    vec3 p = ro + rd*t;

    vec3 n_out = normalize(p - u_sphereC);
    vec3 n_in  = -n_out;
    vec3 vdir = normalize(ro - p);
    float cosA = dot(n_in, vdir);
    if(cosA < u_apertureCos){ frag = vec4(sampleEnv(rd),1.0); return; }

    vec3 I = -rd;
    vec3 r = reflect(I, n_in);
    vec3 col = mix(sampleEnv(rd), sampleEnv(r), clamp(u_reflect,0.0,1.0));
    frag = vec4(col,1.0);
  }`;

  function makeProgram(vs,fs){
    const s = (type,src)=>{ const sh=gl.createShader(type); gl.shaderSource(sh,src); gl.compileShader(sh);
      if(!gl.getShaderParameter(sh,gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(sh)); return sh; };
    const prog = gl.createProgram();
    gl.attachShader(prog, s(gl.VERTEX_SHADER,vs));
    gl.attachShader(prog, s(gl.FRAGMENT_SHADER,fs));
    gl.linkProgram(prog);
    if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
    return prog;
  }

  const prog = makeProgram(quadVS, quadFS);
  gl.useProgram(prog);
  const loc = Object.fromEntries([
    'u_camPos','u_camR','u_fovTan','u_resolution',
    'u_sphereC','u_sphereR','u_apertureCos','u_reflect',
    'u_env','u_uvScale','u_uvOffset','u_envR','u_envMode','u_planeDist','u_planeScale','u_mirrorU'
  ].map(n=>[n,gl.getUniformLocation(prog,n)]));
  const vao = gl.createVertexArray(); gl.bindVertexArray(vao);

  // ===== Placeholder/env texture =====
  const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);
  // 2x2 checker so there's never a pure black screen
  const ph = new Uint8Array([
    80,80,80,  140,140,140,
    140,140,140, 80,80,80
  ]);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGB,2,2,0,gl.RGB,gl.UNSIGNED_BYTE,ph);

  // ===== Video setup =====
  const video = document.createElement('video');
  video.playsInline = true; video.muted = true; video.autoplay = true; // autoplay still needs user gesture on iOS
  let camActive = false;
  async function startCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video: {
          facingMode: { ideal: 'user' },
          width: { ideal: 1280 },
          height: { ideal: 720 }
        },
        audio: false
      });
      video.srcObject = stream;
      await video.play(); // important, else no frames
      camActive = true;
      clearBanner();
    }catch(err){
      camActive = false;
      showBanner('Camera error: ' + String(err && err.message || err));
    }
  }
  function uploadVideoFrame(){
    if(!camActive) return;
    if(video.readyState >= 2){
      gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 0);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGB,gl.RGB,gl.UNSIGNED_BYTE,video);
    }
  }

  // ===== Controls / State =====
  const state = {
    useSensors: true, mirrorVideo: true, envMode: 0,
    camYaw: 0, camPitch: 0, camRoll: 0, fov: 60,
    radius: 0.8, sphereZ: 0.0, aperture: 120, reflect: 1.0,
    envYaw: 0, envPitch: 0, uScale: 1.0, vScale: 1.0, uOff: 0.0, vOff: 0.0,
    planeDist: 1.2, planeScale: 1.0
  };
  const ids = ['camYaw','camPitch','camRoll','fov','radius','sphereZ','aperture','reflect','envYaw','envPitch','uScale','vScale','uOff','vOff','planeDist','planeScale'];
  const hud = document.getElementById('hud');

  function fmt(el,val){
    if(el.step && parseFloat(el.step) < 0.01) return Number(val).toFixed(3);
    if(el.step && parseFloat(el.step) < 0.1) return Number(val).toFixed(2);
    return Number(val).toFixed(1);
  }
  function wireControls(){
    ids.forEach(id=>{
      const el = document.getElementById(id), out = el.nextElementSibling;
      const update=()=>{ state[id] = Number(el.value); out.textContent = fmt(el, el.value); };
      el.addEventListener('input', update, {passive:true}); update();
    });
    document.getElementById('reset').addEventListener('click', ()=>{
      Object.assign(state,{camYaw:0,camPitch:0,camRoll:0,fov:60,radius:0.8,sphereZ:0.0,aperture:120,reflect:1.0,envYaw:0,envPitch:0,uScale:1,vScale:1,uOff:0,vOff:0,planeDist:1.2,planeScale:1.0});
      ids.forEach(id=>{ const el=document.getElementById(id); el.value=state[id]; el.dispatchEvent(new Event('input')); });
    });
    document.getElementById('save').addEventListener('click', (e)=>{ e.preventDefault(); const a=document.createElement('a'); a.href=canvas.toDataURL('image/png'); a.download='mirror_frame.png'; a.click(); });
    const useSensorsEl = document.getElementById('useSensors');
    const mirrorEl = document.getElementById('mirrorVideo');
    const modeEl = document.getElementById('envMode');
    useSensorsEl.addEventListener('change', ()=> state.useSensors = useSensorsEl.checked);
    mirrorEl.addEventListener('change', ()=> state.mirrorVideo = mirrorEl.checked);
    modeEl.addEventListener('change', ()=> state.envMode = parseInt(modeEl.value,10));
  }

  // ===== Resize / DPR =====
  function resize(){
    const dpr = clamp(window.devicePixelRatio||1,1,3);
    const w = Math.max(1, Math.floor(canvas.clientWidth*dpr));
    const h = Math.max(1, Math.floor(canvas.clientHeight*dpr));
    if(canvas.width!==w || canvas.height!==h){ canvas.width=w; canvas.height=h; gl.viewport(0,0,w,h); }
  }
  window.addEventListener('resize', resize);

  // ===== Sensors (DeviceOrientation) =====
  let sensorsActive = false;
  let filt = {yaw:0,pitch:0,roll:0};
  let emaK = 0.15;

  function screenAngleDeg(){
    const o = (screen.orientation && screen.orientation.angle) || window.orientation || 0;
    return (typeof o === 'number') ? o : 0;
  }

  function makeBasis(yawDeg, pitchDeg, rollDeg){
    const cy=Math.cos(deg2rad(yawDeg)), sy=Math.sin(deg2rad(yawDeg));
    const cp=Math.cos(deg2rad(pitchDeg)), sp=Math.sin(deg2rad(pitchDeg));
    const cr=Math.cos(deg2rad(rollDeg)), sr=Math.sin(deg2rad(rollDeg));
    const Rz=[cr,-sr,0, sr,cr,0, 0,0,1];
    const Rx=[1,0,0, 0,cp,-sp, 0,sp,cp];
    const Ry=[cy,0,sy, 0,1,0, -sy,0,cy];
    const m=(A,B)=>[
      A[0]*B[0]+A[1]*B[3]+A[2]*B[6], A[0]*B[1]+A[1]*B[4]+A[2]*B[7], A[0]*B[2]+A[1]*B[5]+A[2]*B[8],
      A[3]*B[0]+A[4]*B[3]+A[5]*B[6], A[3]*B[1]+A[4]*B[4]+A[5]*B[7],
      A[6]*B[0]+A[7]*B[3]+A[8]*B[6], A[6]*B[1]+A[7]*B[4]+A[8]*B[7], A[6]*B[2]+A[7]*B[5]+A[8]*B[8],
    ];
    return new Float32Array(m(m(Ry,Rx),Rz));
  }
  function makeEnvRotation(yawDeg,pitchDeg){
    const cy=Math.cos(deg2rad(yawDeg)), sy=Math.sin(deg2rad(yawDeg));
    const cp=Math.cos(deg2rad(pitchDeg)), sp=Math.sin(deg2rad(pitchDeg));
    const Ry=[cy,0,sy, 0,1,0, -sy,0,cy];
    const Rx=[1,0,0, 0,cp,-sp, 0,sp,cp];
    const m=(A,B)=>[
      A[0]*B[0]+A[1]*B[3]+A[2]*B[6], A[0]*B[1]+A[1]*B[4]+A[2]*B[7], A[0]*B[2]+A[1]*B[5]+A[2]*B[8],
      A[3]*B[0]+A[4]*B[3]+A[5]*B[6], A[3]*B[1]+A[4]*B[4]+A[5]*B[7],
      A[6]*B[0]+A[7]*B[3]+A[8]*B[6], A[6]*B[1]+A[7]*B[4]+A[8]*B[7], A[6]*B[2]+A[7]*B[5]+A[8]*B[8],
    ];
    return new Float32Array(m(Ry,Rx));
  }

  // Convert DeviceOrientation alpha/beta/gamma to yaw/pitch/roll approx; adjust for screen rotation.
  function eulerFromDevice(alpha, beta, gamma){
    // Simple/pragmatic mapping that feels correct for reflection control:
    // yaw ~ alpha (compass heading), pitch ~ beta, roll ~ gamma, then rotate by screen orientation.
    const a = (alpha||0), b=(beta||0), g=(gamma||0);
    const s = screenAngleDeg();
    let yaw=a, pitch=b, roll=g;
    if (s===90 || s===-270){ yaw = a+90; const tmp=pitch; pitch = -roll; roll = tmp; }
    else if (s===180 || s===-180){ yaw=a+180; pitch=-b; roll=-g; }
    else if (s===270 || s===-90){ yaw = a-90; const tmp=pitch; pitch = roll; roll = -tmp; }
    return { yaw, pitch, roll };
  }

  async function requestMotionPermission(){
    try{
      // iOS 13+ requires permission via *user gesture*
      const needsIOS = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
                    || (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function');
      if(needsIOS){
        const r1 = (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function')
          ? await DeviceMotionEvent.requestPermission() : 'granted';
        const r2 = (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function')
          ? await DeviceOrientationEvent.requestPermission() : 'granted';
        if(r1!=='granted' || r2!=='granted') throw new Error('Motion permission denied');
      }
      // Hook one listener to keep latest values
      window.addEventListener('deviceorientation', onDO, { passive: true });
      sensorsActive = true;
      clearBanner();
    }catch(err){
      sensorsActive = false;
      showBanner('Motion sensors unavailable: ' + String(err && err.message || err));
    }
  }

  let lastDO = {alpha:0,beta:0,gamma:0,ts:0};
  function onDO(e){
    lastDO.alpha = e.alpha; lastDO.beta = e.beta; lastDO.gamma = e.gamma; lastDO.ts = performance.now();
  }

  // ===== Enable flow =====
  document.getElementById('enable').addEventListener('click', async ()=>{
    clearBanner();
    // Both need a user gesture; do not await sequentially to keep gesture alive too long.
    await startCamera();
    await requestMotionPermission();
  });

  // ===== Input (drag to orbit yaw/pitch) =====
  {
    let dragging = false, lx=0, ly=0;
    canvas.addEventListener('pointerdown', (e)=>{ dragging = true; lx=e.clientX; ly=e.clientY; canvas.setPointerCapture(e.pointerId); });
    canvas.addEventListener('pointerup',   (e)=>{ dragging = false; canvas.releasePointerCapture(e.pointerId); });
    canvas.addEventListener('pointercancel', ()=> dragging=false);
    canvas.addEventListener('pointermove', (e)=>{
      if (!dragging) return;
      const dx = e.clientX - lx, dy = e.clientY - ly; lx=e.clientX; ly=e.clientY;
      state.camYaw = (state.camYaw + dx*0.25);
      state.camPitch = clamp(state.camPitch + dy*0.25, -89, 89);
      const yawEl = document.getElementById('camYaw'); yawEl.value = state.camYaw; yawEl.dispatchEvent(new Event('input'));
      const pitEl = document.getElementById('camPitch'); pitEl.value = state.camPitch; pitEl.dispatchEvent(new Event('input'));
    }, { passive: true });
  }

  // ===== Wire controls =====
  wireControls();

  // ===== Render loop =====
  function render(){
    const t0 = performance.now();
    resize();

    // Update sensors → filtered euler
    if(state.useSensors && sensorsActive){
      const e = eulerFromDevice(lastDO.alpha, lastDO.beta, lastDO.gamma);
      // blend with sliders (sliders are additive offsets)
      filt.yaw = smooth(0.15, filt.yaw, e.yaw);
      filt.pitch = smooth(0.15, filt.pitch, e.pitch);
      filt.roll = smooth(0.15, filt.roll, e.roll);
    }

    // Upload video frame (if any)
    uploadVideoFrame();

    // uniforms
    gl.useProgram(prog);
    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, tex);
    gl.uniform1i(loc.u_env, 0);

    const yaw = (state.useSensors && sensorsActive ? filt.yaw : 0) + state.camYaw;
    const pitch = (state.useSensors && sensorsActive ? filt.pitch : 0) + state.camPitch;
    const roll = (state.useSensors && sensorsActive ? filt.roll : 0) + state.camRoll;

    const camR = makeBasis(yaw, pitch, roll);
    const camPos = new Float32Array([0, 0, 2.2]);
    gl.uniform3fv(loc.u_camPos, camPos);
    gl.uniformMatrix3fv(loc.u_camR, false, camR);
    gl.uniform1f(loc.u_fovTan, Math.tan(deg2rad(state.fov * 0.5)));
    gl.uniform2f(loc.u_resolution, canvas.width, canvas.height);

    gl.uniform3f(loc.u_sphereC, 0.0, 0.0, state.sphereZ);
    gl.uniform1f(loc.u_sphereR, state.radius);
    gl.uniform1f(loc.u_apertureCos, Math.cos(deg2rad(clamp(state.aperture,1,179))*0.5));
    gl.uniform1f(loc.u_reflect, state.reflect);

    gl.uniform2f(loc.u_uvScale, state.uScale, state.vScale);
    gl.uniform2f(loc.u_uvOffset, state.uOff, state.vOff);
    const envR = makeEnvRotation(state.envYaw, state.envPitch);
    gl.uniformMatrix3fv(loc.u_envR, false, envR);
    gl.uniform1i(loc.u_envMode, state.envMode|0);
    gl.uniform1f(loc.u_planeDist, state.planeDist);
    gl.uniform1f(loc.u_planeScale, state.planeScale);
    gl.uniform1i(loc.u_mirrorU, state.mirrorVideo?1:0);

    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

    // HUD
    const dt = performance.now() - t0;
    const camStr = camActive ? 'on' : 'off';
    const sensStr = (state.useSensors && sensorsActive) ? 'on' : (state.useSensors ? 'pending' : 'off');
    hud.textContent = `⏱︎ ${dt.toFixed(1)} ms • Sensors: ${sensStr} • Camera: ${camStr}`;

    requestAnimationFrame(render);
  }
  resize();
  render();

})();
</script>
</body>
</html>
