<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport"
      content="width=device-width, initial-scale=1, maximum-scale=1, viewport-fit=cover"/>
<title>Emoji → Pollinations</title>
<style>
  :root{
    --t1:#7fd1ff40; --t2:#ff86d640; --t3:#7dffcc40; --t4:#b59bff40;
    --ring2:#00000012; --shadow:0 8px 24px #0000001e,0 2px 8px #00000012;
    --shadow-strong:0 14px 40px #00000026,0 4px 16px #0000001f;
    --ease:cubic-bezier(.2,.8,.2,1);
    --glass:#ffffff70; --glassEdge:#ffffff90; --glassStroke:#00000012;
    --emerald:#10b981; --emerald-d:#0a8e65; --emerald-l:#59e0b9;
  }
  html,body{height:100%;margin:0}
  body{
    background:
      radial-gradient(60vmax 60vmax at 15% 10%, var(--t1), transparent 60%),
      radial-gradient(70vmax 60vmax at 85% 20%, var(--t2), transparent 60%),
      radial-gradient(60vmax 70vmax at 20% 85%, var(--t3), transparent 60%),
      radial-gradient(70vmax 70vmax at 80% 85%, var(--t4), transparent 60%),
      conic-gradient(from 0deg at 50% 50%, #e9f3ff, #ffe9f7, #e9fff6, #f7f3ff, #e9f3ff);
    background-attachment:fixed; animation:hue 24s linear infinite alternate;
    overflow:hidden; touch-action:none; -webkit-tap-highlight-color:transparent;
    font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, Helvetica, Arial, sans-serif;
  }
  @keyframes hue{to{filter:hue-rotate(12deg) saturate(1.05)}}

  .stage{position:fixed; inset:0; display:grid; place-items:center}

  /* floating seeds */
  .seeds{position:fixed; inset:0; pointer-events:none; z-index:5}
  .seed{
    position:absolute; width:56px; height:56px; border-radius:50%;
    display:grid; place-items:center; user-select:none; pointer-events:auto;
    background:radial-gradient(120% 120% at 30% 30%, #ffffffcc, #ffffff9a 60%, #ffffff7a 100%);
    box-shadow:var(--shadow), inset 0 1px 0 #ffffffc8, 0 0 0 1px #0001;
    transform:translate(-50%,-50%) scale(1);
    transition:transform .18s var(--ease), box-shadow .18s var(--ease);
    animation:float var(--dur,9s) ease-in-out infinite var(--delay,0s);
  }
  .seed .e{font-size:28px}
  @keyframes float{
    0%{ transform:translate(calc(-50% + var(--fx,0px)), calc(-50% + var(--fy,0px))) }
    50%{ transform:translate(calc(-50% + var(--fx,0px)), calc(-50% + var(--fy,0px) - 6px)) }
    100%{ transform:translate(calc(-50% + var(--fx,0px)), calc(-50% + var(--fy,0px))) }
  }

  /* central circle */
  .cauldron-wrap{ position:relative; width:min(64vmin,520px); aspect-ratio:1/1; z-index:20; display:grid; place-items:center }
  .cauldron{
    position:relative; width:100%; height:100%; border-radius:50%;
    background:radial-gradient(120% 120% at 70% 30%, #ffffffc0, #ffffff60 45%, #ffffff30 60%, #ffffff12 75%, #ffffff06 100%);
    box-shadow:var(--shadow-strong), inset 0 1px 0 #ffffffa0, inset 0 -20px 60px #0000000b;
    outline:1px solid var(--ring2);
    transition:transform .45s var(--ease);
    overflow:hidden; display:grid; place-items:center;
  }
  .ring{ position:absolute; inset:6%; border-radius:50%; border:1px dashed #00000018; outline:1px solid #ffffff90; outline-offset:-1px; box-shadow:inset 0 0 0 6px #ffffff10; pointer-events:none }
  .cauldron.over{ box-shadow:0 0 0 12px #00c8ff30, var(--shadow-strong) }

  /* chips inside */
  .placed{
    position:absolute; width:12vmin; max-width:72px; aspect-ratio:1/1; border-radius:50%;
    display:grid; place-items:center; user-select:none; cursor:grab;
    background:radial-gradient(120% 120% at 30% 30%, #ffffffc0, #ffffff80 60%, #ffffff50 100%);
    box-shadow:var(--shadow), inset 0 1px 0 #ffffffb8;
    transform:translate(-50%,-50%) scale(1);
    transition:transform .25s var(--ease), opacity .25s var(--ease);
    z-index:2;
  }
  .placed .e{font-size:clamp(24px, 8vmin, 44px)}
  .placed.dropin{ animation:drop .38s var(--ease) }
  @keyframes drop{ 0%{transform:translate(-50%,-50%) scale(.72)} 70%{transform:translate(-50%,-50%) scale(1.14)} 100%{transform:translate(-50%,-50%) scale(1)} }
  .placed.fadeout{ animation:fadeout .25s var(--ease) forwards }
  @keyframes fadeout{ to{ transform:translate(-50%,-50%) scale(.82); opacity:0 } }

  /* result image */
  .image-wrap{ position:absolute; inset:0; border-radius:50%; overflow:hidden; z-index:5; }
  .result-img{ width:100%; height:100%; object-fit:cover; display:block; opacity:0; transform:scale(.92); transition:opacity .6s var(--ease), transform .8s var(--ease) .1s; -webkit-touch-callout: default; }
  .result-img.revealed{ opacity:1; transform:scale(1) }
  .cauldron.show-image .placed{ opacity:0; pointer-events:none; transform:translate(-50%,-50%) scale(.94) }

  /* footer */
  .footer{
    position:fixed; left:16px; right:16px; bottom:16px; z-index:40;
    display:flex; gap:12px; align-items:center;
    padding:12px; border-radius:20px;
    background:linear-gradient(180deg, var(--glass), #ffffff40);
    backdrop-filter: blur(10px) saturate(1.1);
    box-shadow:var(--shadow), inset 0 0 0 1px var(--glassStroke), inset 0 1px 0 var(--glassEdge);
  }
  .pill{
    flex:1; height:56px; border-radius:16px;
    display:flex; align-items:center; gap:10px; padding:0 12px;
    background:radial-gradient(120% 120% at 30% 30%, #ffffffee, #ffffffc8 60%, #ffffffa0 100%);
    box-shadow: inset 0 1px 0 #ffffff, 0 1px 0 #00000005;
  }
  .input{ flex:1; height:40px; border-radius:12px; padding:8px 12px; outline:none; border:none; background:#ffffffd8; box-shadow: inset 0 1px 0 #ffffff, 0 0 0 1px #00000014; font-size:17px; }
  .add{
    width:48px; height:48px; border-radius:14px; display:grid; place-items:center; cursor:pointer;
    background:radial-gradient(140% 140% at 30% 30%, #ffffff, #f5f7ff 60%, #e9f0ff 100%);
    box-shadow:var(--shadow), inset 0 1px 0 #ffffff;
    flex:0 0 48px;
  }
  .add .e{ font-size:22px }

  /* CTA emerald (no stroke) */
  .cta{
    width:96px; height:96px; border-radius:26px; display:grid; place-items:center; cursor:pointer; user-select:none;
    background:
      radial-gradient(120% 140% at 30% 20%, #ffffff80, transparent 55%),
      radial-gradient(140% 160% at 70% 120%, #7ff0cf55, transparent 60%),
      linear-gradient(145deg, var(--emerald-l), var(--emerald), var(--emerald-d));
    box-shadow:
      0 16px 36px rgba(16,185,129,.35),
      0 6px 14px rgba(16,185,129,.35) inset,
      0 -10px 24px rgba(0,0,0,.18) inset;
    transition:transform .18s var(--ease), filter .18s var(--ease);
    position:relative; overflow:hidden;
  }
  .cta::after{
    content:""; position:absolute; inset:-60%;
    background: conic-gradient(from 0deg, #7ff0cf33, #b39bff33, #ff9bd433, #7ff0cf33);
    animation:ctaSpin 7s linear infinite; mix-blend-mode:overlay; pointer-events:none;
  }
  @keyframes ctaSpin{ to{ transform: rotate(360deg) } }
  .cta:hover{ transform:translateY(-1px) scale(1.04) }
  .cta:active{ transform:translateY(0) scale(.98) }
  .cta .e{ font-size:44px; filter: drop-shadow(0 1px 0 #fff6) }
  .cta.spin .e{ animation:spin .9s linear infinite }
  @keyframes spin{ to{ transform:rotate(360deg) } }

  ::selection{background:transparent}
</style>
</head>
<body>
  <div class="stage">
    <div class="seeds" id="seeds"></div>

    <div class="cauldron-wrap">
      <div class="cauldron" id="cauldron">
        <div class="ring"></div>
        <div class="image-wrap"><img id="image" class="result-img" alt="AI result" draggable="false"/></div>
      </div>
    </div>
  </div>

  <div class="footer" id="footer">
    <div class="pill">
      <input class="input" id="freeInput" placeholder="type text or emoji…"/>
      <button class="add" id="addBtn" aria-label="add"><span class="e">➕</span></button>
    </div>
    <button class="cta" id="cta" aria-label="generate"><span class="e">✨</span></button>
  </div>

<script>
/* ========== CONFIG ========== */
const EMOJI_POOL = ["😂","❤️","🤣","👍","😭","🙏","🥰","😍","😊","😅","🔥","👏","😁","💀","😉","✨","🎉","🤔","😎","🎨","🎵","🎧","📷","🎥","🧸","💎","🧠","🐶","🐱","🦊","🐼","🦄","🐧","🐸","🐢","🐙","🦋","🐝","🌸","🌼","🌻","🌿","🍃","🌊","🌈","⛰️","🏙️","☀️","🌙","⭐","⚡","💧","🍎","🍊","🍓","🍩","🍕","🍪"];
const INITIAL_SEEDS = 24;

const EMOJI_WORDS = new Map(Object.entries({
  "😂":"laughter","❤️":"a red heart","🤣":"hysterical laughter","👍":"approval","😭":"tears",
  "🙏":"gratitude","🥰":"affection","😍":"adoration","😊":"a smile","😅":"relief",
  "🔥":"flames","✨":"sparkles","🎉":"confetti","💀":"a skull","😉":"a wink",
  "🐶":"a dog","🐱":"a cat","🦊":"a fox","🐼":"a panda","🦄":"a unicorn","🐧":"a penguin","🐸":"a frog","🐢":"a turtle","🐙":"an octopus",
  "🦋":"a butterfly","🐝":"a bee","🌸":"a cherry blossom","🌼":"a daisy","🌻":"a sunflower","🌿":"green leaves","🍃":"leaves in motion",
  "🌊":"ocean waves","🌈":"a rainbow","⛰️":"mountains","🏙️":"a city skyline",
  "☀️":"sunlight","🌙":"moonlight","⭐":"starry sky","⚡":"lightning","💧":"a water droplet",
  "🍎":"an apple","🍊":"an orange","🍓":"strawberries","🍩":"a donut","🍕":"pizza","🍪":"a cookie",
  "🎨":"paint","🎵":"a music note","🎧":"headphones","📷":"a camera","🎥":"a film camera","🧸":"a teddy bear","💎":"a diamond","🧠":"a brain"
}));

/* ========== DOM ========== */
const cauldron = document.getElementById('cauldron');
const imageEl  = document.getElementById('image');
const seedsEl  = document.getElementById('seeds');
const footer   = document.getElementById('footer');
const freeInput= document.getElementById('freeInput');
const addBtn   = document.getElementById('addBtn');
const cta      = document.getElementById('cta');

/* ========== STATE ========== */
let seeds = [];     // {id, emoji, x, y}
let placed = [];    // {id, type:'emoji'|'hint', emoji?, hint?, x, y}
let dragging = null;

/* ========== INIT ========== */
initSeeds(); renderSeeds();

/* --- UI: input + add --- */
addBtn.addEventListener('click', addFromInput);
freeInput.addEventListener('keydown', e => { if (e.key==='Enter'){ e.preventDefault(); addFromInput(); freeInput.blur(); } });

function addFromInput(){
  const raw = (freeInput.value || "").trim();
  if(!raw) return pulse(addBtn);

  const emojis = Array.from(raw).filter(ch => /\p{Extended_Pictographic}/u.test(ch));
  const textOnly = raw.replace(/\p{Extended_Pictographic}/gu,'').replace(/\s+/g,' ').trim();

  emojis.forEach(e => placeChip({type:'emoji', emoji:e}));
  if (textOnly) placeChip({type:'hint', hint:textOnly, emoji:'💡'});

  freeInput.value = '';
  pulse(addBtn);
}

function placeChip(obj){
  const {x,y} = randomSpotInsideBowl();
  const id = crypto.randomUUID();
  placed.push({id, ...obj, x, y});
  renderPlaced(true);
}

/* --- layout helpers --- */
function viewportRect(){
  const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  const h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  return {left:0, top:0, width:w, height:h, right:w, bottom:h};
}

function randomSpotInsideBowl(){
  const bowl = cauldron.getBoundingClientRect();
  const maxTries=400; let tries=0;
  while(tries++<maxTries){
    const px = 8 + Math.random()*84; // 8%..92%
    const py = 8 + Math.random()*84;
    const cx = bowl.left + px/100*bowl.width;
    const cy = bowl.top  + py/100*bowl.height;
    const d = Math.hypot(cx-(bowl.left+bowl.width/2), cy-(bowl.top+bowl.height/2));
    if (d > bowl.width/2 - 40) continue;

    let ok=true;
    for(const p of placed){
      const dx = (p.x - px)/100*bowl.width;
      const dy = (p.y - py)/100*bowl.height;
      if (Math.hypot(dx,dy) < 66) { ok=false; break; }
    }
    if (ok) return {x:px, y:py};
  }
  return {x:50, y:50};
}

/* --- seeds around screen (not just top) --- */
function initSeeds(){
  const rect = viewportRect();
  const bowl = cauldron.getBoundingClientRect();
  const R = bowl.width/2;
  const cx = bowl.left + R, cy = bowl.top + R;
  const seedR = 28;

  const avoid = [
    {left: cx-R-24, top: cy-R-24, right: cx+R+24, bottom: cy+R+24},
    (()=>{const f=footer.getBoundingClientRect(); return {left:f.left-16, top:f.top-16, right:f.right+16, bottom:f.bottom+16}})()
  ];

  seeds = [];
  const taken=[];
  for(let i=0;i<INITIAL_SEEDS;i++){
    const emo = EMOJI_POOL[Math.floor(Math.random()*EMOJI_POOL.length)];
    const spot = randomSpot(rect, seedR, avoid, taken);
    if (!spot) continue;
    taken.push(spot);
    seeds.push({id:crypto.randomUUID(), emoji:emo, x:spot.x, y:spot.y});
  }
}
function randomSpot(rect, seedR, avoidRects, taken=[]){
  const maxTries = 1500; let tries=0;
  while (tries++<maxTries){
    const x = seedR+10 + Math.random()*(rect.width - seedR*2 - 20);
    const y = seedR+10 + Math.random()*(rect.height - seedR*2 - 20);
    const a = avoidRects.some(ar => x>ar.left-seedR && x<ar.right+seedR && y>ar.top-seedR && y<ar.bottom+seedR);
    if (a) continue;
    let ok=true;
    for(const s of taken){ if (Math.hypot(x - s.x, y - s.y) < seedR*2 + 16){ ok=false; break; } }
    if (!ok) continue;
    return {x,y};
  }
  return null;
}

function renderSeeds(){
  seedsEl.innerHTML = '';
  for(const s of seeds){
    const n = document.createElement('button');
    n.className = 'seed';
    n.style.left = s.x+'px'; n.style.top = s.y+'px';
    n.style.setProperty('--delay', `${(Math.random()*-6).toFixed(2)}s`);
    n.style.setProperty('--dur', `${(7+Math.random()*4).toFixed(2)}s`);
    n.style.setProperty('--fx', `${(Math.random()*14-7).toFixed(1)}px`);
    n.style.setProperty('--fy', `${(Math.random()*8-4).toFixed(1)}px`);
    n.dataset.id = s.id;
    n.innerHTML = `<span class="e">${s.emoji}</span>`;
    seedsEl.appendChild(n);
    n.addEventListener('pointerdown', e => startDragSeed(e, s.id));
  }
}

/* ========== DRAGGING ========== */
function startDragSeed(ev, id){
  ev.preventDefault();
  const idx = seeds.findIndex(s=>s.id===id);
  if (idx<0) return;
  const ghost = makeGhost(seeds[idx].emoji);
  dragging = {type:'seed', idx, emoji:seeds[idx].emoji, ghostEl:ghost};
  pointerMove(ev);
  window.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
}
function startDragPlaced(ev, id){
  ev.preventDefault();
  const idx = placed.findIndex(p=>p.id===id);
  if (idx<0) return;
  const ghost = makeGhost(placed[idx].emoji || '💡');
  dragging = {type:'placed', idx, emoji:placed[idx].emoji || '💡', ghostEl:ghost};
  pointerMove(ev);
  window.addEventListener('pointermove', pointerMove);
  window.addEventListener('pointerup', pointerUp);
}
function makeGhost(emoji){
  const g = document.createElement('div');
  g.className='seed';
  g.style.width='64px'; g.style.height='64px'; g.style.position='fixed'; g.style.zIndex=9999;
  g.style.transform='translate(-50%,-50%) scale(1.0)';
  g.style.boxShadow='var(--shadow-strong), 0 0 0 2px #00c8ff30';
  g.innerHTML = `<span class="e">${emoji}</span>`;
  document.body.appendChild(g); return g;
}
function pointerMove(ev){
  if (!dragging) return;
  dragging.ghostEl.style.left = ev.clientX+'px';
  dragging.ghostEl.style.top  = ev.clientY+'px';
  const {inside} = coordsInCauldron(ev.clientX, ev.clientY);
  dragging.ghostEl.style.transform = `translate(-50%,-50%) scale(${inside?1.26:1.04})`;
  cauldron.classList.toggle('over', inside);
}
function pointerUp(ev){
  if (!dragging) return cleanupDrag();
  const {inside, px, py} = coordsInCauldron(ev.clientX, ev.clientY);
  cauldron.classList.remove('over');

  if (inside){
    if (dragging.type==='seed'){
      const id = crypto.randomUUID();
      placed.push({id, type:'emoji', emoji:dragging.emoji, x:px, y:py});
      renderPlaced(true);
      const node = [...seedsEl.children][dragging.idx]; if (node) node.remove();
      seeds.splice(dragging.idx,1);
    } else {
      placed[dragging.idx].x = px; placed[dragging.idx].y = py;
      renderPlaced(false);
    }
  } else {
    if (dragging.type==='placed'){
      const id = placed[dragging.idx].id;
      const node = cauldron.querySelector(`.placed[data-id="${id}"]`);
      if (node){ node.classList.add('fadeout'); setTimeout(()=>node.remove(),260); }
      placed.splice(dragging.idx,1);
    }
  }
  cleanupDrag();
}
function cleanupDrag(){
  window.removeEventListener('pointermove', pointerMove);
  window.removeEventListener('pointerup', pointerUp);
  if (dragging?.ghostEl) dragging.ghostEl.remove();
  dragging = null;
}

function renderPlaced(playDrop=false){
  Array.from(cauldron.querySelectorAll('.placed')).forEach(n=>n.remove());
  for (const p of placed){
    const n = document.createElement('div');
    n.className='placed'; n.dataset.id=p.id;
    n.style.left=p.x+'%'; n.style.top=p.y+'%';
    n.innerHTML=`<span class="e">${p.emoji || '💡'}</span>`;
    if (playDrop) n.classList.add('dropin');
    n.addEventListener('pointerdown', e=>startDragPlaced(e, p.id));
    cauldron.appendChild(n);
  }
}

/* ========== Geometry ========== */
function coordsInCauldron(cx, cy){
  const r = cauldron.getBoundingClientRect();
  const mx = cx - (r.left + r.width/2);
  const my = cy - (r.top  + r.height/2);
  const dist = Math.hypot(mx,my);
  const inside = dist <= r.width/2;
  const px = ((mx + r.width/2) / r.width) * 100;
  const py = ((my + r.height/2) / r.height) * 100;
  return {inside, px: Math.max(6, Math.min(94, px)), py: Math.max(6, Math.min(94, py))};
}

/* ========== Prompt (coherent scene) ========== */
function buildPromptCoherent(){
  const emojiItems = placed.filter(p=>p.type==='emoji');
  const hintTexts  = placed.filter(p=>p.type==='hint').map(p=>p.hint);

  if (!emojiItems.length && !hintTexts.length) return "";

  // choose a central subject if available (first animal/thing), others become motifs
  const subject = emojiItems[0];
  const motifs  = emojiItems.slice(1);

  const nameOf = e => EMOJI_WORDS.get(e) || `the ${e} symbol`;
  const dirOf = (x,y)=> {
    const ang = (Math.atan2(y-50,x-50)*180/Math.PI+360)%360;
    const dirs=["right","top-right","top","top-left","left","bottom-left","bottom","bottom-right"];
    return dirs[Math.round((360-ang)/45)%8];
  };

  const subjectTxt = subject ? `a scene centered on ${nameOf(subject.emoji)}` : `a single cohesive scene`;
  const motifsTxt = motifs.length
    ? `, complemented by ${motifs.map(m=>`${nameOf(m.emoji)} at the ${dirOf(m.x,m.y)}`).join(', ')}`
    : ``;
  const mood = hintTexts.length ? `. Mood & style: ${hintTexts.join(', ')}.` : `.`;
  const guard = ` Interpret emojis as real objects, places, colors, or emotions — not as glyphs. Compose one coherent image with depth, lighting, and consistent style. No text.`;

  return `${subjectTxt}${motifsTxt}${mood}${guard}`;
}

/* ========== Pollinations ========== */
async function callPollinations(prompt){
  const url = "https://image.pollinations.ai/prompt/" +
              encodeURIComponent(prompt) + "?width=768&height=768";
  const res = await fetch(url,{mode:"cors"});
  if(!res.ok) throw new Error('Pollinations error');
  const blob = await res.blob();
  return URL.createObjectURL(blob);
}

/* ========== CTA ========== */
cta.addEventListener('click', async ()=>{
  const prompt = buildPromptCoherent();
  if(!prompt){
    cauldron.animate([{transform:'translateX(0)'},{transform:'translateX(-7px)'},{transform:'translateX(7px)'},{transform:'translateX(0)'}],
      {duration:280, easing:'cubic-bezier(.3,.8,.2,1)'});
    return;
  }
  cta.classList.add('spin');
  imageEl.classList.remove('revealed'); cauldron.classList.remove('show-image');
  try{
    const imgURL = await callPollinations(prompt);
    imageEl.src = imgURL;
    imageEl.onload = () => { imageEl.classList.add('revealed'); cauldron.classList.add('show-image'); };
  }catch(e){ console.warn(e); }
  finally{ cta.classList.remove('spin'); }
});

/* ========== Helpers ========== */
function pulse(el){ el.animate([{transform:'scale(1)'},{transform:'scale(1.06)'},{transform:'scale(1)'}],{duration:220,easing:'cubic-bezier(.3,.8,.2,1)'}); }

/* gesture guard */
document.addEventListener('gesturestart', e=>e.preventDefault());
</script>
</body>
</html>