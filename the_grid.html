<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Grid · Density Dropdown + Even Picker + Icons</title>
<style>
  :root{
    --bg:#0b0c0e;
    --grid-dim:#0e1217;
    --grid-bright:#141a23;
  }
  html,body{height:100%}
  body{margin:0;background:var(--bg);overflow:hidden}
  canvas{display:block;width:100vw;height:100vh;touch-action:none}
  #sab{position:fixed;bottom:0;left:0;width:0;height:env(safe-area-inset-bottom);pointer-events:none;opacity:0}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="sab" aria-hidden="true"></div>

<script>
(()=>{
// ===== canvas/setup =====
const cv=document.getElementById('cv');
const ctx=cv.getContext('2d',{alpha:false,desynchronized:true});
const DPR=Math.max(1,Math.min(devicePixelRatio||1,2));
const sabProbe=document.getElementById('sab');

let W=0,H=0,CELL=0,COLS=0,ROWS=0,N=0;

// Densities (CSS px per cell)
const DENSITY_CHOICES=[2,3,4,6,8,12,16];
let cellCssPx=DENSITY_CHOICES[0];

// world params (brush & life tuned via picker)
const params={
  lifeFertility:1.2,
  lifeResilience:0.3,
  lifeSpread:1.4,
  lifeMortality:0.5,
  brushRadius:1.1,
  stoneFormSec:2.0,
  wallBombPct:0.08,
  wallBoostPct:0.08
};
const WALL_TOXICITY=0.25;
let brushMode='seed'; // 'seed' | 'barrier' | 'nutrient' | 'erase'

// ===== state arrays =====
let alive,nextAlive,blink,field,hueX,hueY;
let forming,stoneProg,stoneJit,stoneFlag,stoneHP,wallType;
let nutrient,nutBoost,nutFlash;
let poisonWave,nextPoisonWave,nutWave,nextNutWave;
let boostFlash,eraseGlow;
const emitters=[];

function alloc(){
  alive=new Uint8Array(N); nextAlive=new Uint8Array(N); blink=new Float32Array(N);
  field=new Float32Array(N); hueX=new Float32Array(N); hueY=new Float32Array(N);
  forming=new Uint8Array(N); stoneProg=new Float32Array(N); stoneJit=new Float32Array(N);
  stoneFlag=new Uint8Array(N); stoneHP=new Float32Array(N); wallType=new Uint8Array(N);
  nutrient=new Float32Array(N); nutBoost=new Uint8Array(N); nutFlash=new Uint8Array(N);
  poisonWave=new Uint8Array(N); nextPoisonWave=new Uint8Array(N);
  nutWave=new Uint8Array(N); nextNutWave=new Uint8Array(N);
  boostFlash=new Float32Array(N); eraseGlow=new Float32Array(N);
  emitters.length=0;
}

// grid pattern
let gridPattern=null, GRID_DIM=null;
function cssVar(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}
function buildGridPattern(){
  const s=CELL, p=document.createElement('canvas'); p.width=p.height=2*s;
  const g=p.getContext('2d');
  GRID_DIM=cssVar('--grid-dim'); const bright=cssVar('--grid-bright');
  g.fillStyle=GRID_DIM; g.fillRect(0,0,2*s,2*s);
  g.fillStyle=bright; g.fillRect(0,0,s,s); g.fillRect(s,s,s,s);
  gridPattern=ctx.createPattern(p,'repeat');
}

function applyGrid(){
  W=Math.floor(innerWidth*DPR); H=Math.floor(innerHeight*DPR);
  cv.width=W; cv.height=H; cv.style.width='100vw'; cv.style.height='100vh';
  CELL=Math.max(2, Math.round(cellCssPx*DPR));
  COLS=(W/CELL)|0; ROWS=(H/CELL)|0; N=COLS*ROWS;
  alloc(); buildGridPattern(); computeUI();
}

// ===== UI layout (density dropdown + picker) =====
// physical sizes (CSS px → device px)
const PICKER_PX = 120;     // desired picker height (capped below)
const UI_SPACER_PX = 12;   // gap between dropdown and picker
const DENS_HEADER_PX = 36; // header row height (min 48 enforced)
const DENS_PANEL_PX  = 160;// density items area height when opened

// --- Hard cap for the bottom controller stripe (CSS px) ---
const BOTTOM_STRIPE_MAX_PX = 200; // total vertical size cap for the picker area
let STRIPE_MAX_DPX = 0;           // computed per-DPR device-px cap

// --- Touch ergonomics ---
const TOUCH_MIN_PX = 48; // standard touch target (CSS px)
let CHEVRON_CX_DPX = 0, CHEVRON_CY_DPX = 0, CHEVRON_HIT = null;

let reservedBottomRows=0;

let densHeaderY0=0,densHeaderY1=0;
let densPanelY0=0,densPanelY1=0, densOpen=false;

let pickY0=0,pickY1=0;
let pickLifeEnd=0,pickWallEnd=0,pickNutrEnd=0,pickEraseEnd=0;

// strict no-draw: from densHeaderY0 downward
let noDrawBorderPxTop=0;

// --- Step-rate selector (inside expanded density panel) ---
const RATE_PANEL_PX = 56; // CSS px height for control bar
const RATE_OPTIONS = [
  {label:'ASAP', ms:0},
  {label:'20ms', ms:20},
  {label:'50ms', ms:50},
  {label:'200ms',ms:200}
];
let stepMs = 50; // default selection
let rateY0=0, rateY1=0; // rows for the selector

function safeBottomCssPx(){ return sabProbe.getBoundingClientRect().height||0; }
function rowsFromPx(px){ return Math.max(2, Math.ceil((px*DPR)/CELL)); }

// ---- UI sizing helpers (device px, independent of CELL) ----
function uiPx(px){ return Math.floor(px * DPR); }
function uiLine(px){ return Math.max(1, Math.floor(px * DPR)); }

function computeUI(){
  const inset=safeBottomCssPx();
  reservedBottomRows = Math.ceil(((inset+24)*DPR)/Math.max(1,CELL));

  // Compute picker rows by physical height, capped to 200px
  const PICK_ROWS = rowsFromPx(Math.min(PICKER_PX, BOTTOM_STRIPE_MAX_PX));

  // Header must be at least 48px tall
  const HEADER_ROWS= rowsFromPx(Math.max(DENS_HEADER_PX, TOUCH_MIN_PX));

  // If open, panel items area + rate bar; else 0
  const PANEL_ROWS = densOpen ? rowsFromPx(DENS_PANEL_PX) : 0;
  const SPACER_ROWS= rowsFromPx(UI_SPACER_PX);

  // Bottom-up placement
  pickY1=ROWS-1-reservedBottomRows;
  pickY0=Math.max(0, pickY1 - PICK_ROWS + 1);

  const spacerY1=Math.max(0, pickY0 - 1);
  const spacerY0=Math.max(0, spacerY1 - SPACER_ROWS + 1);

  // Entire expandable area top is densHeader; below it live panel+rate then spacer then picker.
  densPanelY1 = Math.max(0, spacerY0 - 1);

  if (densOpen){
    const RATE_ROWS = rowsFromPx(RATE_PANEL_PX);
    rateY1 = densPanelY1;
    rateY0 = Math.max(0, rateY1 - RATE_ROWS + 1);

    // density items occupy everything above the rate bar; height ~ DENS_PANEL_PX
    densPanelY0 = Math.max(0, rateY0 - 1 - rowsFromPx(DENS_PANEL_PX) + 1);
    if (densPanelY0 > rateY0 - 1) densPanelY0 = Math.max(0, rateY0 - 1);
  } else {
    // closed: no panel nor rate bar
    densPanelY0 = densPanelY1 + 1;
    rateY0 = rateY1 = densPanelY1 + 1;
  }

  densHeaderY1 = densOpen ? Math.max(0, densPanelY0 - 1) : Math.max(0, spacerY0 - 1);
  densHeaderY0 = Math.max(0, densHeaderY1 - HEADER_ROWS + 1);

  noDrawBorderPxTop = densHeaderY0*CELL;

  // Picker horizontal partitions (Life big, Wall big, Nutr small, Erase small; small = 1/3 big)
  const totalUnits=8;
  const lifeUnits=3, wallUnits=3, nutrUnits=1, eraseUnits=1;
  const unitCols = Math.max(1, Math.floor(COLS/totalUnits));
  pickLifeEnd  = lifeUnits*unitCols;
  pickWallEnd  = pickLifeEnd + wallUnits*unitCols;
  pickNutrEnd  = pickWallEnd + nutrUnits*unitCols;
  pickEraseEnd = COLS; // fill remainder

  // cache device-px cap for icon sizing
  STRIPE_MAX_DPX = Math.round(BOTTOM_STRIPE_MAX_PX * DPR);
}

// ===== Picker mapping =====
function lerp(a,b,t){return a*(1-t)+b*t;}
const lerp2=(a,b,k)=>[ lerp(a[0],b[0],k), lerp(a[1],b[1],k) ];
function wallMixFrom(t){
  if(t<=0.5){const k=t/0.5; return lerp2([0.30,0.00],[0.15,0.15],k);}
  if(t<=0.85){const k=(t-0.5)/0.35; return lerp2([0.15,0.15],[0.00,0.30],k);}
  const k=(t-0.85)/0.15; return lerp2([0.00,0.30],[0.00,0.00],k);
}

let picking=null, lastPick=null, nowTS=performance.now();
function applyPick(px,py){
  const cx=(px/CELL)|0;
  let readout=[], t=0;

  if (cx < pickLifeEnd){
    brushMode='seed';
    t = Math.min(1, Math.max(0, cx/Math.max(1,pickLifeEnd-1)));
    params.lifeFertility=lerp(0.6,3.0,t);
    params.lifeResilience=lerp(0.0,1.0,t);
    params.lifeSpread=lerp(0.8,2.5,t);
    params.lifeMortality=lerp(0.70,0.12,t);
    readout=[`LIFE`];
  } else if (cx < pickWallEnd){
    brushMode='barrier';
    t = Math.min(1, Math.max(0, (cx-pickLifeEnd)/Math.max(1,(pickWallEnd-pickLifeEnd-1))));
    const [bomb,boost]=wallMixFrom(t);
    params.wallBombPct=bomb; params.wallBoostPct=boost;
    readout=[`WALLS`];
  } else if (cx < pickNutrEnd){
    brushMode='nutrient'; readout=[`NUTRITION`];
  } else {
    brushMode='erase'; readout=[`ERASE`];
  }
  picking={x:px,y:py,readout,mode:brushMode,t};
  lastPick={x:px, until:nowTS+700, readout};
}

// ===== Strict input routing (no draw below header) =====
function isInNoDrawZonePx(py){ return py>=noDrawBorderPxTop; }
function inHeader(row){ return row>=densHeaderY0 && row<=densHeaderY1; }
function inPanel(row){ return densOpen && row>=densPanelY0 && row<=densPanelY1; }
function inPicker(row){ return row>=pickY0 && row<=pickY1; }

const touches=new Map();
function normTouches(e){
  const r=cv.getBoundingClientRect(); const out=[];
  const list=(e.changedTouches||[]);
  for(let i=0;i<list.length;i++){
    const t=list[i]; out.push({id:t.identifier,x:(t.clientX-r.left)*DPR,y:(t.clientY-r.top)*DPR});
  } return out;
}

function onStart(e){
  e.preventDefault();
  for(const t of normTouches(e)){
    const row=(t.y/CELL)|0;
    const c={id:t.id,lastX:t.x,lastY:t.y,ui:null};
    if (isInNoDrawZonePx(t.y)){
      if (inHeader(row)){
        c.ui='header';
        // Only toggle if finger is inside the chevron's 48x48 px hitbox
        if (CHEVRON_HIT && pointInRect(t.x, t.y, CHEVRON_HIT)) toggleDensityOpen();
      }
      else if (inPanel(row)){
        c.ui='panel';
        const isRateRow = row>=rateY0 && row<=rateY1;
        if (isRateRow) chooseRateAt(t.x,t.y);
        else chooseDensityAt(t.x,t.y);
      }
      else if (inPicker(row)){ c.ui='picker'; applyPick(t.x,t.y); }
      else c.ui='blocked';
    } else {
      c.ui='draw'; deposit(t.x,t.y,0,0,true);
    }
    touches.set(t.id,c);
  }
}
function onMove(e){
  e.preventDefault();
  for(const t of normTouches(e)){
    const prev=touches.get(t.id); if(!prev) continue;
    const row=(t.y/CELL)|0;
    if (isInNoDrawZonePx(t.y)){
      if (inPanel(row)){
        prev.ui='panel';
        const isRateRow = row>=rateY0 && row<=rateY1;
        if (isRateRow) chooseRateAt(t.x,t.y);
        else chooseDensityAt(t.x,t.y);
        continue;
      }
      if (inPicker(row)){ prev.ui='picker'; applyPick(t.x,t.y); continue; }
      prev.ui='blocked'; continue;
    }
    if (prev.ui!=='draw') continue;
    const vx=t.x-prev.lastX, vy=t.y-prev.lastY; deposit(t.x,t.y,vx,vy,false);
    prev.lastX=t.x; prev.lastY=t.y;
  }
}
function onEnd(e){ for(const t of normTouches(e)) touches.delete(t.id); picking=null; }

cv.addEventListener('touchstart',onStart,{passive:false});
cv.addEventListener('touchmove', onMove ,{passive:false});
cv.addEventListener('touchend',  onEnd  ,{passive:false});
cv.addEventListener('touchcancel',onEnd ,{passive:false});

// ===== Density dropdown logic =====
let densHoverIdx=-1;
function toggleDensityOpen(){ densOpen=!densOpen; if(!densOpen) densHoverIdx=-1; computeUI(); }
function densitiesLayout(){ // return array of row rects (for selection)
  if(!densOpen) return [];
  const rows = densPanelY1-densPanelY0+1;
  const items = DENSITY_CHOICES.length;
  const per = Math.max(2, Math.floor(rows/items));
  const out=[];
  let y=densPanelY0;
  for(let i=0;i<items;i++){
    const y0=y, y1=Math.min(densPanelY1, y+per-1);
    out.push({y0,y1,val:DENSITY_CHOICES[i]});
    y=y1+1;
  }
  return out;
}
function chooseDensityAt(px,py){
  const cy=(py/CELL)|0; const items=densitiesLayout();
  for(const it of items){
    if(cy>=it.y0 && cy<=it.y1){
      if (cellCssPx!==it.val){ cellCssPx=it.val; applyGrid(); }
      densHoverIdx=DENSITY_CHOICES.indexOf(it.val);
      return;
    }
  }
}

// ===== Emitters / physics (unchanged core) =====
function addEmitter(px,py,ang,energy,burst,canSpawn,colorMode){
  const mult=params.lifeSpread;
  for(let k=0;k<(burst||1);k++){
    const jitter=ang+(Math.random()-0.5)*0.5;
    const spd=(12+28*Math.min(1,energy)+Math.random()*6)*mult;
    const ttl=(900+1200*energy+Math.random()*400)/(1/Math.max(0.6,Math.min(2.5,mult)));
    emitters.push({x:px/CELL,y:py/CELL,dx:Math.cos(jitter)*spd,dy:Math.sin(jitter)*spd,ttl,canSpawn:!!canSpawn,colorMode:colorMode||0});
  }
  if(emitters.length>1600) emitters.splice(0, emitters.length-1600);
}
function radialBurst(cx,cy,rays,canSpawn=true,colorMode=0){
  const cxp=cx*CELL + CELL*0.5, cyp=cy*CELL + CELL*0.5;
  const r=rays||28;
  for(let i=0;i<r;i++){ const a=(i/r)*Math.PI*2; addEmitter(cxp,cyp,a,1,1,canSpawn,colorMode); }
}
function stepEmitters(dt){
  for(let i=emitters.length-1;i>=0;i--){
    const e=emitters[i]; e.ttl-=dt; if(e.ttl<=0){emitters.splice(i,1); continue;}
    const s=dt/1000; e.x+=e.dx*s; e.y+=e.dy*s;
    const ix=e.x|0, iy=e.y|0; if(ix<0||iy<0||ix>=COLS||iy>=ROWS){ emitters.splice(i,1); continue; }
    const id=iy*COLS+ix;
    if (stoneFlag[id]){
      const damp=-0.6;
      if(Math.abs(e.dx)>Math.abs(e.dy)){ e.dx*=damp; e.dy*=0.35; } else { e.dy*=damp; e.dx*=0.35; }
    } else if (e.canSpawn){ alive[id]=1; blink[id]=1.0; }
    if (e.colorMode===2){ eraseGlow[id]=Math.max(eraseGlow[id],1.0); }
  }
}

function deposit(px,py,vx,vy,initial){
  if(isInNoDrawZonePx(py)) return;
  const sp=Math.hypot(vx,vy);
  const baseR=2.2*CELL*params.brushRadius;
  const r=baseR+Math.min(7*CELL*params.brushRadius, sp*1.0);
  const r2=r*r; const cx=(px/CELL)|0, cy=(py/CELL)|0; const rad=Math.ceil(r/CELL);
  const dirAng=Math.atan2(vy, vx||1e-6);
  if((initial || sp>0.6*CELL)){
    if(brushMode==='seed') addEmitter(px,py,dirAng,Math.min(1,sp/(2.0*CELL)),1,true,0);
    if(brushMode==='erase')addEmitter(px,py,dirAng,Math.min(1,sp/(2.0*CELL)),2,false,2);
  }
  for(let yy=cy-rad; yy<=cy+rad; yy++){
    if(yy<0||yy>=ROWS) continue;
    if (yy*CELL + CELL*0.5 >= noDrawBorderPxTop) continue;
    for(let xx=cx-rad; xx<=cx+rad; xx++){
      if(xx<0||xx>=COLS) continue;
      const gx=xx*CELL + CELL*0.5, gy=yy*CELL + CELL*0.5;
      const dx=gx-px, dy=gy-py; const d2=dx*dx+dy*dy; if(d2>r2) continue;
      const i=yy*COLS+xx;
      const sigma=r*0.5; const fall=Math.exp(-d2/(2*sigma*sigma));
      const amp=fall*(1+Math.min(1, sp/(1.6*CELL)));

      if (brushMode==='seed'){
        field[i]=Math.max(field[i], amp*0.9);
        const ang=Math.atan2(dy,dx); hueX[i]+=Math.cos(ang)*amp; hueY[i]+=Math.sin(ang)*amp;
        if(!alive[i] && Math.random()<amp*0.9){ alive[i]=1; blink[i]=1.0; }
      } else if (brushMode==='barrier'){
        if(!stoneFlag[i]){
          if(!forming[i]){
            forming[i]=1; stoneJit[i]=0.9+Math.random()*0.2;
            const r1=Math.random(); wallType[i]=0;
            if(r1<params.wallBombPct) wallType[i]=1; else if(r1<params.wallBombPct+params.wallBoostPct) wallType[i]=2;
          }
          stoneProg[i]=Math.min(1, stoneProg[i]+amp*0.05);
        }
        nutrient[i]=0; if(nutBoost[i]){nutBoost[i]=0;nutFlash[i]=0;}
      } else if (brushMode==='nutrient'){
        nutrient[i]=Math.min(1, nutrient[i]+amp*0.9);
      } else {
        alive[i]=0; nextAlive[i]=0; blink[i]=0;
        nutrient[i]=0; nutBoost[i]=0; nutFlash[i]=0;
        poisonWave[i]=0; nutWave[i]=0;
        forming[i]=0; stoneFlag[i]=0; stoneHP[i]=0; stoneProg[i]=0; wallType[i]=0;
        eraseGlow[i]=Math.max(eraseGlow[i],0.2+0.8*amp);
      }
    }
  }
}

// ===== sim =====
function step(dt){
  const tick=dt;

  const seedFade=Math.exp(-tick/180);
  for(let i=0;i<N;i++){
    field[i]*=seedFade; hueX[i]*=seedFade; hueY[i]*=seedFade;
    blink[i]*=Math.exp(-tick/90);
    if(nutFlash[i]>0)   nutFlash[i]=Math.max(0,nutFlash[i]-tick);
    if(boostFlash[i]>0) boostFlash[i]=Math.max(0,boostFlash[i]-tick);
    if(eraseGlow[i]>0)  eraseGlow[i]*=Math.exp(-tick/200);
  }

  for(let i=0;i<N;i++){
    if(forming[i] && !stoneFlag[i]){
      stoneProg[i]+=(1/(params.stoneFormSec*1000))*(stoneJit[i]||1)*tick;
      if(stoneProg[i]>=1){ stoneProg[i]=1; forming[i]=0; stoneFlag[i]=1; stoneHP[i]=1; }
    }
  }

  stepEmitters(tick);

  nextPoisonWave.fill(0); nextNutWave.fill(0);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const i=y*COLS+x;
      const pS=poisonWave[i]; if(pS>0){
        const s=pS-1;
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
          if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
          if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
          const j=yy*COLS+xx; if(stoneFlag[j])continue;
          if(nextPoisonWave[j]<s) nextPoisonWave[j]=s;
        }
      }
      const nS=nutWave[i]; if(nS>0){
        const s=nS-1;
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
          if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
          if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
          const j=yy*COLS+xx; if(stoneFlag[j])continue;
          if(nextNutWave[j]<s) nextNutWave[j]=s;
        }
      }
    }
  }
  for(let i=0;i<N;i++){
    poisonWave[i]=Math.max(0, Math.max(poisonWave[i]-1, nextPoisonWave[i]));
    nutWave[i]=Math.max(0, Math.max(nutWave[i]-1, nextNutWave[i]));
    if(nutWave[i]>0) nutrient[i]=Math.min(1, nutrient[i]+0.25);
  }

  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const i=y*COLS+x; if(stoneFlag[i]){ nextAlive[i]=0; continue; }
      const a=alive[i];
      let n=0,nearBarrier=false;
      for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
        if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
        if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
        const j=yy*COLS+xx; const isB=stoneFlag[j]||forming[j];
        n+=alive[j]*(isB?0.25:1.0); if(isB) nearBarrier=true;
      }
      const nut=nutrient[i], waveP=poisonWave[i];
      let born=(!a)&&(n===3);
      let survive=(a)&&(n===2||n===3);
      if(!a && n===2){
        const fert=0.08*(Math.max(0,params.lifeFertility-1))*(0.6+0.8*nut);
        if(Math.random()<fert) born=true;
      }
      if(a && n===4){
        const res=0.5*params.lifeResilience*(0.6+0.8*nut);
        if(Math.random()<res) survive=true;
      }
      let dead=false;
      if(a && nearBarrier){
        const p=WALL_TOXICITY*(0.8-0.5*nut); if(Math.random()<p) dead=true;
      }
      if(a && !dead && waveP>0) dead=true;
      if(a && !dead){
        const m=params.lifeMortality*0.16; if(Math.random()<m) dead=true;
      }
      nextAlive[i]= dead?0:(born?1:(survive?1:0));
      if(nextAlive[i]){
        blink[i]=1.0;
        if(nutrient[i]>0) nutrient[i]=Math.max(0, nutrient[i]-0.10);
        if(nutBoost[i]){ nutBoost[i]=0; nutFlash[i]=240; radialBurst(x,y,32,true,0); }
      }
    }
  }
  {const t=alive; alive=nextAlive; nextAlive=t;}

  const eatBase=0.06*params.lifeSpread*(1+0.6*Math.random());
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const i=y*COLS+x; if(!alive[i]) continue;
      for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
        if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
        if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
        const j=yy*COLS+xx; if(!stoneFlag[j]) continue;
        stoneHP[j]-=eatBase;
        if(stoneHP[j]<=0){
          const t=wallType[j];
          stoneFlag[j]=0; stoneHP[j]=0; stoneProg[j]=0; forming[j]=0;
          if(t===1){
            boostFlash[j]=240; poisonWave[j]=Math.max(poisonWave[j],10);
            const r=8;
            for(let ddy=-1;ddy<=1;ddy++)for(let ddx=-1;ddx<=1;ddx++){
              if(!ddx&&!ddy)continue; const nx=xx+ddx, ny=yy+ddy;
              if(nx<0||ny<0||nx>=COLS||ny>=ROWS) continue;
              const id=ny*COLS+nx; if(!stoneFlag[id]) poisonWave[id]=Math.max(poisonWave[id],r);
            }
          } else if (t===2){
            boostFlash[j]=160; nutWave[j]=Math.max(nutWave[j],10); radialBurst(xx,yy,32,true,0);
            const R=4,R2=R*R;
            for(let iy=yy-R; iy<=yy+R; iy++){
              if(iy<0||iy>=ROWS) continue;
              for(let ix=xx-R; ix<=xx+R; ix++){
                if(ix<0||ix>=COLS) continue;
                const dx2=ix-xx,dy2=iy-yy; if(dx2*dx2+dy2*dy2>R2) continue;
                const id=iy*COLS+ix;
                if(stoneFlag[id]||forming[id]){ stoneFlag[id]=0; forming[id]=0; stoneHP[id]=0; stoneProg[id]=0; wallType[id]=0; nutrient[id]=Math.min(1,nutrient[id]+1); }
              }
            }
          } else {
            boostFlash[j]=160; radialBurst(xx,yy,20,true,0);
          }
          wallType[j]=0;
        }
      }
    }
  }
}

// ===== helpers for UI sizing / hit tests =====
function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
function pointInRect(px, py, r){ return px>=r.x0 && px<=r.x1 && py>=r.y0 && py<=r.y1; }
function pickStripeHeightDPX(){ return (pickY1 - pickY0 + 1) * CELL; }
function pickIconCapDPX(){ return Math.min(STRIPE_MAX_DPX, pickStripeHeightDPX()) * 0.6; }
// Fixed icon sizes in CSS px, then DPR-adjusted, clamped to stripe
function iconSizeFixedPx(cssPx){ return Math.min(uiPx(cssPx), Math.floor(pickIconCapDPX())); }
function lineWidthFromSize(sz, k){ return Math.max(1, Math.floor(sz * k)); }

// ===== render =====
function fillCell(ix,iy){ ctx.fillRect(ix*CELL+1, iy*CELL+1, CELL-2, CELL-2); }

function render(){
  // grid
  ctx.fillStyle = gridPattern ? gridPattern : (GRID_DIM || '#0e1217');
  ctx.fillRect(0,0,W,H);

  // world
  for(let y=0;y<ROWS;y++){
    const off=y*COLS;
    for(let x=0;x<COLS;x++){
      const i=off+x;
      if(boostFlash[i]>0 || nutFlash[i]>0){ ctx.fillStyle='#fff176'; fillCell(x,y); continue; }
      if(stoneFlag[i]){ ctx.fillStyle='#8a93a0'; fillCell(x,y); continue; }
      const prog=stoneProg[i];
      if(prog>0){ ctx.fillStyle='hsl(210,0%,60%)'; ctx.globalAlpha=Math.min(1,0.15+0.85*prog); fillCell(x,y); ctx.globalAlpha=1; }
      if(poisonWave[i]>0){ ctx.globalAlpha=Math.min(0.45,0.06*poisonWave[i]); ctx.fillStyle='hsl(320,90%,50%)'; fillCell(x,y); ctx.globalAlpha=1; }
      const nut=nutrient[i];
      if(nut>0.02){ ctx.globalAlpha=Math.min(0.35,nut*0.35); ctx.fillStyle='#ff9a3c'; fillCell(x,y); ctx.globalAlpha=1; }
      if(nutWave[i]>0){ ctx.globalAlpha=Math.min(0.35,0.05*nutWave[i]); ctx.fillStyle='#ff9a3c'; fillCell(x,y); ctx.globalAlpha=1; }
      const f=field[i], a=alive[i];
      if(f>0.02 || a){
        const hx=hueX[i], hy=hueY[i];
        const H=(hx||hy)?(Math.atan2(hy,hx)*180/Math.PI+360)%360:200;
        const S=Math.min(100,60+Math.max(0,f)*40);
        const L=(18+(a?28:12)+Math.max(0,f)*60);
        ctx.fillStyle=`hsl(${H},${S}%,${Math.min(74,L)}%)`;
        fillCell(x,y);
      }
      const b=blink[i]; if(b>0.02){ ctx.globalAlpha=Math.min(0.22,b*0.22); ctx.fillStyle='#bfe2ff'; fillCell(x,y); ctx.globalAlpha=1; }
      const eg=eraseGlow[i]; if(eg>0.01){ ctx.globalAlpha=Math.min(0.45, eg*0.45); ctx.fillStyle='hsl(0,80%,80%)'; fillCell(x,y); ctx.globalAlpha=1; }
    }
  }

  // density dropdown (header + optional panel)
  drawDensityHeader();
  if(densOpen) drawDensityPanel();

  // strict no-draw border at header top
  const yDiv = (noDrawBorderPxTop|0);
  ctx.fillStyle='rgba(255,255,255,0.25)';
  ctx.fillRect(0, yDiv, W, Math.max(1, Math.round(DPR)));

  // picker bars + white icons over them
  drawPicker();

  // topmost brush preview ring
  drawPreviewSpot();

  // sticky pick indicator label
  if (picking) drawPickIndicator(picking.x, picking.readout);
  else if (lastPick && nowTS<lastPick.until) drawPickIndicator(lastPick.x, lastPick.readout);
}

function drawDensityHeader(){
  // header background
  for(let y=densHeaderY0;y<=densHeaderY1;y++){
    for(let x=0;x<COLS;x++){ ctx.fillStyle='hsl(220,12%,28%)'; fillCell(x,y); }
  }
  // left mini grid icon
  const cx = Math.max(2, Math.floor(COLS*0.02));
  drawMiniGridIcon((cx*CELL)|0, (Math.floor((densHeaderY0+densHeaderY1)/2)*CELL)|0, Math.max(8,Math.floor(CELL*3)), true);

  // chevron hitbox (48x48 CSS px, DPR-scaled)
  const rx = Math.floor(COLS*0.95); const cy = Math.floor((densHeaderY0+densHeaderY1)/2);
  CHEVRON_CX_DPX = rx*CELL; CHEVRON_CY_DPX = cy*CELL;
  const half = Math.round((TOUCH_MIN_PX * DPR) / 2);
  CHEVRON_HIT = { x0: CHEVRON_CX_DPX - half, x1: CHEVRON_CX_DPX + half, y0: CHEVRON_CY_DPX - half, y1: CHEVRON_CY_DPX + half };

  // chevron visual (DPR-fixed, independent of CELL)
  ctx.strokeStyle='rgba(255,255,255,0.9)';
  ctx.lineWidth=uiLine(2);
  const cheW = uiPx(24), cheH = uiPx(14);
  if(!densOpen){ // down
    ctx.beginPath();
    ctx.moveTo(CHEVRON_CX_DPX - cheW/2, CHEVRON_CY_DPX - cheH/2);
    ctx.lineTo(CHEVRON_CX_DPX,           CHEVRON_CY_DPX + cheH/2);
    ctx.lineTo(CHEVRON_CX_DPX + cheW/2,  CHEVRON_CY_DPX - cheH/2);
    ctx.stroke();
  }else{ // up
    ctx.beginPath();
    ctx.moveTo(CHEVRON_CX_DPX - cheW/2, CHEVRON_CY_DPX + cheH/2);
    ctx.lineTo(CHEVRON_CX_DPX,           CHEVRON_CY_DPX - cheH/2);
    ctx.lineTo(CHEVRON_CX_DPX + cheW/2,  CHEVRON_CY_DPX + cheH/2);
    ctx.stroke();
  }

  // current density label bar
  const labelW = Math.min(W*0.35, 160*DPR), labelH = Math.max(CELL*1.6, 16);
  const lx = Math.min(W - labelW - 6, Math.max(6, W*0.5 - labelW*0.5));
  const ly = (densHeaderY0*CELL) + Math.max(2, (densHeaderY1-densHeaderY0)*CELL*0.2);
  ctx.fillStyle='rgba(15,20,32,0.92)'; ctx.fillRect(lx,ly,labelW,labelH);
  ctx.fillStyle='rgba(200,210,255,0.9)'; ctx.fillRect(lx,ly, Math.min(labelW*0.4,70), labelH);
}

function drawDensityPanel(){
  // density items background
  for(let y=densPanelY0;y<=densPanelY1;y++){
    for(let x=0;x<COLS;x++){ ctx.fillStyle='hsl(220,12%,20%)'; fillCell(x,y); }
  }
  const items=densitiesLayout();
  for(let i=0;i<items.length;i++){
    const it=items[i];
    // button bg
    for(let y=it.y0;y<=it.y1;y++){
      for(let x=1;x<COLS-1;x++){ ctx.fillStyle=(i===densHoverIdx)?'hsl(220,14%,30%)':'hsl(220,12%,24%)'; fillCell(x,y); }
    }
    // preview miniature grid using actual device px size
    const pxSize=Math.round(it.val*DPR);
    const wpx=(COLS-4)*CELL, hpx=(it.y1-it.y0+1)*CELL;
    const cols=Math.max(1,Math.floor(wpx/pxSize));
    const rows=Math.max(1,Math.floor(hpx/pxSize));
    const x0px=2*CELL, y0px=it.y0*CELL;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const on=((r+c)&1)===0;
        ctx.fillStyle= on?'hsl(210,12%,46%)':'hsl(210,14%,38%)';
        ctx.fillRect(x0px + c*pxSize + 1, y0px + r*pxSize + 1, Math.max(1,pxSize-2), Math.max(1,pxSize-2));
      }
    }
    if (it.val===cellCssPx){
      ctx.strokeStyle='rgba(255,255,255,0.9)';
      ctx.lineWidth=uiLine(2);
      ctx.strokeRect(1*CELL, it.y0*CELL, (COLS-2)*CELL, (it.y1-it.y0+1)*CELL);
    }
  }

  // rate control bar
  drawRatePanel();
}

function drawRatePanel(){
  // background band
  for(let y=rateY0; y<=rateY1; y++){
    for(let x=0; x<COLS; x++){
      ctx.fillStyle='hsl(220,12%,22%)';
      fillCell(x,y);
    }
  }

  // compute a centered segmented row in device px
  const bandX0 = 1*CELL, bandX1 = (COLS-1)*CELL;
  const bandY0 = rateY0*CELL, bandY1 = (rateY1+1)*CELL;
  const bandW  = bandX1 - bandX0, bandH = bandY1 - bandY0;

  // segment geometry
  const gaps = Math.max(3, Math.floor(6*DPR));
  const segW = Math.floor((bandW - gaps*(RATE_OPTIONS.length+1)) / RATE_OPTIONS.length);
  const segH = Math.max(Math.floor(bandH*0.7), Math.floor(28*DPR));
  const segY = Math.floor(bandY0 + (bandH - segH)/2);

  // draw segments
  for(let i=0;i<RATE_OPTIONS.length;i++){
    const x = Math.floor(bandX0 + gaps + i*(segW+gaps));
    const y = segY;
    const w = segW, h = segH;

    const selected = (stepMs === RATE_OPTIONS[i].ms);
    ctx.fillStyle = selected ? 'hsl(220,18%,30%)' : 'hsl(220,12%,26%)';
    ctx.fillRect(x,y,w,h);

    ctx.strokeStyle='rgba(255,255,255,0.65)';
    ctx.lineWidth=Math.max(1, Math.floor(1.2*DPR));
    ctx.strokeRect(x,y,w,h);

    // label chip (visual weight only, no text)
    const chipW = Math.max(Math.floor(w*0.42), Math.floor(64*DPR));
    ctx.fillStyle='rgba(200,210,255,0.9)';
    ctx.fillRect(x,y, chipW, h);
  }
}

function rateSegmentsLayout(){
  if (!densOpen) return [];
  const bandX0 = 1*CELL, bandX1 = (COLS-1)*CELL;
  const bandY0 = rateY0*CELL, bandY1 = (rateY1+1)*CELL;
  const bandW  = bandX1 - bandX0, bandH = bandY1 - bandY0;

  const gaps = Math.max(3, Math.floor(6*DPR));
  const segW = Math.floor((bandW - gaps*(RATE_OPTIONS.length+1)) / RATE_OPTIONS.length);
  const segH = Math.max(Math.floor(bandH*0.7), Math.floor(28*DPR));
  const segY = Math.floor(bandY0 + (bandH - segH)/2);

  const out=[];
  for(let i=0;i<RATE_OPTIONS.length;i++){
    const x = Math.floor(bandX0 + gaps + i*(segW+gaps));
    out.push({x0:x, y0:segY, x1:x+segW, y1:segY+segH, ms: RATE_OPTIONS[i].ms});
  }
  return out;
}
function chooseRateAt(px,py){
  const segs = rateSegmentsLayout();
  for(const s of segs){
    if (px>=s.x0 && px<=s.x1 && py>=s.y0 && py<=s.y1){
      stepMs = s.ms;
      return;
    }
  }
}

// Picker drawing with icons
function drawPicker(){
  // Life (left big)
  for(let y=pickY0;y<=pickY1;y++){
    const r01=(y-pickY0)/Math.max(1,(pickY1-pickY0));
    for(let x=0;x<pickLifeEnd;x++){
      const t=x/Math.max(1,pickLifeEnd-1);
      const H=195+15*t, S=20+70*t, L=28+20*(1-Math.abs(r01-0.5)*2);
      ctx.fillStyle=`hsl(${H},${S}%,${L}%)`; fillCell(x,y);
    }
  }
  // Wall (next big)
  for(let y=pickY0;y<=pickY1;y++){
    for(let x=pickLifeEnd;x<pickWallEnd;x++){
      const t=(x-pickLifeEnd)/Math.max(1,(pickWallEnd-pickLifeEnd-1));
      let col; if(t<0.5){const k=t/0.5; col=mixHSL([320,90,50],[220,10,55],k);}
      else if(t<0.85){const k=(t-0.5)/0.35; col=mixHSL([220,10,55],[150,65,50],k);}
      else {const k=(t-0.85)/0.15; col=mixHSL([150,65,50],[210,4,40],k);}
      ctx.fillStyle=`hsl(${col[0]},${col[1]}%,${col[2]}%)`; fillCell(x,y);
    }
  }
  // Nutrient (small)
  for(let y=pickY0;y<=pickY1;y++){
    for(let x=pickWallEnd;x<pickNutrEnd;x++){
      const r01=(y-pickY0)/Math.max(1,(pickY1-pickY0));
      ctx.fillStyle=`hsl(${36},85%,${45+12*(1-Math.abs(r01-0.5)*2)}%)`; fillCell(x,y);
    }
  }
  // Erase (small)
  for(let y=pickY0;y<=pickY1;y++){
    for(let x=pickNutrEnd;x<pickEraseEnd;x++){
      const r01=(y-pickY0)/Math.max(1,(pickY1-pickY0));
      ctx.fillStyle=`hsl(6,85%,${48+10*(1-Math.abs(r01-0.5)*2)}%)`; fillCell(x,y);
    }
  }

  // top border line of picker
  ctx.globalAlpha=0.28; ctx.fillStyle='hsl(220,10%,35%)';
  ctx.fillRect(0,(pickY0*CELL)|0, W, 1); ctx.globalAlpha=1;

  // White grid icons over areas (centered), fixed DPR-based sizes
  drawBrushIcons();
}

function mixHSL(a,b,k){ return [(a[0]*(1-k)+b[0]*k+360)%360, a[1]*(1-k)+b[1]*k, a[2]*(1-k)+b[2]*k]; }

// Simple glyphs
function drawBrushIcons(){
  const cy = Math.floor((pickY0+pickY1)/2)*CELL + CELL*0.5;

  const lifeSz  = iconSizeFixedPx(28);
  const wallSz  = iconSizeFixedPx(32);
  const dotSz   = iconSizeFixedPx(24);
  const eraseSz = iconSizeFixedPx(24);

  // Life icon: small plus/grid spark
  drawMiniGridIcon(Math.floor((pickLifeEnd*CELL)*0.5),                       cy, lifeSz,  false);

  // Wall icon: small white rounded rectangle / brick
  drawBrickIcon   (Math.floor(((pickLifeEnd+pickWallEnd)*CELL)*0.5),          cy, wallSz);

  // Nutrient icon: three dots
  drawDotsIcon    (Math.floor(((pickWallEnd+pickNutrEnd)*CELL)*0.5),          cy, dotSz);

  // Erase icon: red tiny grid cross
  drawRedXIcon    (Math.floor(((pickNutrEnd+pickEraseEnd)*CELL)*0.5),         cy, eraseSz);
}

function drawMiniGridIcon(cx,cy,sz,withBorder){
  const s=Math.max(2,Math.floor(sz/4));
  const w=s*3, h=s*3;
  const x=cx - w/2, y=cy - h/2;
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const on=((r===1)||(c===1)); // plus shape
      ctx.fillStyle= on?'rgba(255,255,255,0.9)':'rgba(255,255,255,0.22)';
      ctx.fillRect(x + c*s + 1, y + r*s + 1, Math.max(1,s-2), Math.max(1,s-2));
    }
  }
  if (withBorder){
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth = lineWidthFromSize(sz, 0.16);
    ctx.strokeRect(x, y, w, h);
  }
}
function drawBrickIcon(cx,cy,sz){
  const w=sz*1.6, h=sz;
  const x=cx-w/2, y=cy-h/2;
  ctx.strokeStyle='rgba(255,255,255,0.9)';
  ctx.lineWidth = lineWidthFromSize(sz, 0.18);
  ctx.strokeRect(x,y,w,h);
  // inner mortar lines
  ctx.beginPath();
  ctx.moveTo(x, y+h/2); ctx.lineTo(x+w, y+h/2);
  ctx.moveTo(x+w/3, y); ctx.lineTo(x+w/3, y+h/2);
  ctx.moveTo(x+(2*w/3), y+h/2); ctx.lineTo(x+(2*w/3), y+h);
  ctx.stroke();
}
function drawDotsIcon(cx,cy,sz){
  const r=Math.max(1,Math.floor(sz*0.18));
  ctx.fillStyle='rgba(255,255,255,0.92)';
  ctx.beginPath(); ctx.arc(cx - sz*0.35, cy, r, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + sz*0.35, cy, r, 0, Math.PI*2); ctx.fill();
}
function drawRedXIcon(cx,cy,sz){
  ctx.strokeStyle='rgba(220,60,60,0.95)';
  ctx.lineWidth = lineWidthFromSize(sz, 0.18);
  const d=sz*0.6;
  ctx.beginPath(); ctx.moveTo(cx-d,cy-d); ctx.lineTo(cx+d,cy+d); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx+d,cy-d); ctx.lineTo(cx-d,cy+d); ctx.stroke();
}

// Preview ring (topmost)
function drawPreviewSpot(){
  const cx = picking ? Math.min(COLS-1, Math.max(0,(picking.x/CELL)|0))
    : (brushMode==='seed' ? Math.floor(pickLifeEnd/2)
      : brushMode==='barrier' ? Math.floor((pickLifeEnd+pickWallEnd)/2)
      : brushMode==='nutrient' ? Math.floor((pickWallEnd+pickNutrEnd)/2)
      : Math.floor((pickNutrEnd+pickEraseEnd)/2));
  const py = Math.max(0, noDrawBorderPxTop - Math.round(8*DPR));
  const px = cx*CELL + CELL*0.5;
  const r = 2.6*CELL*params.brushRadius;

  ctx.globalAlpha=1;
  ctx.strokeStyle='rgba(255,255,255,0.95)';
  ctx.lineWidth=Math.max(1,Math.floor(CELL*0.6));
  ctx.beginPath(); ctx.arc(px,py, r, 0, Math.PI*2); ctx.stroke();
}

// pick indicator chip (very light)
function drawPickIndicator(px, readout){
  const label = readout[0]||'';
  const w = Math.min(W*0.5, Math.max(120, label.length*10))*0.55;
  const x = Math.min(W-w-8, Math.max(8, px - w/2));
  const y = (pickY0*CELL) - Math.max(18, CELL*2) - 6;
  const h = Math.max(16, CELL*1.6);
  ctx.fillStyle='rgba(15,20,32,0.92)'; ctx.fillRect(x,y,w,h);
  ctx.fillStyle='rgba(200,210,255,0.9)'; ctx.fillRect(x,y, Math.min(70,w*0.4), h);
}

// ===== loop =====
let lastT = performance.now();
let acc = 0;

function tick(now){
  const dt = Math.min(50, now - lastT);
  lastT = now; nowTS = now;
  acc += dt;

  const MAX_STEPS = 4;

  if (stepMs === 0){
    // ASAP: one step with all accumulated time
    const chunk = acc; acc = 0;
    step(chunk);
  } else {
    let steps = 0;
    while (acc >= stepMs && steps < MAX_STEPS){
      step(stepMs);
      acc -= stepMs;
      steps++;
    }
  }

  render();
  requestAnimationFrame(tick);
}

// ===== utils for chevron hitbox =====
// (pointInRect defined above)

// ===== init =====
applyGrid();
addEventListener('resize', ()=>{ applyGrid(); }, {passive:true});
cv.addEventListener('gesturestart', e=>e.preventDefault(), {passive:false});
requestAnimationFrame(tick);

})();
</script>
</body>
</html>