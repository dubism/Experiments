<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover,user-scalable=no" />
<title>Grid Â· Picker + Speed Toggle (Touch-solid, 120px cap)</title>
<style>
  :root{
    --bg:#0b0c0e;
    --grid-dim:#0e1217;
    --grid-bright:#141a23;
  }
  html,body{height:100%}
  body{
    margin:0;background:var(--bg);overflow:hidden;
    overscroll-behavior:none;                 /* stop rubber-band from stealing taps */
    -webkit-user-select:none;user-select:none;
    -webkit-touch-callout:none;
  }
  canvas{
    display:block;width:100vw;height:100vh;
    touch-action:none;                         /* we fully handle gestures */
    -webkit-tap-highlight-color:transparent;
  }
  #sab{position:fixed;bottom:0;left:0;width:0;height:env(safe-area-inset-bottom);pointer-events:none;opacity:0}
</style>
</head>
<body>
<canvas id="cv"></canvas>
<div id="sab" aria-hidden="true"></div>

<script>
(()=>{
/* ========================= setup ========================= */
const cv=document.getElementById('cv');
const ctx=cv.getContext('2d',{alpha:false,desynchronized:true});
const DPR=Math.max(1,Math.min(devicePixelRatio||1,2));
const sabProbe=document.getElementById('sab');

let W=0,H=0,CELL=0,COLS=0,ROWS=0,N=0;

// Densities (CSS px per cell)
const DENSITY_CHOICES=[2,3,4,6,8,12,16];
let cellCssPx=DENSITY_CHOICES[0];

// world params
const params={
  lifeFertility:1.2,
  lifeResilience:0.3,
  lifeSpread:1.4,
  lifeMortality:0.5,
  brushRadius:1.1,
  stoneFormSec:2.0,
  wallBombPct:0.08,
  wallBoostPct:0.08
};
const WALL_TOXICITY=0.25;
let brushMode='seed'; // 'seed'|'barrier'|'nutrient'|'erase'

/* ========================= state ========================= */
let alive,nextAlive,blink,field,hueX,hueY;
let forming,stoneProg,stoneJit,stoneFlag,stoneHP,wallType;
let nutrient,nutBoost,nutFlash;
let poisonWave,nextPoisonWave,nutWave,nextNutWave;
let boostFlash,eraseGlow;
const emitters=[];

function alloc(){
  alive=new Uint8Array(N); nextAlive=new Uint8Array(N); blink=new Float32Array(N);
  field=new Float32Array(N); hueX=new Float32Array(N); hueY=new Float32Array(N);
  forming=new Uint8Array(N); stoneProg=new Float32Array(N); stoneJit=new Float32Array(N);
  stoneFlag=new Uint8Array(N); stoneHP=new Float32Array(N); wallType=new Uint8Array(N);
  nutrient=new Float32Array(N); nutBoost=new Uint8Array(N); nutFlash=new Uint8Array(N);
  poisonWave=new Uint8Array(N); nextPoisonWave=new Uint8Array(N);
  nutWave=new Uint8Array(N); nextNutWave=new Uint8Array(N);
  boostFlash=new Float32Array(N); eraseGlow=new Float32Array(N);
  emitters.length=0;
}

/* ========================= grid pattern ========================= */
let gridPattern=null, GRID_DIM=null;
function cssVar(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}
function buildGridPattern(){
  const s=CELL, p=document.createElement('canvas'); p.width=p.height=2*s;
  const g=p.getContext('2d');
  GRID_DIM=cssVar('--grid-dim'); const bright=cssVar('--grid-bright');
  g.fillStyle=GRID_DIM; g.fillRect(0,0,2*s,2*s);
  g.fillStyle=bright; g.fillRect(0,0,s,s); g.fillRect(s,s,s,s);
  gridPattern=ctx.createPattern(p,'repeat');
}

/* ========================= sizing ========================= */
function applyGrid(){
  W=Math.floor(innerWidth*DPR); H=Math.floor(innerHeight*DPR);
  cv.width=W; cv.height=H; cv.style.width='100vw'; cv.style.height='100vh';
  CELL=Math.max(2, Math.round(cellCssPx*DPR));
  COLS=(W/CELL)|0; ROWS=(H/CELL)|0; N=COLS*ROWS;
  alloc(); buildGridPattern(); computeUI(); buildUiRects();
}

/* ========================= UI layout ========================= */
/* visual intentions in CSS pixels; tap rects are computed in device pixels */
const PICKER_PX = 120;      // requested picker stripe height (we cap it strictly below)
const UI_SPACER_PX = 8;
const DENS_HEADER_PX = 44;
const DENS_PANEL_PX  = 140;

/* hard cap for bottom stripe INCLUDING safe-area */
const BOTTOM_STRIPE_MAX_PX = 120;
let STRIPE_MAX_DPX = 0;

const TOUCH_MIN_PX = 48;

/* rows for drawing; rects for tapping */
let densHeaderY0=0,densHeaderY1=0;
let densPanelY0=0,densPanelY1=0, densOpen=false;
let pickY0=0,pickY1=0;
let pickLifeEnd=0,pickWallEnd=0,pickNutrEnd=0,pickEraseEnd=0;

let noDrawBorderPxTop=0;

/* speed toggle */
const RATE_PANEL_PX = 48;
const RATE_OPTIONS = [
  {label:'ASAP', ms:0},
  {label:'20ms', ms:20},
  {label:'50ms', ms:50},
  {label:'200ms',ms:200}
];
let stepMs = 50;
let rateY0=0, rateY1=0;
let rateFlashUntil=0;

/* device-px rects (tap hitboxes) */
let RECT_HEADER=null, RECT_PANEL=null, RECT_PANEL_BAND=null, RECT_PICKER=null, RECT_RATE=null, CHEVRON_HIT=null;

function safeBottomCssPx(){ return sabProbe.getBoundingClientRect().height||0; }
function rowsFromPx(px){ return Math.max(2, Math.ceil((px*DPR)/CELL)); }
function uiPx(px){ return Math.floor(px*DPR); }
function uiLine(px){ return Math.max(1, Math.floor(px*DPR)); }

function computeUI(){
  const insetCss = safeBottomCssPx(); // CSS px
  // picker stripe visible height + inset <= 120 px; also keep at least 48px for ergonomics
  const effectivePickerPx = Math.max(48, Math.min(PICKER_PX, BOTTOM_STRIPE_MAX_PX - insetCss));
  const PICK_ROWS = rowsFromPx(effectivePickerPx);

  const HEADER_ROWS = rowsFromPx(Math.max(DENS_HEADER_PX, TOUCH_MIN_PX));
  const SPACER_ROWS = rowsFromPx(UI_SPACER_PX);

  // bottom reserved rows ONLY for safe-area
  const reservedBottomRows = Math.ceil(((insetCss)*DPR)/Math.max(1,CELL));

  // bottom-up
  pickY1=ROWS-1-reservedBottomRows;
  pickY0=Math.max(0, pickY1 - PICK_ROWS + 1);

  const spacerY1=Math.max(0, pickY0 - 1);
  const spacerY0=Math.max(0, spacerY1 - SPACER_ROWS + 1);

  densPanelY1 = Math.max(0, spacerY0 - 1);

  if (densOpen){
    const RATE_ROWS = rowsFromPx(RATE_PANEL_PX);
    rateY1 = densPanelY1;
    rateY0 = Math.max(0, rateY1 - RATE_ROWS + 1);
    densPanelY0 = Math.max(0, rateY0 - 1 - rowsFromPx(DENS_PANEL_PX) + 1);
    if (densPanelY0 > rateY0 - 1) densPanelY0 = Math.max(0, rateY0 - 1);
  } else {
    densPanelY0 = densPanelY1 + 1;
    rateY0 = rateY1 = densPanelY1 + 1;
  }

  densHeaderY1 = densOpen ? Math.max(0, densPanelY0 - 1) : Math.max(0, spacerY0 - 1);
  densHeaderY0 = Math.max(0, densHeaderY1 - HEADER_ROWS + 1);

  noDrawBorderPxTop = densHeaderY0*CELL;

  // picker partitions
  const totalUnits=8;
  const lifeUnits=3, wallUnits=3, nutrUnits=1, eraseUnits=1;
  const unitCols = Math.max(1, Math.floor(COLS/totalUnits));
  pickLifeEnd  = lifeUnits*unitCols;
  pickWallEnd  = pickLifeEnd + wallUnits*unitCols;
  pickNutrEnd  = pickWallEnd + nutrUnits*unitCols;
  pickEraseEnd = COLS;

  STRIPE_MAX_DPX = Math.round(BOTTOM_STRIPE_MAX_PX * DPR);
}

function buildUiRects(){
  RECT_HEADER = {x0:0, x1:W, y0:densHeaderY0*CELL,      y1:(densHeaderY1+1)*CELL};
  RECT_PANEL  = densOpen ? {x0:0, x1:W, y0:densPanelY0*CELL, y1:(densPanelY1+1)*CELL} : null;
  RECT_PICKER = {x0:0, x1:W, y0:pickY0*CELL,            y1:(pickY1+1)*CELL};
  // large chevron zone = right 50% of header
  CHEVRON_HIT = {x0:Math.floor(W*0.5), x1:W, y0:RECT_HEADER.y0, y1:RECT_HEADER.y1};
  // rate button rect (exists only when open)
  RECT_RATE   = densOpen ? rateButtonRect() : null;
}

/* ========================= picker mapping ========================= */
function lerp(a,b,t){return a*(1-t)+b*t;}
const lerp2=(a,b,k)=>[ lerp(a[0],b[0],k), lerp(a[1],b[1],k) ];
function wallMixFrom(t){
  if(t<=0.5){const k=t/0.5; return lerp2([0.30,0.00],[0.15,0.15],k);}
  if(t<=0.85){const k=(t-0.5)/0.35; return lerp2([0.15,0.15],[0.00,0.30],k);}
  const k=(t-0.85)/0.15; return lerp2([0.00,0.30],[0.00,0.00],k);
}

let picking=null, lastPick=null, nowTS=performance.now();

/* ========================= events: pointer-only ========================= */
function toDevPx(e){
  const r=cv.getBoundingClientRect();
  const x=e.clientX, y=e.clientY;
  return {x:(x-r.left)*DPR, y:(y-r.top)*DPR};
}
const TAP_SLOP_PX = 12;
let press = null; // {kind:'chevron'|'rate'|'panel'|'picker', x0,y0}

function beginPress(kind, p){ press={kind, x0:p.x, y0:p.y}; }
function cancelPress(){ press=null; }
function isTap(p){ return press && Math.hypot(p.x-press.x0, p.y-press.y0) <= (TAP_SLOP_PX*DPR); }

const drawState = { drawing:false, lastX:0,lastY:0 };

cv.addEventListener('pointerdown', (e)=>{
  e.preventDefault(); cv.setPointerCapture?.(e.pointerId);
  const p=toDevPx(e);

  // header chevron
  if (inRect(p, CHEVRON_HIT)){ beginPress('chevron', p); return; }
  // rate button
  if (densOpen && RECT_RATE && inRect(p, RECT_RATE)){ beginPress('rate', p); return; }
  // density panel (grid size)
  if (densOpen && RECT_PANEL && inRect(p, RECT_PANEL)){
    beginPress('panel', p); chooseDensityAt(p.x,p.y); return;
  }
  // picker stripe
  if (inRect(p, RECT_PICKER)){ beginPress('picker', p); applyPick(p.x,p.y); return; }
  // drawing canvas
  if (p.y<noDrawBorderPxTop){
    drawState.drawing=true; drawState.lastX=p.x; drawState.lastY=p.y;
    deposit(p.x,p.y,0,0,true);
  }
}, {passive:false});

cv.addEventListener('pointermove', (e)=>{
  const p=toDevPx(e);

  // cancel press if moved out
  if (press && !isTap(p)) cancelPress();

  if (press && press.kind==='panel' && densOpen && RECT_PANEL && inRect(p, RECT_PANEL)){
    chooseDensityAt(p.x,p.y); // hover-follow
  }
  if (press && press.kind==='picker' && inRect(p, RECT_PICKER)){
    applyPick(p.x,p.y);
  }

  if (drawState.drawing){
    if (p.y>=noDrawBorderPxTop){ drawState.drawing=false; return; }
    const vx=p.x-drawState.lastX, vy=p.y-drawState.lastY;
    deposit(p.x,p.y,vx,vy,false);
    drawState.lastX=p.x; drawState.lastY=p.y;
  }
}, {passive:false});

cv.addEventListener('pointerup', (e)=>{
  const p=toDevPx(e);
  if (press && isTap(p)){
    if (press.kind==='chevron'){ toggleDensityOpen(); }
    if (press.kind==='rate'){ nextRate(); }
  }
  cancelPress();
  drawState.drawing=false; picking=null;
}, {passive:false});

cv.addEventListener('pointercancel', ()=>{
  cancelPress(); drawState.drawing=false; picking=null;
}, {passive:false});

function inRect(p, r){ return r && p.x>=r.x0 && p.x<=r.x1 && p.y>=r.y0 && p.y<=r.y1; }

/* ========================= density header / panel ========================= */
let densHoverIdx=-1;
function toggleDensityOpen(){ densOpen=!densOpen; computeUI(); buildUiRects(); }
function densitiesLayout(){
  if(!densOpen) return [];
  const rows = densPanelY1-densPanelY0+1;
  const items = DENSITY_CHOICES.length;
  const per = Math.max(2, Math.floor(rows/items));
  const out=[];
  let y=densPanelY0;
  for(let i=0;i<items;i++){
    const y0=y, y1=Math.min(densPanelY1, y+per-1);
    out.push({y0,y1,val:DENSITY_CHOICES[i]});
    y=y1+1;
  }
  return out;
}
function chooseDensityAt(px,py){
  const cy=(py/CELL)|0; const items=densitiesLayout();
  for(let i=0;i<items.length;i++){
    const it=items[i];
    if(cy>=it.y0 && cy<=it.y1){
      densHoverIdx=i;
      if (cellCssPx!==it.val){ cellCssPx=it.val; applyGrid(); } // re-layout and rebuild rects inside
      return;
    }
  }
}

/* ========================= picker behavior ========================= */
function applyPick(px,py){
  const cx=(px/CELL)|0;
  let readout=[], t=0;

  if (cx < pickLifeEnd){
    brushMode='seed';
    t = Math.min(1, Math.max(0, cx/Math.max(1,pickLifeEnd-1)));
    params.lifeFertility=lerp(0.6,3.0,t);
    params.lifeResilience=lerp(0.0,1.0,t);
    params.lifeSpread=lerp(0.8,2.5,t);
    params.lifeMortality=lerp(0.70,0.12,t);
    readout=[`LIFE`];
  } else if (cx < pickWallEnd){
    brushMode='barrier';
    t = Math.min(1, Math.max(0, (cx-pickLifeEnd)/Math.max(1,(pickWallEnd-pickLifeEnd-1))));
    const [bomb,boost]=wallMixFrom(t);
    params.wallBombPct=bomb; params.wallBoostPct=boost;
    readout=[`WALLS`];
  } else if (cx < pickNutrEnd){
    brushMode='nutrient'; readout=[`NUTRITION`];
  } else {
    brushMode='erase'; readout=[`ERASE`];
  }
  picking={x:px,y:py,readout,mode:brushMode,t};
  lastPick={x:px, until:nowTS+700, readout};
}

/* ========================= emitters / physics ========================= */
function addEmitter(px,py,ang,energy,burst,canSpawn,colorMode){
  const mult=params.lifeSpread;
  for(let k=0;k<(burst||1);k++){
    const jitter=ang+(Math.random()-0.5)*0.5;
    const spd=(12+28*Math.min(1,energy)+Math.random()*6)*mult;
    const ttl=(900+1200*energy+Math.random()*400)/(1/Math.max(0.6,Math.min(2.5,mult)));
    emitters.push({x:px/CELL,y:py/CELL,dx:Math.cos(jitter)*spd,dy:Math.sin(jitter)*spd,ttl,canSpawn:!!canSpawn,colorMode:colorMode||0});
  }
  if(emitters.length>1600) emitters.splice(0, emitters.length-1600);
}
function radialBurst(cx,cy,rays,canSpawn=true,colorMode=0){
  const cxp=cx*CELL + CELL*0.5, cyp=cy*CELL + CELL*0.5;
  const r=rays||28;
  for(let i=0;i<r;i++){ const a=(i/r)*Math.PI*2; addEmitter(cxp,cyp,a,1,1,canSpawn,colorMode); }
}
function stepEmitters(dt){
  for(let i=emitters.length-1;i>=0;i--){
    const e=emitters[i]; e.ttl-=dt; if(e.ttl<=0){emitters.splice(i,1); continue;}
    const s=dt/1000; e.x+=e.dx*s; e.y+=e.dy*s;
    const ix=e.x|0, iy=e.y|0; if(ix<0||iy<0||ix>=COLS||iy>=ROWS){ emitters.splice(i,1); continue; }
    const id=iy*COLS+ix;
    if (stoneFlag[id]){
      const damp=-0.6;
      if(Math.abs(e.dx)>Math.abs(e.dy)){ e.dx*=damp; e.dy*=0.35; } else { e.dy*=damp; e.dx*=0.35; }
    } else if (e.canSpawn){ alive[id]=1; blink[id]=1.0; }
    if (e.colorMode===2){ eraseGlow[id]=Math.max(eraseGlow[id],1.0); }
  }
}

function deposit(px,py,vx,vy,initial){
  if(py>=noDrawBorderPxTop) return;
  const sp=Math.hypot(vx,vy);
  const baseR=2.2*CELL*params.brushRadius;
  const r=baseR+Math.min(7*CELL*params.brushRadius, sp*1.0);
  const r2=r*r; const cx=(px/CELL)|0, cy=(py/CELL)|0; const rad=Math.ceil(r/CELL);
  const dirAng=Math.atan2(vy, vx||1e-6);
  if((initial || sp>0.6*CELL)){
    if(brushMode==='seed') addEmitter(px,py,dirAng,Math.min(1,sp/(2.0*CELL)),1,true,0);
    if(brushMode==='erase')addEmitter(px,py,dirAng,Math.min(1,sp/(2.0*CELL)),2,false,2);
  }
  for(let yy=cy-rad; yy<=cy+rad; yy++){
    if(yy<0||yy>=ROWS) continue;
    if (yy*CELL + CELL*0.5 >= noDrawBorderPxTop) continue;
    for(let xx=cx-rad; xx<=cx+rad; xx++){
      if(xx<0||xx>=COLS) continue;
      const gx=xx*CELL + CELL*0.5, gy=yy*CELL + CELL*0.5;
      const dx=gx-px, dy=gy-py; const d2=dx*dx+dy*dy; if(d2>r2) continue;
      const i=yy*COLS+xx;
      const sigma=r*0.5; const fall=Math.exp(-d2/(2*sigma*sigma));
      const amp=fall*(1+Math.min(1, sp/(1.6*CELL)));

      if (brushMode==='seed'){
        field[i]=Math.max(field[i], amp*0.9);
        const ang=Math.atan2(dy,dx); hueX[i]+=Math.cos(ang)*amp; hueY[i]+=Math.sin(ang)*amp;
        if(!alive[i] && Math.random()<amp*0.9){ alive[i]=1; blink[i]=1.0; }
      } else if (brushMode==='barrier'){
        if(!stoneFlag[i]){
          if(!forming[i]){
            forming[i]=1; stoneJit[i]=0.9+Math.random()*0.2;
            const r1=Math.random(); wallType[i]=0;
            if(r1<params.wallBombPct) wallType[i]=1; else if(r1<params.wallBombPct+params.wallBoostPct) wallType[i]=2;
          }
          stoneProg[i]=Math.min(1, stoneProg[i]+amp*0.05);
        }
        nutrient[i]=0; if(nutBoost[i]){nutBoost[i]=0;nutFlash[i]=0;}
      } else if (brushMode==='nutrient'){
        nutrient[i]=Math.min(1, nutrient[i]+amp*0.9);
      } else {
        alive[i]=0; nextAlive[i]=0; blink[i]=0;
        nutrient[i]=0; nutBoost[i]=0; nutFlash[i]=0;
        poisonWave[i]=0; nutWave[i]=0;
        forming[i]=0; stoneFlag[i]=0; stoneHP[i]=0; stoneProg[i]=0; wallType[i]=0;
        eraseGlow[i]=Math.max(eraseGlow[i],0.2+0.8*amp);
      }
    }
  }
}

/* ========================= sim ========================= */
function step(dt){
  const tick=dt;

  const seedFade=Math.exp(-tick/180);
  for(let i=0;i<N;i++){
    field[i]*=seedFade; hueX[i]*=seedFade; hueY[i]*=seedFade;
    blink[i]*=Math.exp(-tick/90);
    if(nutFlash[i]>0)   nutFlash[i]=Math.max(0,nutFlash[i]-tick);
    if(boostFlash[i]>0) boostFlash[i]=Math.max(0,boostFlash[i]-tick);
    if(eraseGlow[i]>0)  eraseGlow[i]*=Math.exp(-tick/200);
  }

  for(let i=0;i<N;i++){
    if(forming[i] && !stoneFlag[i]){
      stoneProg[i]+=(1/(params.stoneFormSec*1000))*(stoneJit[i]||1)*tick;
      if(stoneProg[i]>=1){ stoneProg[i]=1; forming[i]=0; stoneFlag[i]=1; stoneHP[i]=1; }
    }
  }

  stepEmitters(tick);

  nextPoisonWave.fill(0); nextNutWave.fill(0);
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const i=y*COLS+x;
      const pS=poisonWave[i]; if(pS>0){
        const s=pS-1;
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
          if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
          if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
          const j=yy*COLS+xx; if(stoneFlag[j])continue;
          if(nextPoisonWave[j]<s) nextPoisonWave[j]=s;
        }
      }
      const nS=nutWave[i]; if(nS>0){
        const s=nS-1;
        for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
          if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
          if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
          const j=yy*COLS+xx; if(stoneFlag[j])continue;
          if(nextNutWave[j]<s) nextNutWave[j]=s;
        }
      }
    }
  }
  for(let i=0;i<N;i++){
    poisonWave[i]=Math.max(0, Math.max(poisonWave[i]-1, nextPoisonWave[i]));
    nutWave[i]=Math.max(0, Math.max(nutWave[i]-1, nextNutWave[i]));
    if(nutWave[i]>0) nutrient[i]=Math.min(1, nutrient[i]+0.25);
  }

  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const i=y*COLS+x; if(stoneFlag[i]){ nextAlive[i]=0; continue; }
      const a=alive[i];
      let n=0,nearBarrier=false;
      for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
        if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
        if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
        const j=yy*COLS+xx; const isB=stoneFlag[j]||forming[j];
        n+=alive[j]*(isB?0.25:1.0); if(isB) nearBarrier=true;
      }
      const nut=nutrient[i], waveP=poisonWave[i];
      let born=(!a)&&(n===3);
      let survive=(a)&&(n===2||n===3);
      if(!a && n===2){
        const fert=0.08*(Math.max(0,params.lifeFertility-1))*(0.6+0.8*nut);
        if(Math.random()<fert) born=true;
      }
      if(a && n===4){
        const res=0.5*params.lifeResilience*(0.6+0.8*nut);
        if(Math.random()<res) survive=true;
      }
      let dead=false;
      if(a && nearBarrier){
        const p=WALL_TOXICITY*(0.8-0.5*nut); if(Math.random()<p) dead=true;
      }
      if(a && !dead && waveP>0) dead=true;
      if(a && !dead){
        const m=params.lifeMortality*0.16; if(Math.random()<m) dead=true;
      }
      nextAlive[i]= dead?0:(born?1:(survive?1:0));
      if(nextAlive[i]){
        blink[i]=1.0;
        if(nutrient[i]>0) nutrient[i]=Math.max(0, nutrient[i]-0.10);
        if(nutBoost[i]){ nutBoost[i]=0; nutFlash[i]=240; radialBurst(x,y,32,true,0); }
      }
    }
  }
  {const t=alive; alive=nextAlive; nextAlive=t;}

  const eatBase=0.06*params.lifeSpread*(1+0.6*Math.random());
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const i=y*COLS+x; if(!alive[i]) continue;
      for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
        if(!dx&&!dy)continue; const xx=x+dx,yy=y+dy;
        if(xx<0||yy<0||xx>=COLS||yy>=ROWS)continue;
        const j=yy*COLS+xx; if(!stoneFlag[j]) continue;
        stoneHP[j]-=eatBase;
        if(stoneHP[j]<=0){
          const t=wallType[j];
          stoneFlag[j]=0; stoneHP[j]=0; stoneProg[j]=0; forming[j]=0;
          if(t===1){
            boostFlash[j]=240; poisonWave[j]=Math.max(poisonWave[j],10);
            const r=8;
            for(let ddy=-1;ddy<=1;ddy++)for(let ddx=-1;ddx<=1;ddx++){
              if(!ddx&&!ddy)continue; const nx=xx+ddx, ny=yy+ddy;
              if(nx<0||ny<0||nx>=COLS||ny>=ROWS) continue;
              const id=ny*COLS+nx; if(!stoneFlag[id]) poisonWave[id]=Math.max(poisonWave[id],r);
            }
          } else if (t===2){
            boostFlash[j]=160; nutWave[j]=Math.max(nutWave[j],10); radialBurst(xx,yy,32,true,0);
            const R=4,R2=R*R;
            for(let iy=yy-R; iy<=yy+R; iy++){
              if(iy<0||iy>=ROWS) continue;
              for(let ix=xx-R; ix<=xx+R; ix++){
                if(ix<0||ix>=COLS) continue;
                const dx2=ix-xx,dy2=iy-yy; if(dx2*dx2+dy2*dy2>R2) continue;
                const id=iy*COLS+ix;
                if(stoneFlag[id]||forming[id]){ stoneFlag[id]=0; forming[id]=0; stoneHP[id]=0; stoneProg[id]=0; wallType[id]=0; nutrient[id]=Math.min(1,nutrient[id]+1); }
              }
            }
          } else {
            boostFlash[j]=160; radialBurst(xx,yy,20,true,0);
          }
          wallType[j]=0;
        }
      }
    }
  }
}

/* ========================= helpers ========================= */
function clamp(n, lo, hi){ return Math.max(lo, Math.min(hi, n)); }
function pickStripeHeightDPX(){ return Math.min(STRIPE_MAX_DPX, (pickY1 - pickY0 + 1) * CELL); }
function pickIconCapDPX(){ return pickStripeHeightDPX() * 0.6; }
function iconSizeFixedPx(cssPx){ return Math.min(uiPx(cssPx), Math.floor(pickIconCapDPX())); }
function lineWidthFromSize(sz, k){ return Math.max(1, Math.floor(sz * k)); }

/* ========================= render ========================= */
function fillCell(ix,iy){ ctx.fillRect(ix*CELL+1, iy*CELL+1, CELL-2, CELL-2); }

function render(){
  // grid
  ctx.fillStyle = gridPattern ? gridPattern : (GRID_DIM || '#0e1217');
  ctx.fillRect(0,0,W,H);

  // world
  for(let y=0;y<ROWS;y++){
    const off=y*COLS;
    for(let x=0;x<COLS;x++){
      const i=off+x;
      if(boostFlash[i]>0 || nutFlash[i]>0){ ctx.fillStyle='#fff176'; fillCell(x,y); continue; }
      if(stoneFlag[i]){ ctx.fillStyle='#8a93a0'; fillCell(x,y); continue; }
      const prog=stoneProg[i];
      if(prog>0){ ctx.fillStyle='hsl(210,0%,60%)'; ctx.globalAlpha=Math.min(1,0.15+0.85*prog); fillCell(x,y); ctx.globalAlpha=1; }
      if(poisonWave[i]>0){ ctx.globalAlpha=Math.min(0.45,0.06*poisonWave[i]); ctx.fillStyle='hsl(320,90%,50%)'; fillCell(x,y); ctx.globalAlpha=1; }
      const nut=nutrient[i];
      if(nut>0.02){ ctx.globalAlpha=Math.min(0.35,nut*0.35); ctx.fillStyle='#ff9a3c'; fillCell(x,y); ctx.globalAlpha=1; }
      if(nutWave[i]>0){ ctx.globalAlpha=Math.min(0.35,0.05*nutWave[i]); ctx.fillStyle='#ff9a3c'; fillCell(x,y); ctx.globalAlpha=1; }
      const f=field[i], a=alive[i];
      if(f>0.02 || a){
        const hx=hueX[i], hy=hueY[i];
        const H=(hx||hy)?(Math.atan2(hy,hx)*180/Math.PI+360)%360:200;
        const S=Math.min(100,60+Math.max(0,f)*40);
        const L=(18+(a?28:12)+Math.max(0,f)*60);
        ctx.fillStyle=`hsl(${H},${S}%,${Math.min(74,L)}%)`;
        fillCell(x,y);
      }
      const b=blink[i]; if(b>0.02){ ctx.globalAlpha=Math.min(0.22,b*0.22); ctx.fillStyle='#bfe2ff'; fillCell(x,y); ctx.globalAlpha=1; }
      const eg=eraseGlow[i]; if(eg>0.01){ ctx.globalAlpha=Math.min(0.45, eg*0.45); ctx.fillStyle='hsl(0,80%,80%)'; fillCell(x,y); ctx.globalAlpha=1; }
    }
  }

  drawDensityHeader();
  if(densOpen) drawDensityPanel();

  // strict no-draw border at header top
  ctx.fillStyle='rgba(255,255,255,0.25)';
  ctx.fillRect(0, (noDrawBorderPxTop|0), W, Math.max(1, Math.round(DPR)));

  drawPicker();
  drawPreviewSpot();

  if (picking) drawPickIndicator(picking.x, picking.readout);
  else if (lastPick && nowTS<lastPick.until) drawPickIndicator(lastPick.x, lastPick.readout);
}

function drawDensityHeader(){
  for(let y=densHeaderY0;y<=densHeaderY1;y++){
    for(let x=0;x<COLS;x++){ ctx.fillStyle='hsl(220,12%,28%)'; fillCell(x,y); }
  }
  // left mini grid icon
  const cx = Math.max(2, Math.floor(COLS*0.02));
  drawMiniGridIcon((cx*CELL)|0, (Math.floor((densHeaderY0+densHeaderY1)/2)*CELL)|0, Math.max(8,Math.floor(CELL*3)), true);

  // chevron visuals centered in its big hit zone
  const cX = Math.floor((CHEVRON_HIT.x0 + CHEVRON_HIT.x1)/2);
  const cY = Math.floor((CHEVRON_HIT.y0 + CHEVRON_HIT.y1)/2);
  if (press && press.kind==='chevron'){
    ctx.fillStyle='rgba(255,255,255,0.08)';
    ctx.fillRect(CHEVRON_HIT.x0, CHEVRON_HIT.y0, CHEVRON_HIT.x1-CHEVRON_HIT.x0, CHEVRON_HIT.y1-CHEVRON_HIT.y0);
  }
  ctx.strokeStyle='rgba(255,255,255,0.9)';
  ctx.lineWidth=uiLine(2);
  const cheW = uiPx(24), cheH = uiPx(14);
  ctx.beginPath();
  if(!densOpen){
    ctx.moveTo(cX - cheW/2, cY - cheH/2);
    ctx.lineTo(cX,            cY + cheH/2);
    ctx.lineTo(cX + cheW/2,   cY - cheH/2);
  }else{
    ctx.moveTo(cX - cheW/2, cY + cheH/2);
    ctx.lineTo(cX,            cY - cheH/2);
    ctx.lineTo(cX + cheW/2,   cY + cheH/2);
  }
  ctx.stroke();

  // density label bar (visual only)
  const labelW = Math.min(W*0.35, 160*DPR), labelH = Math.max(CELL*1.6, 16);
  const lx = Math.min(W - labelW - 6, Math.max(6, W*0.5 - labelW*0.5));
  const ly = (densHeaderY0*CELL) + Math.max(2, (densHeaderY1-densHeaderY0)*CELL*0.2);
  ctx.fillStyle='rgba(15,20,32,0.92)'; ctx.fillRect(lx,ly,labelW,labelH);
  ctx.fillStyle='rgba(200,210,255,0.9)'; ctx.fillRect(lx,ly, Math.min(labelW*0.4,70), labelH);
}

function drawDensityPanel(){
  for(let y=densPanelY0;y<=densPanelY1;y++){
    for(let x=0;x<COLS;x++){ ctx.fillStyle='hsl(220,12%,20%)'; fillCell(x,y); }
  }
  const items=densitiesLayout();
  for(let i=0;i<items.length;i++){
    const it=items[i];
    for(let y=it.y0;y<=it.y1;y++){
      for(let x=1;x<COLS-1;x++){ ctx.fillStyle=(i===densHoverIdx)?'hsl(220,14%,30%)':'hsl(220,12%,24%)'; fillCell(x,y); }
    }
    // miniature grid preview
    const pxSize=Math.round(it.val*DPR);
    const wpx=(COLS-4)*CELL, hpx=(it.y1-it.y0+1)*CELL;
    const cols=Math.max(1,Math.floor(wpx/pxSize));
    const rows=Math.max(1,Math.floor(hpx/pxSize));
    const x0px=2*CELL, y0px=it.y0*CELL;
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const on=((r+c)&1)===0;
        ctx.fillStyle= on?'hsl(210,12%,46%)':'hsl(210,14%,38%)';
        ctx.fillRect(x0px + c*pxSize + 1, y0px + r*pxSize + 1, Math.max(1,pxSize-2), Math.max(1,pxSize-2));
      }
    }
    if (it.val===cellCssPx){
      ctx.strokeStyle='rgba(255,255,255,0.9)';
      ctx.lineWidth=uiLine(2);
      ctx.strokeRect(1*CELL, it.y0*CELL, (COLS-2)*CELL, (it.y1-it.y0+1)*CELL);
    }
  }

  drawRatePanel();
}

function currentRateIndex(){
  for(let i=0;i<RATE_OPTIONS.length;i++) if (RATE_OPTIONS[i].ms===stepMs) return i;
  return 2;
}
function nextRate(){
  const i=(currentRateIndex()+1)%RATE_OPTIONS.length;
  stepMs = RATE_OPTIONS[i].ms;
  rateFlashUntil = nowTS + 140; // brief confirmation flash
}

/* speed button rect centered in the rate band */
function rateButtonRect(){
  const bandX0 = 1*CELL, bandX1 = (COLS-1)*CELL;
  const bandY0 = rateY0*CELL, bandY1 = (rateY1+1)*CELL;
  const bandW  = bandX1 - bandX0, bandH = bandY1 - bandY0;
  const w = Math.min(uiPx(180), Math.floor(bandW*0.6));
  const h = Math.max(uiPx(32), Math.floor(bandH*0.7));
  const x = Math.floor((W - w)/2);
  const y = Math.floor(bandY0 + (bandH - h)/2);
  return {x0:x, y0:y, x1:x+w, y1:y+h, w, h};
}

function drawRatePanel(){
  // band
  for(let y=rateY0; y<=rateY1; y++)
    for(let x=0; x<COLS; x++){ ctx.fillStyle='hsl(220,12%,22%)'; fillCell(x,y); }

  RECT_RATE = rateButtonRect(); // ensure up-to-date for taps right after open

  // button
  ctx.fillStyle='hsl(220,12%,26%)';
  ctx.fillRect(RECT_RATE.x0, RECT_RATE.y0, RECT_RATE.w, RECT_RATE.h);
  ctx.strokeStyle='rgba(255,255,255,0.75)';
  ctx.lineWidth=uiLine(2);
  ctx.strokeRect(RECT_RATE.x0, RECT_RATE.y0, RECT_RATE.w, RECT_RATE.h);

  // pressed / flash overlays
  if (press && press.kind==='rate'){
    ctx.fillStyle='rgba(255,255,255,0.10)';
    ctx.fillRect(RECT_RATE.x0, RECT_RATE.y0, RECT_RATE.w, RECT_RATE.h);
  }
  if (nowTS < rateFlashUntil){
    ctx.fillStyle='rgba(255,255,255,0.12)';
    ctx.fillRect(RECT_RATE.x0, RECT_RATE.y0, RECT_RATE.w, RECT_RATE.h);
  }

  // label
  const label = `Speed: ${RATE_OPTIONS[currentRateIndex()].label}`;
  ctx.fillStyle='rgba(255,255,255,0.92)';
  ctx.font = `${uiPx(12)}px system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial`;
  ctx.textAlign='center'; ctx.textBaseline='middle';
  ctx.fillText(label, RECT_RATE.x0 + RECT_RATE.w/2, RECT_RATE.y0 + RECT_RATE.h/2);
}

/* ========================= picker visuals ========================= */
function drawPicker(){
  // Life
  for(let y=pickY0;y<=pickY1;y++){
    const r01=(y-pickY0)/Math.max(1,(pickY1-pickY0));
    for(let x=0;x<pickLifeEnd;x++){
      const t=x/Math.max(1,pickLifeEnd-1);
      const H=195+15*t, S=20+70*t, L=28+20*(1-Math.abs(r01-0.5)*2);
      ctx.fillStyle=`hsl(${H},${S}%,${L}%)`; fillCell(x,y);
    }
  }
  // Wall
  for(let y=pickY0;y<=pickY1;y++){
    for(let x=pickLifeEnd;x<pickWallEnd;x++){
      const t=(x-pickLifeEnd)/Math.max(1,(pickWallEnd-pickLifeEnd-1));
      let col; if(t<0.5){const k=t/0.5; col=mixHSL([320,90,50],[220,10,55],k);}
      else if(t<0.85){const k=(t-0.5)/0.35; col=mixHSL([220,10,55],[150,65,50],k);}
      else {const k=(t-0.85)/0.15; col=mixHSL([150,65,50],[210,4,40],k);}
      ctx.fillStyle=`hsl(${col[0]},${col[1]}%,${col[2]}%)`; fillCell(x,y);
    }
  }
  // Nutrient
  for(let y=pickY0;y<=pickY1;y++)
    for(let x=pickWallEnd;x<pickNutrEnd;x++){
      const r01=(y-pickY0)/Math.max(1,(pickY1-pickY0));
      ctx.fillStyle=`hsl(${36},85%,${45+12*(1-Math.abs(r01-0.5)*2)}%)`; fillCell(x,y);
    }
  // Erase
  for(let y=pickY0;y<=pickY1;y++)
    for(let x=pickNutrEnd;x<pickEraseEnd;x++){
      const r01=(y-pickY0)/Math.max(1,(pickY1-pickY0));
      ctx.fillStyle=`hsl(6,85%,${48+10*(1-Math.abs(r01-0.5)*2)}%)`; fillCell(x,y);
    }

  // top border
  ctx.globalAlpha=0.28; ctx.fillStyle='hsl(220,10%,35%)';
  ctx.fillRect(0,(pickY0*CELL)|0, W, 1); ctx.globalAlpha=1;

  // pressed feedback for picker
  if (press && press.kind==='picker'){
    ctx.fillStyle='rgba(255,255,255,0.08)';
    ctx.fillRect(RECT_PICKER.x0, RECT_PICKER.y0, RECT_PICKER.x1-RECT_PICKER.x0, RECT_PICKER.y1-RECT_PICKER.y0);
  }

  drawBrushIcons();
}

function mixHSL(a,b,k){ return [(a[0]*(1-k)+b[0]*k+360)%360, a[1]*(1-k)+b[1]*k, a[2]*(1-k)+b[2]*k]; }

function drawBrushIcons(){
  const cy = Math.floor((pickY0+pickY1)/2)*CELL + CELL*0.5;
  const lifeSz  = iconSizeFixedPx(28);
  const wallSz  = iconSizeFixedPx(32);
  const dotSz   = iconSizeFixedPx(24);
  const eraseSz = iconSizeFixedPx(24);
  drawMiniGridIcon(Math.floor((pickLifeEnd*CELL)*0.5),                       cy, lifeSz,  false);
  drawBrickIcon   (Math.floor(((pickLifeEnd+pickWallEnd)*CELL)*0.5),          cy, wallSz);
  drawDotsIcon    (Math.floor(((pickWallEnd+pickNutrEnd)*CELL)*0.5),          cy, dotSz);
  drawRedXIcon    (Math.floor(((pickNutrEnd+pickEraseEnd)*CELL)*0.5),         cy, eraseSz);
}

function drawMiniGridIcon(cx,cy,sz,withBorder){
  const s=Math.max(2,Math.floor(sz/4));
  const w=s*3, h=s*3;
  const x=cx - w/2, y=cy - h/2;
  for(let r=0;r<3;r++){
    for(let c=0;c<3;c++){
      const on=((r===1)||(c===1));
      ctx.fillStyle= on?'rgba(255,255,255,0.9)':'rgba(255,255,255,0.22)';
      ctx.fillRect(x + c*s + 1, y + r*s + 1, Math.max(1,s-2), Math.max(1,s-2));
    }
  }
  if (withBorder){
    ctx.strokeStyle='rgba(255,255,255,0.9)';
    ctx.lineWidth = lineWidthFromSize(sz, 0.16);
    ctx.strokeRect(x, y, w, h);
  }
}
function drawBrickIcon(cx,cy,sz){
  const w=sz*1.6, h=sz;
  const x=cx-w/2, y=cy-h/2;
  ctx.strokeStyle='rgba(255,255,255,0.9)';
  ctx.lineWidth = lineWidthFromSize(sz, 0.18);
  ctx.strokeRect(x,y,w,h);
  ctx.beginPath();
  ctx.moveTo(x, y+h/2); ctx.lineTo(x+w, y+h/2);
  ctx.moveTo(x+w/3, y); ctx.lineTo(x+w/3, y+h/2);
  ctx.moveTo(x+(2*w/3), y+h/2); ctx.lineTo(x+(2*w/3), y+h);
  ctx.stroke();
}
function drawDotsIcon(cx,cy,sz){
  const r=Math.max(1,Math.floor(sz*0.18));
  ctx.fillStyle='rgba(255,255,255,0.92)';
  ctx.beginPath(); ctx.arc(cx - sz*0.35, cy, r, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.fill();
  ctx.beginPath(); ctx.arc(cx + sz*0.35, cy, r, 0, Math.PI*2); ctx.fill();
}
function drawRedXIcon(cx,cy,sz){
  ctx.strokeStyle='rgba(220,60,60,0.95)';
  ctx.lineWidth = lineWidthFromSize(sz, 0.18);
  const d=sz*0.6;
  ctx.beginPath(); ctx.moveTo(cx-d,cy-d); ctx.lineTo(cx+d,cy+d); ctx.stroke();
  ctx.beginPath(); ctx.moveTo(cx+d,cy-d); ctx.lineTo(cx-d,cy+d); ctx.stroke();
}

/* preview ring */
function drawPreviewSpot(){
  const cx = picking ? Math.min(COLS-1, Math.max(0,(picking.x/CELL)|0))
    : (brushMode==='seed' ? Math.floor(pickLifeEnd/2)
      : brushMode==='barrier' ? Math.floor((pickLifeEnd+pickWallEnd)/2)
      : brushMode==='nutrient' ? Math.floor((pickWallEnd+pickNutrEnd)/2)
      : Math.floor((pickNutrEnd+pickEraseEnd)/2));
  const py = Math.max(0, noDrawBorderPxTop - Math.round(8*DPR));
  const px = cx*CELL + CELL*0.5;
  const r = 2.6*CELL*params.brushRadius;

  ctx.globalAlpha=1;
  ctx.strokeStyle='rgba(255,255,255,0.95)';
  ctx.lineWidth=Math.max(1,Math.floor(CELL*0.6));
  ctx.beginPath(); ctx.arc(px,py, r, 0, Math.PI*2); ctx.stroke();
}

/* sticky readout */
function drawPickIndicator(px, readout){
  const label = readout[0]||'';
  const w = Math.min(W*0.5, Math.max(120, label.length*10))*0.55;
  const x = Math.min(W-w-8, Math.max(8, px - w/2));
  const y = (pickY0*CELL) - Math.max(18, CELL*2) - 6;
  const h = Math.max(16, CELL*1.6);
  ctx.fillStyle='rgba(15,20,32,0.92)'; ctx.fillRect(x,y,w,h);
  ctx.fillStyle='rgba(200,210,255,0.9)'; ctx.fillRect(x,y, Math.min(70,w*0.4), h);
}

/* ========================= loop ========================= */
let lastT = performance.now();
let acc = 0;

function tick(now){
  const dt = Math.min(50, now - lastT);
  lastT = now; nowTS = now;
  acc += dt;

  const MAX_STEPS = 4;
  if (stepMs === 0){
    const chunk = acc; acc = 0; step(chunk);
  } else {
    let steps = 0;
    while (acc >= stepMs && steps < MAX_STEPS){
      step(stepMs); acc -= stepMs; steps++;
    }
  }

  render();
  requestAnimationFrame(tick);
}

/* ========================= init ========================= */
applyGrid();
addEventListener('resize', ()=>{ applyGrid(); }, {passive:true});
cv.addEventListener('gesturestart', e=>e.preventDefault(), {passive:false});
requestAnimationFrame(tick);

})();
</script>
</body>
</html>