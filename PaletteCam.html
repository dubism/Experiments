<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Live Camera Palette — Stable Freeze + Immediate Palettes</title>
<style>
  :root{
    --bg:#000; --ink:#fff; --muted:#bdbdbd; --line:#222; --zoom:1;
    --sq:0px; --cbH:0px;
    --ctaW:clamp(220px,60vw,340px); --ctaH:56px;
    --ctaB:calc(16px + env(safe-area-inset-bottom));
  }
  *{box-sizing:border-box}
  html,body{height:100dvh}
  html,body{
    margin:0;background:#000;color:#fff;font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;
    user-select:none; overflow:hidden; overscroll-behavior:none; touch-action:none;
    -webkit-text-size-adjust:100%;
  }

  .app{position:fixed; inset:0; display:grid; isolation:isolate; overscroll-behavior:none;}
  @media (orientation: portrait){
    .app{ grid-template-rows: var(--sq) 1fr; grid-template-columns: 1fr; }
    #videoPane{ grid-row:1; grid-column:1; } #uiPane{ grid-row:2; grid-column:1; }
  }
  @media (orientation: landscape){
    .app{ grid-template-columns: var(--sq) 1fr; grid-template-rows: 1fr; }
    #videoPane{ grid-column:1; grid-row:1; } #uiPane{ grid-column:2; grid-row:1; }
  }

  #videoPane{
    position:relative; overflow:hidden; background:#000; z-index:1;
    contain:layout paint size; clip-path: inset(0);
    -webkit-user-drag:none;
  }
  #videoPane video, #videoPane canvas{
    position:absolute; inset:0; width:100%; height:100%;
    object-fit:cover; transform:scale(var(--zoom)); transform-origin:center; display:block;
    backface-visibility:hidden; will-change:transform;
    -webkit-user-drag:none; pointer-events:none;
  }
  #video::-webkit-media-controls-start-playback-button{ display:none !important; }
  #frozenCanvas{display:none}

  #uiPane{
    position:relative; min-width:0; min-height:0; display:flex; flex-direction:column; gap:10px;
    padding:10px 12px 12px;
    padding-bottom: calc(12px + var(--ctaH) + env(safe-area-inset-bottom));
    background:#000; z-index:2; contain:paint;
  }

  #palettePane{ display:flex; flex-direction:column; gap:10px; min-height:0; flex:1;
    border-bottom:1px solid var(--line); padding-bottom:10px; background:#000; }
  .title{display:flex;align-items:center;justify-content:space-between;color:#9aa0a6}
  .stack{
    position:relative;display:flex;flex-direction:column;gap:10px;min-height:0;flex:1;cursor:pointer;
    touch-action:none; -webkit-touch-callout:none; -webkit-user-drag:none;
  }
  .swatches,.gradient{border:1px solid var(--line);border-radius:14px;overflow:hidden;min-height:60px;background:#000}
  .swatches{display:flex} .swatch{flex:1} .gradient{display:block}
  #openHint{display:none}

  #controlsBar{ border-top:1px solid var(--line); background:#000; padding:10px 0 0; margin-top:auto; }
  #bar{display:grid;grid-template-columns:1fr;grid-template-rows:auto;gap:10px}
  .zoomArea{grid-row:1}
  .zoomWrap{display:flex;align-items:center;gap:12px;width:100%}
  .zbtn{flex:none;width:42px;height:42px;aspect-ratio:1/1;border-radius:50%;border:1px solid var(--line);background:#121212;color:#fff;font-size:22px;display:flex;align-items:center;justify-content:center;cursor:pointer}
  input[type="range"].zoom{appearance:none;-webkit-appearance:none;width:100%;height:16px;border-radius:999px;background:#1a1a1a;outline:none}
  input[type="range"].zoom::-webkit-slider-thumb{appearance:none;-webkit-appearance:none;width:28px;height:28px;border-radius:50%;background:#fff;border:none;cursor:pointer;margin-top:-6px}
  input[type="range"].zoom::-webkit-slider-runnable-track{height:16px;border-radius:999px;background:#2b2b2b}
  input[type="range"].zoom::-moz-range-thumb{width:28px;height:28px;border:none;border-radius:50%;background:#fff;cursor:pointer}
  input[type="range"].zoom::-moz-range-track{height:16px;border-radius:999px;background:#2b2b2b}
  .btn{padding:12px 18px;border:1px solid var(--line);border-radius:12px;background:#0d0d0d;color:#fff;cursor:pointer}
  .btn.cta{background:#fff;color:#000;font-weight:900;border-color:#fff;font-size:18px}

  #freezeBtn,#unfreezeBtn{
    position:fixed; left:50%; transform:translateX(-50%) translateZ(0);
    bottom:var(--ctaB); width:var(--ctaW); z-index:5000;
  }

  /* ——— Control Center wrapper (contract) ——— */
  #ccWrap{
    position:fixed;
    inset:
      max(12px, env(safe-area-inset-top))
      max(12px, env(safe-area-inset-right))
      calc(var(--ctaH) + env(safe-area-inset-bottom) + 12px)
      max(12px, env(safe-area-inset-left));
    z-index:9000;
    display:none;
    pointer-events:auto;
    transform:translateZ(0);
  }
  #ccWrap.open{ display:block; }

  /* ——— Control Center card (contract) ——— */
  #cc{
    position:absolute; inset:0;
    background:rgba(0,0,0,.65);
    backdrop-filter:blur(10px);
    border:1px solid var(--line);
    border-radius:14px;
    padding:14px;
    overflow:auto; max-height:100%;
    touch-action:pan-y;
  }

  /* Typography + numerics */
  .small,.value{font-variant-numeric:tabular-nums}
  .label{font-weight:600}

  /* Method copy + separator (contract) */
  #algoBrief{ margin:10px 4px 14px; line-height:1.45; }
  #algoBrief .a{ margin:8px 0 12px; opacity:.85; }
  #algoBrief .a.active{ opacity:1; font-weight:600; }
  .ccsep{ border:0; border-top:1px solid var(--line); opacity:.6; margin:6px 0 10px; }

  /* Field blocks (contract) */
  .field{ padding:6px 2px 0; }
  .field-head{ display:flex; align-items:center; justify-content:space-between; min-height:44px; }
  .value{ color:#9aa0a6; margin-left:12px; }
  .field-body{ padding:2px 0 8px; }
  .divider{ height:1px; margin:6px 0 4px; background:linear-gradient(to right, transparent, #222, transparent); }

  /* Inputs inside CC (contract) */
  #cc .field-body input[type="range"]{ width:100%; }
  #cc, #cc *{ -webkit-user-select:none; user-select:none; }
  #cc input, #cc textarea, #cc select, #cc button, #cc label{ -webkit-user-select:auto; user-select:auto; pointer-events:auto; }

  /* Long-press shield, error toast, composite overlay */
  .pressLock, .pressLock *{ -webkit-user-select:none !important; user-select:none !important; -webkit-touch-callout:none !important; }
  #pressShield{ position:fixed; inset:0; z-index:9500; background:transparent; display:none; touch-action:none; pointer-events:auto; }

  #camError{
    position:fixed; left:50%; transform:translateX(-50%);
    bottom:calc(var(--ctaB) + 64px); background:rgba(255,80,80,.12);
    color:#ffbdbd; border:1px solid #492; border-color:#ff5a5a33;
    padding:8px 12px; border-radius:10px; font-size:12px; display:none; z-index:8000;
    backdrop-filter:blur(8px);
  }

  #compositeOverlay{position:fixed;inset:0;background:#000;z-index:10000;display:none;align-items:center;justify-content:center;flex-direction:column;gap:16px;padding:14px}
  #compositeOverlay.open{display:flex}
  #compositeCanvas{display:none}
  #compositeImg{max-width:min(1024px,92vw);max-height:70vh;border-radius:12px;background:#000}
  .smallhint{font-size:12px;color:#9aa0a6;margin-top:6px;text-align:center;user-select:none}

  /* Processing canvases must never layout/paint */
  #off,#capFrame{ display:none !important; width:0 !important; height:0 !important; }
</style>
</head>
<body>
  <div class="app">
    <section id="videoPane" aria-label="Camera">
      <video id="video" playsinline muted autoplay></video>
      <canvas id="frozenCanvas"></canvas>
    </section>

    <section id="uiPane" aria-label="UI">
      <div id="palettePane">
        <div class="title">
          <div id="algoName" class="small">K-Means (LAB)</div>
          <div class="small">FPS <span id="fps">0</span> · <span id="res">–</span> · <span id="status">Starting…</span></div>
        </div>
        <div class="stack" id="paletteClickable" title="Tap left/right to switch · long-press for controls · drag to change K" draggable="false">
          <div id="swatches" class="swatches"></div>
          <div id="gradient" class="gradient" hidden></div>
          <div id="openHint" aria-hidden="true"></div>
        </div>
      </div>

      <section id="controlsBar">
        <div id="bar">
          <div class="zoomArea">
            <div class="zoomWrap">
              <button class="zbtn" id="zoomMinus" type="button" aria-label="Zoom out">−</button>
              <input type="range" id="zoom" class="zoom" min="1" max="10" step="0.01" value="1">
              <button class="zbtn" id="zoomPlus" type="button" aria-label="Zoom in">+</button>
            </div>
          </div>
          <button class="btn cta" id="freezeBtn" type="button">FREEZE</button>
        </div>
      </section>
    </section>
  </div>

  <!-- ===== CC overlay (contractual structure) as a direct child of <body> ===== -->
  <div id="ccWrap" role="dialog" aria-modal="true">
    <div id="cc">
      <section id="algoBrief" class="small"></section>
      <hr class="ccsep">

      <div class="field">
        <div class="field-head">
          <span class="label">Colors (K)</span>
          <span class="value" id="kVal">3</span>
        </div>
        <div class="field-body">
          <input type="range" id="k" min="2" max="10" value="3">
        </div>
        <div class="divider"></div>
      </div>

      <div class="field">
        <div class="field-head">
          <span class="label">Show rectangles</span>
          <input type="checkbox" id="rects" checked>
        </div>
        <div class="divider"></div>
      </div>

      <div class="field">
        <div class="field-head">
          <span class="label">Show gradient</span>
          <input type="checkbox" id="grad" checked>
        </div>
        <div class="divider"></div>
      </div>

      <div class="field">
        <div class="field-head">
          <span class="label">Processing width</span>
          <span class="value" id="sizeVal">240 px</span>
        </div>
        <div class="field-body">
          <input type="range" id="size" min="120" max="360" step="20" value="240">
        </div>
        <div class="divider"></div>
      </div>

      <div class="field">
        <div class="field-head">
          <span class="label">Process every N frames</span>
          <span class="value" id="throttleVal">20</span>
        </div>
        <div class="field-body">
          <input type="range" id="throttleLog" min="0" max="100" value="0">
        </div>
        <div class="divider"></div>
      </div>
    </div>
  </div>

  <div id="pressShield"></div>
  <div id="camError" role="status"></div>

  <div id="compositeOverlay">
    <canvas id="compositeCanvas"></canvas>
    <img id="compositeImg" alt="Composite preview"/>
    <div id="lpHint" class="smallhint">Long-press the image to save.</div>
    <button class="btn cta" id="unfreezeBtn" type="button">UNFREEZE</button>
  </div>

  <canvas id="off"></canvas>
  <canvas id="capFrame"></canvas>

<script>
/* ===== error toast ===== */
(function(){
  window.addEventListener('error', e=>{
    try{
      const box=document.getElementById('camError');
      box.textContent = 'Script error: ' + (e.message||'unknown');
      box.style.display='block';
    }catch{}
  }, {once:true});
})();

/* ===== square sizing ===== */
(function(){
  function recalcSquare(){
    const vv = window.visualViewport;
    const vw = Math.max(0, window.innerWidth);
    const vh = Math.max(0, (vv?.height ?? window.innerHeight));
    const isLandscape = vw > vh;
    const sq = isLandscape ? vh : Math.min(vw, vh);
    document.documentElement.style.setProperty('--sq', Math.round(sq) + 'px');

    const fc = document.getElementById('frozenCanvas');
    if (fc && fc.style.display !== 'none') {
      const wrap = document.getElementById('videoPane');
      fc.width = wrap.clientWidth;
      fc.height = wrap.clientHeight;
    }
  }
  window.recalcSquare = recalcSquare;
  let raf = 0;
  const kick = () => { cancelAnimationFrame(raf); raf = requestAnimationFrame(recalcSquare); };
  addEventListener('load', kick,{passive:true});
  addEventListener('resize', kick,{passive:true});
  addEventListener('orientationchange', kick,{passive:true});
  window.visualViewport && window.visualViewport.addEventListener('resize', kick,{passive:true});
})();

/* ===== measure CTA / bar ===== */
const controlsBar = document.getElementById('controlsBar');
const freezeBtnEl = document.getElementById('freezeBtn');
function updateCbH(){
  try{
    const hBar = Math.round(controlsBar.getBoundingClientRect().height);
    document.documentElement.style.setProperty('--cbH', hBar + 'px');
    const hCta = freezeBtnEl ? Math.round(freezeBtnEl.getBoundingClientRect().height) : Math.max(56, hBar);
    document.documentElement.style.setProperty('--ctaH', hCta + 'px');
  }catch{}
}
new ResizeObserver(updateCbH).observe(controlsBar);
freezeBtnEl && new ResizeObserver(updateCbH).observe(freezeBtnEl);
addEventListener('load', updateCbH);

/* ===== elements ===== */
const video=document.getElementById('video');
const frozenCanvas=document.getElementById('frozenCanvas');
const statusEl=document.getElementById('status');
const fpsEl=document.getElementById('fps');
const resEl=document.getElementById('res');
const swatchesEl=document.getElementById('swatches');
const gradientEl=document.getElementById('gradient');
const paletteClickable=document.getElementById('paletteClickable');
const kRange=document.getElementById('k'); const kVal=document.getElementById('kVal');
const sizeRange=document.getElementById('size'); const sizeVal=document.getElementById('sizeVal');
const throttleLog=document.getElementById('throttleLog'); const throttleVal=document.getElementById('throttleVal');
const rectChk=document.getElementById('rects'); const gradChk=document.getElementById('grad');
const zoomSlider=document.getElementById('zoom'); const zoomMinus=document.getElementById('zoomMinus'); const zoomPlus=document.getElementById('zoomPlus');
const freezeBtn=document.getElementById('freezeBtn');
const compositeOverlay=document.getElementById('compositeOverlay');
const compositeCanvas=document.getElementById('compositeCanvas');
const compositeImg=document.getElementById('compositeImg');
const unfreezeBtn=document.getElementById('unfreezeBtn');
const ccWrap=document.getElementById('ccWrap');
const cc=document.getElementById('cc');
const algoNameEl=document.getElementById('algoName');
const lpHint=document.getElementById('lpHint');
const pressShield=document.getElementById('pressShield');
const camError=document.getElementById('camError');
const off=document.getElementById('off');

/* ===== state ===== */
let algo='kmeans', K=+kRange.value, procWidth=+sizeRange.value, uiZoom=+zoomSlider.value;
let throttleN=20, frameCounter=0, lastT=performance.now(), fps=0;
let ccOpen=false, pressLock=false, draggingK=false;
let lastPaletteKmax=null;
const KMAX = +kRange.max;

/* ===== helpers ===== */
const TH_MIN=1, TH_MAX=150;
const sliderToN=v=>Math.max(TH_MIN,Math.min(TH_MAX,Math.round(TH_MIN*Math.exp((v/100)*Math.log(TH_MAX/TH_MIN)))));
const nToSlider=n=>Math.round((Math.log(Math.max(TH_MIN,Math.min(TH_MAX,n))/TH_MIN)/Math.log(TH_MAX/TH_MIN))*100);
const clamp=(v,min,max)=>v<min?min:(v>max?max:v);
const toHex=([r,g,b])=>'#'+[r,g,b].map(v=>Math.max(0,Math.min(255,Math.round(v))).toString(16).padStart(2,'0')).join('');
const status=t=>{ try{statusEl.textContent=t;}catch{} };
function toast(msg){ if(!msg) return; camError.textContent=msg; camError.style.display='block'; setTimeout(()=>camError.style.display='none', 3000); }

/* ===== algo labels/brief (contract) ===== */
const ALGOS=['kmeans','hist','mediancut'];
const ALGO_LABEL={kmeans:'K-Means (LAB)',hist:'Histogram',mediancut:'Median-cut'};
const ALGO_COPY={
  kmeans:'K-Means (LAB): groups similar colors in human-perceived space.',
  hist:'Histogram: picks colors that appear most often with simple smoothing.',
  mediancut:'Median-cut: slices the color range into balanced boxes.'
};
function setAlgo(next){ algo=next; algoNameEl.textContent=ALGO_LABEL[algo]; highlightAlgoDesc(algo); lastPaletteKmax=null; }
function cycleAlgo(dir){ const i=ALGOS.indexOf(algo); setAlgo(ALGOS[(i+(dir>0?1:-1)+ALGOS.length)%ALGOS.length]); }
function renderAlgoBrief(){
  const b=document.getElementById('algoBrief');
  b.innerHTML = `
    <div class="a" data-a="kmeans">${ALGO_COPY.kmeans}</div>
    <div class="a" data-a="hist">${ALGO_COPY.hist}</div>
    <div class="a" data-a="mediancut">${ALGO_COPY.mediancut}</div>`;
}
function highlightAlgoDesc(a){ document.querySelectorAll('#algoBrief .a').forEach(n=>n.classList.toggle('active',n.dataset.a===a)); }

/* ===== selection + CC behavior (contract) ===== */
function lockPressSelection(){ if(pressLock) return; pressLock=true; document.body.classList.add('pressLock'); }
function unlockPressSelection(){ if(!pressLock) return; pressLock=false; document.body.classList.remove('pressLock'); const s=window.getSelection?.(); try{ s && s.removeAllRanges(); }catch{} }
document.addEventListener('selectstart',(e)=>{ if(pressLock) e.preventDefault(); },{capture:true});
document.addEventListener('selectionchange',()=>{ if(pressLock){ const s=window.getSelection?.(); try{ s && s.removeAllRanges(); }catch{} }});
document.addEventListener('contextmenu',(e)=>{ if(ccOpen||pressLock) e.preventDefault(); },{capture:true});

/* CC open/close (contract) */
function hidePressShield(){ pressShield.style.display='none'; clearTimeout(showPressShieldWithAutoRelease._t); }
function openCC(){
  hidePressShield(); unlockScroll(); unlockPressSelection();
  try{ video.dataset.prevOpacity = video.style.opacity || ''; video.style.opacity = '0.9999'; }catch{}
  ccWrap.style.display = 'block';           // <-- explicit, beats any inline default
  ccWrap.classList.add('open'); ccOpen=true;

  queueMicrotask(()=>{
    const first = cc.querySelector('input, select, textarea, button');
    if(first && first.focus) try{ first.focus({preventScroll:true}); }catch{}
  });
}
function closeCC(){
  ccOpen=false; ccWrap.classList.remove('open'); hidePressShield();
  ccWrap.style.display = 'none';            // <-- explicit hide
  try{ video.style.opacity = video.dataset.prevOpacity || ''; }catch{}
}

/* Stop outside-close bubbling from inside CC */
cc.addEventListener('pointerdown', e=>e.stopPropagation(), {capture:true});
cc.addEventListener('click', e=>e.stopPropagation(), {capture:true});

/* Close on ANY outside tap (keep open if composite overlay is up) */
document.addEventListener('pointerdown', (e)=>{
  if(document.getElementById('compositeOverlay')?.classList.contains('open')) return;
  if(ccOpen && !cc.contains(e.target)) closeCC();
}, {capture:true});

/* ESC closes CC */
document.addEventListener('keydown', (e)=>{ if(e.key==='Escape' && ccOpen) closeCC(); });

/* Long-press shield helpers */
function showPressShieldWithAutoRelease(){
  pressShield.style.display='block';
  const release=()=>{ hidePressShield(); document.removeEventListener('pointerup',release,true); document.removeEventListener('touchend',release,true); document.removeEventListener('mouseup',release,true); };
  document.addEventListener('pointerup',release,true);
  document.addEventListener('touchend',release,true);
  document.addEventListener('mouseup',release,true);
  clearTimeout(showPressShieldWithAutoRelease._t);
  showPressShieldWithAutoRelease._t=setTimeout(hidePressShield,1200);
}

/* ===== global scroll lock during K-drag (never when CC is open) ===== */
function noScroll(e){ if(ccOpen) return; if(e.cancelable) e.preventDefault(); }
function lockScroll(){
  document.addEventListener('touchmove', noScroll, {passive:false, capture:true});
  document.addEventListener('wheel', noScroll, {passive:false, capture:true});
}
function unlockScroll(){
  document.removeEventListener('touchmove', noScroll, {capture:true});
  document.removeEventListener('wheel', noScroll, {capture:true});
}

/* ===== K-drag + gestures (instant) ===== */
let lpTimer=0,movedTooFar=false,longPressed=false;
const LP_MS=450,MOVE_TOL=10;
function getKStepPx(){ const h = paletteClickable.clientHeight || 200; return Math.max(14, Math.min(56, Math.round(h / 6))); }

/* instant K application (Option A: slice from lastPaletteKmax) */
function renderPlaceholders(count){
  for(let i=0;i<count;i++){
    const d=document.createElement('div');
    d.className='swatch';
    d.style.background='#222';
    swatchesEl.appendChild(d);
  }
}
function applyKInstant(newK){
  K = newK; kVal.textContent = newK;
  swatchesEl.innerHTML='';
  if(lastPaletteKmax && lastPaletteKmax.length){
    const have = Math.min(K, lastPaletteKmax.length);
    renderPalette(lastPaletteKmax.slice(0, have), true);
    if(have < K) renderPlaceholders(K - have);
  }else{
    renderPlaceholders(K);
  }
}

paletteClickable.addEventListener('pointerdown', (e)=>{
  if(ccOpen) return;
  if(e.pointerType==='mouse' && e.button!==0) return;

  movedTooFar=false; longPressed=false;
  const startX=e.clientX, startY=e.clientY;
  let lastX=startX, lastY=startY;

  let kDrag=false; draggingK=false;
  let kAccum=0;
  const stepPx=getKStepPx();
  let ax=0, ay=-1, dirSign=+1;

  paletteClickable.setPointerCapture(e.pointerId);
  lockPressSelection(); lockScroll();

  clearTimeout(lpTimer);
  lpTimer=setTimeout(()=>{
    if(movedTooFar || kDrag) return;
    longPressed=true;
    try{paletteClickable.releasePointerCapture(e.pointerId);}catch{}
    openCC();
  }, LP_MS);

  const move=(ev)=>{
    const dx = ev.clientX - startX;
    const dy = ev.clientY - startY;

    if(!kDrag){
      if(Math.abs(dx) > MOVE_TOL || Math.abs(dy) > MOVE_TOL){ movedTooFar = true; clearTimeout(lpTimer); }
      if(Math.abs(dy) > MOVE_TOL && Math.abs(dy) > Math.abs(dx) * 0.7){
        const len = Math.hypot(dx, dy) || 1;
        ax = dx / len; ay = dy / len;
        dirSign = (dy < 0) ? +1 : -1;
        kDrag = true; draggingK = true;
      }
    }

    if(kDrag){
      const dpx = ev.clientX - lastX;
      const dpy = ev.clientY - lastY;
      const proj = dpx*ax + dpy*ay;
      kAccum += proj * dirSign;

      let steps = 0;
      if(kAccum >= stepPx) steps = Math.floor(kAccum / stepPx);
      else if(kAccum <= -stepPx) steps = Math.ceil(kAccum / stepPx);

      if(steps){
        const newK = clamp(+kRange.value + steps, +kRange.min, +kRange.max);
        if (newK !== +kRange.value){
          kRange.value = String(newK);
          applyKInstant(newK);
        }
        kAccum -= steps * stepPx;
      }
      if(ev.cancelable) ev.preventDefault();
    }

    lastX = ev.clientX; lastY = ev.clientY;
  };

  const finish=(ev)=>{
    try{paletteClickable.releasePointerCapture(e.pointerId);}catch{}
    paletteClickable.removeEventListener('pointermove',move);
    paletteClickable.removeEventListener('pointerup',finish);
    paletteClickable.removeEventListener('pointercancel',cancel);
    clearTimeout(lpTimer); hidePressShield(); unlockScroll();

    if(!longPressed && !kDrag && !movedTooFar){
      const r=paletteClickable.getBoundingClientRect();
      const isLeft=(ev.clientX-r.left)<(r.width/2); cycleAlgo(isLeft?-1:+1);
    }
    draggingK=false; unlockPressSelection();
  };

  const cancel=()=>{
    clearTimeout(lpTimer); hidePressShield(); unlockScroll(); unlockPressSelection();
    try{paletteClickable.releasePointerCapture(e.pointerId);}catch{}
    paletteClickable.removeEventListener('pointermove',move);
    paletteClickable.removeEventListener('pointerup',finish);
    paletteClickable.removeEventListener('pointercancel',cancel);
    draggingK=false;
  };

  paletteClickable.addEventListener('pointermove',move);
  paletteClickable.addEventListener('pointerup',finish,{once:true});
  paletteClickable.addEventListener('pointercancel',cancel,{once:true});
});

paletteClickable.addEventListener('wheel', (e)=>{ e.preventDefault(); }, {passive:false});

/* ===== controls (contract bindings) ===== */
kRange.addEventListener('input',()=>applyKInstant(+kRange.value));
sizeRange.addEventListener('input',()=>{procWidth=+sizeRange.value;sizeVal.textContent=procWidth+' px';});
throttleLog.addEventListener('input',()=>{throttleN=sliderToN(+throttleLog.value);throttleVal.textContent=String(throttleN);});
rectChk.addEventListener('change',()=>renderPalette(lastPaletteKmax?.slice(0,K)||[]));
gradChk.addEventListener('change',()=>renderPalette(lastPaletteKmax?.slice(0,K)||[]));
function setZoom(v){ uiZoom=clamp(v,1,10); zoomSlider.value=uiZoom; document.documentElement.style.setProperty('--zoom',uiZoom); }
zoomSlider.addEventListener('input',()=>setZoom(+zoomSlider.value));
zoomMinus.addEventListener('click',()=>setZoom(+zoomSlider.value-0.25));
zoomPlus .addEventListener('click',()=>setZoom(+zoomSlider.value+0.25));

/* ===== crop helper ===== */
function computeSquareCrop(){
  const vw=video.videoWidth||0, vh=video.videoHeight||0; if(!vw||!vh) return {sx:0,sy:0,sw:0,sh:0};
  const z=Math.max(1,uiZoom), base=Math.min(vw,vh), sw=Math.round(base/z), sh=sw,
        sx=Math.floor((vw-sw)/2), sy=Math.floor((vh-sw)/2);
  return {sx,sy,sw,sh};
}

/* ===== sampling ===== */
function samplePixels(imgData, step){
  const d = imgData.data;
  const n = d.length;
  const out=[];
  for(let i=0;i<n;i+=4*step){
    if(d[i+3] < 250) continue;
    out.push([d[i], d[i+1], d[i+2]]);
  }
  return out;
}

/* ===== Option A: compute Kmax palette (hierarchical / deterministic) ===== */
function kmeansKmax(pixels, Kmax){
  if(!pixels.length) return [];
  const idxs = Uint32Array.from({length:pixels.length}, (_,i)=>i);
  let leaves = [{ids:idxs, id:0}];
  let nextId=1;

  function centroid(ids){
    let r=0,g=0,b=0; const n=ids.length||ids.byteLength;
    for(let i=0;i<n;i++){ const p=pixels[ids[i]]; r+=p[0]; g+=p[1]; b+=p[2]; }
    const inv=1/Math.max(1,n); return [r*inv,g*inv,b*inv];
  }
  function split2(ids){
    let nr=0,ng=0,nb=0, n=ids.length||ids.byteLength;
    for(let i=0;i<n;i++){ const p=pixels[ids[i]]; nr+=p[0]; ng+=p[1]; nb+=p[2]; }
    const mr=nr/n, mg=ng/n, mb=nb/n;
    let vr=0,vg=0,vb=0;
    for(let i=0;i<n;i++){ const p=pixels[ids[i]]; const dr=p[0]-mr,dg=p[1]-mg,db=p[2]-mb; vr+=dr*dr; vg+=dg*dg; vb+=db*db; }
    const axis = (vr>=vg && vr>=vb)?0:((vg>=vb)?1:2);

    const c=[mr,mg,mb];
    const seedA=c.slice(), seedB=c.slice();
    const j = Math.sqrt((axis===0?vr:(axis===1?vg:vb))/Math.max(1,n)) * 0.5;
    seedA[axis]-=j; seedB[axis]+=j;

    let A=[], B=[];
    let ca=seedA, cb=seedB;
    for(let it=0; it<3; it++){
      A.length=0; B.length=0;
      for(let i=0;i<n;i++){
        const p=pixels[ids[i]];
        const da=(p[0]-ca[0])**2 + (p[1]-ca[1])**2 + (p[2]-ca[2])**2;
        const db=(p[0]-cb[0])**2 + (p[1]-cb[1])**2 + (p[2]-cb[2])**2;
        (da<=db?A:B).push(ids[i]);
      }
      if(A.length===0 || B.length===0){
        const sorted = Array.from(ids).sort((i1,i2)=>pixels[i1][axis]-pixels[i2][axis]);
        const mid = sorted.length>>1;
        A = sorted.slice(0, mid);
        B = sorted.slice(mid);
      }
      ca = centroid(A); cb = centroid(B);
    }
    return {A:Uint32Array.from(A), B:Uint32Array.from(B), ca, cb};
  }

  while(leaves.length < Kmax){
    leaves.sort((x,y)=> (y.ids.length - x.ids.length) || (x.id - y.id));
    const node = leaves.shift();
    if(!node || node.ids.length<=1){ if(node) leaves.push(node); break; }
    const {A,B} = split2(node.ids);
    leaves.push({ids:A, id:nextId++});
    leaves.push({ids:B, id:nextId++});
  }

  const reps = leaves.map(l=>({c:centroid(l.ids), n:l.ids.length, id:l.id}))
                     .sort((a,b)=> (b.n-a.n) || (a.id-b.id))
                     .map(o=>o.c);
  return reps.slice(0, Kmax);
}

function medianCutKmax(pixels, Kmax){
  if(!pixels.length) return [];
  const allIdx = Uint32Array.from({length:pixels.length}, (_,i)=>i);
  let boxes=[{ids:allIdx, id:0}]; let nextId=1;

  function stats(ids){
    let rMin=255,gMin=255,bMin=255, rMax=0,gMax=0,bMax=0;
    let sr=0,sg=0,sb=0, n=ids.length||ids.byteLength;
    for(let i=0;i<n;i++){
      const p=pixels[ids[i]]; const r=p[0],g=p[1],b=p[2];
      if(r<rMin)rMin=r; if(g<gMin)gMin=g; if(b<bMin)bMin=b;
      if(r>rMax)rMax=r; if(g>gMax)gMax=g; if(b>bMax)bMax=b;
      sr+=r; sg+=g; sb+=b;
    }
    return {rMin,rMax,gMin,gMax,bMin,bMax, mean:[sr/n, sg/n, sb/n], n};
  }

  function split(ids){
    const s = stats(ids);
    const rangeR = s.rMax - s.rMin, rangeG = s.gMax - s.gMin, rangeB = s.bMax - s.bMin;
    const axis = (rangeR>=rangeG && rangeR>=rangeB)?0:((rangeG>=rangeB)?1:2);

    const sorted = Array.from(ids).sort((i1,i2)=>pixels[i1][axis]-pixels[i2][axis]);
    const mid = sorted.length>>1 || 1;
    return {A:Uint32Array.from(sorted.slice(0,mid)), B:Uint32Array.from(sorted.slice(mid))};
  }

  while(boxes.length < Kmax){
    boxes.sort((x,y)=>{
      const sx=stats(x.ids), sy=stats(y.ids);
      const pop = (sy.n - sx.n);
      if(pop) return pop;
      const rx = Math.max(sx.rMax-sx.rMin, sx.gMax-sx.gMin, sx.bMax-sx.bMin);
      const ry = Math.max(sy.rMax-sy.rMin, sy.gMax-sy.gMin, sy.bMax-sy.bMin);
      return (ry - rx) || (x.id - y.id);
    });
    const box=boxes.shift(); if(!box || box.ids.length<=1){ if(box) boxes.push(box); break; }
    const {A,B} = split(box.ids);
    boxes.push({ids:A, id:nextId++});
    boxes.push({ids:B, id:nextId++});
  }

  const reps = boxes.map(b=>{
    const s=stats(b.ids); return {c:s.mean, n:s.n, id:b.id};
  }).sort((a,b)=> (b.n-a.n) || (a.id-b.id)).map(o=>o.c);

  return reps.slice(0,Kmax);
}

function histogramKmax(pixels, Kmax){
  if(!pixels.length) return [];
  const B=16, gridSize=B*B*B;
  const bins = new Uint32Array(gridSize);
  const toBin = (v)=> Math.min(B-1, (v*B/256)|0);
  for(const p of pixels){
    const r=toBin(p[0]), g=toBin(p[1]), b=toBin(p[2]);
    bins[r*B*B + g*B + b]++;
  }
  const w = [1,2,1], smooth = new Float32Array(gridSize);
  for(let r=0;r<B;r++) for(let g=0;g<B;g++) for(let b=0;b<B;b++){
    let acc=0;
    for(let dr=-1;dr<=1;dr++){
      const rr=r+dr; if(rr<0||rr>=B) continue;
      for(let dg=-1;dg<=1;dg++){
        const gg=g+dg; if(gg<0||gg>=B) continue;
        for(let db=-1;db<=1;db++){
          const bb=b+db; if(bb<0||bb>=B) continue;
          acc += bins[rr*B*B + gg*B + bb] * w[dr+1]*w[dg+1]*w[db+1];
        }
      }
    }
    smooth[r*B*B + g*B + b] = acc;
  }
  const candidates=[]; for(let i=0;i<gridSize;i++) if(smooth[i]>0) candidates.push({i, v:smooth[i]});
  candidates.sort((a,b)=>b.v-a.v);

  const picked=[], taken = new Uint8Array(gridSize); const NMSr = 1;
  for(const c of candidates){
    if(picked.length>=Kmax) break;
    if(taken[c.i]) continue;
    picked.push(c.i);
    const bi = c.i, br = (bi/(B*B))|0, bg = ((bi%(B*B))/B)|0, bb = bi%B;
    for(let dr=-NMSr; dr<=NMSr; dr++){
      const rr=br+dr; if(rr<0||rr>=B) continue;
      for(let dg=-NMSr; dg<=NMSr; dg++){
        const gg=bg+dg; if(gg<0||gg>=B) continue;
        for(let db=-NMSr; db<=NMSr; db++){
          const bb2=bb+db; if(bb2<0||bb>=B) continue;
          taken[rr*B*B + gg*B + bb2] = 1;
        }
      }
    }
  }

  const toCenter = (bin)=> Math.round((bin+0.5)*(255/B));
  return picked.map(i=>{
    const r=(i/(B*B))|0, g=((i%(B*B))/B)|0, b=i%B;
    return [toCenter(r), toCenter(g), toCenter(b)];
  });
}

/* render */
function renderPalette(pal, skipClear=false){
  if(!skipClear) swatchesEl.innerHTML='';
  const showRects = rectChk.checked!==false;
  const showGrad  = gradChk.checked!==false;

  if(showRects){
    for(const rgb of pal){
      const d=document.createElement('div');
      d.className='swatch';
      d.style.background=toHex(rgb);
      swatchesEl.appendChild(d);
    }
    swatchesEl.style.display='';
  }else{
    swatchesEl.style.display='none';
  }

  if(showGrad && pal.length){
    const stops = pal.map(rgb=>toHex(rgb)).join(', ');
    gradientEl.style.background = `linear-gradient(90deg, ${stops})`;
    gradientEl.hidden = false;
  }else{
    gradientEl.hidden = true;
  }
}

/* processing loop */
const offCtx = off.getContext('2d', {willReadFrequently:true});
function tick(now){
  const dt = now - lastT;
  if(dt>=500){ fps = Math.round((frameCounter*1000)/dt); fpsEl.textContent=String(fps); frameCounter=0; lastT=now; }
  frameCounter++;

  if(video.readyState>=2){
    if(tick._skip===undefined) tick._skip=0;
    if(tick._skip<=0){
      const {sx,sy,sw,sh} = computeSquareCrop();
      if(sw>0){
        off.width = procWidth; off.height = procWidth;
        offCtx.drawImage(video, sx,sy,sw,sh, 0,0,procWidth,procWidth);
        const img = offCtx.getImageData(0,0,procWidth,procWidth);
        const pixels = samplePixels(img, 6);

        if(algo==='kmeans')      lastPaletteKmax = kmeansKmax(pixels, KMAX);
        else if(algo==='hist')   lastPaletteKmax = histogramKmax(pixels, KMAX);
        else                     lastPaletteKmax = medianCutKmax(pixels, KMAX);

        if(lastPaletteKmax && lastPaletteKmax.length){
          renderPalette(lastPaletteKmax.slice(0, Math.min(K, lastPaletteKmax.length)));
        }
      }
      tick._skip = throttleN;
    }else{
      tick._skip--;
    }
  }
  requestAnimationFrame(tick);
}

/* ===== camera start ===== */
async function startCamera(){
  try{
    status('Requesting camera…');
    const cstr = {
      audio:false,
      video:{ facingMode:{ideal:'environment'}, width:{ideal:1280}, height:{ideal:1280}, frameRate:{ideal:30} }
    };
    const stream = await navigator.mediaDevices.getUserMedia(cstr);
    video.setAttribute('playsinline','');
    video.muted = true;
    video.srcObject = stream;

    await new Promise((res)=>video.addEventListener('loadedmetadata', res, {once:true}));
    try{ await video.play(); }catch(_){}
    resEl.textContent = `${video.videoWidth}×${video.videoHeight}`;
    status('Live');
  }catch(err){
    console.error(err);
    status('Camera error');
    toast(err?.message || 'Camera failed');
  }
}

/* ===== freeze / unfreeze ===== */
function freezeNow(){
  try{
    const wrap = document.getElementById('videoPane');
    const w = wrap.clientWidth, h = wrap.clientHeight;
    compositeCanvas.width = w; compositeCanvas.height = h;
    const ctx = compositeCanvas.getContext('2d', {willReadFrequently:true});
    const vw = video.videoWidth || 0, vh = video.videoHeight || 0;
    if(vw && vh){
      const z = Math.max(1, uiZoom);
      const base = Math.min(vw, vh);
      const sw = Math.round(base / z);
      const sx = Math.floor((vw - sw)/2);
      const sy = Math.floor((vh - sw)/2);
      ctx.drawImage(video, sx, sy, sw, sw, 0, 0, w, h);
    }else{
      ctx.fillStyle = '#000'; ctx.fillRect(0,0,w,h);
    }
    compositeImg.src = compositeCanvas.toDataURL('image/jpeg', 0.9);
    compositeOverlay.classList.add('open');
    status('Frozen');
  }catch(e){
    toast('Freeze failed: ' + (e?.message||'unknown'));
  }
}
function unfreeze(){
  compositeOverlay.classList.remove('open');
  status('Live');
}

/* ===== wire up + start ===== */
renderAlgoBrief(); highlightAlgoDesc(algo);
sizeVal.textContent=procWidth+' px';
kVal.textContent=String(K);
throttleVal.textContent=String(throttleN);
throttleLog.value = String(nToSlider(throttleN));

freezeBtn.addEventListener('click', freezeNow);
unfreezeBtn.addEventListener('click', unfreeze);

window.addEventListener('pageshow', ()=>{
  startCamera();
  requestAnimationFrame(tick);
}, {once:true});
</script>
</body>
</html>