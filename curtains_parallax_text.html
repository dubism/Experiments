<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Curtain ‚Äî Period Control (Single File)</title>
<style>
  :root{
    --bg:#0a0b0d; --ink:#f5f6f8; --muted:#9aa3b2;
    --line:#1a2130; --accent:#7ec8ff; --accent2:#65f0c7;
    --phase: 0;           /* JS updates this 0..1 */
    --open: 0;            /* triangle-mapped 0..1 (0 closed, 1 widest) */
    --epsilon: 0.002;     /* snap window for 0/1 */
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; background:radial-gradient(1200px 800px at 10% -10%, #0e1727 0%, #0a0b0d 50%, #07080b 100%);
    color:var(--ink); font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Inter, sans-serif;
  }

  /* ===== Controls ===== */
  header{
    position:sticky; top:0; z-index:30;
    background:linear-gradient(#10131a,#0c0f15); border-bottom:1px solid #151b26;
    box-shadow:0 6px 18px rgba(0,0,0,.35);
  }
  .wrap{max-width:1080px;margin:0 auto;padding:12px 14px}
  h1{margin:0;font-size:15px;letter-spacing:.25px}
  .grid{
    display:grid; gap:10px; grid-template-columns:repeat(12,1fr); align-items:center; margin-top:10px;
  }
  .cell{display:flex; gap:8px; align-items:center}
  .cell label{font-size:11px; color:var(--muted); white-space:nowrap}
  .seg{display:inline-flex; border:1px solid #26314a; border-radius:10px; overflow:hidden}
  .seg button{
    border:0; background:#101622; color:#e6edf7; padding:.44rem .66rem; font-weight:650; cursor:pointer;
    border-right:1px solid #26314a;
  }
  .seg button:last-child{border-right:0}
  .seg button[aria-pressed="true"]{background:#162033}
  input[type=number], input[type=text]{
    width:94px; background:#0b0f16; border:1px solid #1e293e; border-radius:9px; color:var(--ink);
    padding:.42rem .55rem; outline:none;
  }
  input[type=range]{width:100%}
  input[type=checkbox]{transform:translateY(1px)}
  .btn{
    border:1px solid #283552; background:#101622; color:#e6edf7; padding:.46rem .68rem; border-radius:10px;
    font-weight:700; letter-spacing:.2px; cursor:pointer;
  }
  .btn:hover{background:#132035}
  .muted{color:var(--muted); font-size:12px}
  .stat{
    display:flex; gap:10px; flex-wrap:wrap; align-items:center; font-variant-numeric:tabular-nums;
    background:#0b1019; border:1px solid #172137; padding:8px 10px; border-radius:10px;
  }
  .pill{padding:.2rem .5rem; border:1px solid #27324a; border-radius:999px; background:#0d1320}

  /* ===== Stage / curtains ===== */
  .stage{
    position:fixed; inset:0; z-index:0; pointer-events:none;
    display:grid; place-items:center;
  }
  .back{
    position:absolute; inset:0;
    background:
      radial-gradient(600px 420px at 88% 20%, rgba(101,240,199,.10), transparent 55%),
      radial-gradient(520px 360px at 20% 80%, rgba(126,200,255,.14), transparent 60%),
      linear-gradient(180deg, #0d111a, #0a0c12 60%, #080a0d);
  }
  .circle{
    width:min(45vmin,520px); aspect-ratio:1/1; border-radius:50%;
    background:radial-gradient(circle at 50% 40%, rgba(255,255,255,.15), rgba(255,255,255,.06) 35%, transparent 60%),
               radial-gradient(circle at 50% 65%, rgba(255,255,255,.08), rgba(255,255,255,0) 45%);
    outline:1px solid rgba(255,255,255,.06);
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.06), 0 30px 80px rgba(0,0,0,.55);
    filter:drop-shadow(0 30px 60px rgba(0,0,0,.5));
  }

  /* Two orientations we can clean-switch between */
  .curtains.dir-x, .curtains.dir-y{position:absolute; inset:0; display:flex; pointer-events:none}
  .curtains.dir-x{flex-direction:row}
  .curtains.dir-y{flex-direction:column}

  .panel{
    flex:1 1 50%;
    background:rgba(245,246,248,.10);
    backdrop-filter:saturate(120%) blur(10px);
    border:1px solid rgba(200,210,230,.10);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.03), 0 10px 26px rgba(0,0,0,.35);
    transform:scaleX(1); transform-origin:center;
    will-change:transform, opacity;
  }
  /* Edges shading */
  .panel::after{
    content:""; position:absolute; inset:0;
    background:linear-gradient(90deg, rgba(255,255,255,.05), rgba(255,255,255,0) 18%, rgba(255,255,255,0) 82%, rgba(255,255,255,.05));
    pointer-events:none;
  }
  /* orientation-specific transform-origins so scaling opens from center */
  .dir-x .panel:nth-child(1){transform-origin:right center}
  .dir-x .panel:nth-child(2){transform-origin:left center}
  .dir-y .panel:nth-child(1){transform-origin:center bottom}
  .dir-y .panel:nth-child(2){transform-origin:center top}

  /* We show only the active orientation; body gets .o-x or .o-y */
  .curtains{display:none}
  body.o-x .curtains.dir-x{display:flex}
  body.o-y .curtains.dir-y{display:flex}

  /* ===== Debug/status stripe ===== */
  .footer{
    position:fixed; bottom:8px; left:50%; transform:translateX(-50%); z-index:20;
    background:#0b1019; border:1px solid #172137; border-radius:12px; padding:8px 10px;
    box-shadow:0 10px 24px rgba(0,0,0,.45);
  }
  .kbd{font:11px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; color:#cfe4ff}

  /* Scroll rail (only used in scroll / hybrid to give you something to scrub) */
  .rail{
    position:relative; z-index:1; max-width:1080px; margin:24px auto; color:#cbd6e7;
  }
  .tick{
    height:40px; border-left:1px dashed #28406b; margin-left:6px; position:relative;
  }
  .tick span{
    position:absolute; left:10px; top:-2px; font-size:11px; color:#8fa6c9;
    background:#0b1019; border:1px solid #172137; padding:2px 6px; border-radius:999px;
  }

  @media (max-width:820px){
    .grid{grid-template-columns:repeat(6,1fr)}
  }
</style>
</head>
<body class="o-x">
  <header>
    <div class="wrap">
      <h1>üéõ Curtain ‚Äî Period Control</h1>
      <div class="grid">
        <!-- Mode -->
        <div class="cell" style="grid-column:span 3">
          <label>Mode</label>
          <div class="seg" role="group" aria-label="Mode">
            <button id="mTime"   aria-pressed="true">Time</button>
            <button id="mHybrid" aria-pressed="false">Hybrid</button>
            <button id="mScroll" aria-pressed="false">Scroll</button>
          </div>
        </div>

        <!-- Period -->
        <div class="cell" style="grid-column:span 5">
          <label>Period (s)</label>
          <input id="periodRange" type="range" min="0.2" max="60" step="0.1" value="8">
          <input id="periodNum" type="number" min="0.2" max="120" step="0.1" value="8" />
        </div>

        <!-- BPM -->
        <div class="cell" style="grid-column:span 2">
          <label>BPM</label>
          <input id="bpmNum" type="number" min="20" max="300" step="1" value="75" />
        </div>

        <!-- Play / Pause & Phase -->
        <div class="cell" style="grid-column:span 2">
          <button id="playPause" class="btn" title="Space toggles">Pause</button>
          <button id="tap" class="btn" title="Tap tempo (T)">Tap</button>
        </div>

        <!-- Clean switch -->
        <div class="cell" style="grid-column:span 3">
          <label><input id="cleanSwitch" type="checkbox" checked> Clean-switch at œÜ=0/1</label>
          <label class="muted">Œµ</label>
          <input id="eps" type="number" min="0" max="0.02" step="0.001" value="0.002" />
        </div>

        <!-- Scroll span -->
        <div class="cell" style="grid-column:span 3">
          <label>Scroll span (px / cycle)</label>
          <input id="spanPx" type="number" min="300" step="50" value="4000" />
        </div>

        <!-- Phase jump -->
        <div class="cell" style="grid-column:span 4">
          <button id="to0" class="btn" title="1">œÜ ‚Üê 0</button>
          <button id="toHalf" class="btn" title="H">œÜ ‚Üê 0.5</button>
          <button id="to1" class="btn" title="2">œÜ ‚Üê 1</button>
          <span class="muted">Orientation:</span>
          <div class="seg" role="group" aria-label="Orientation">
            <button id="oX" aria-pressed="true">Horizontal</button>
            <button id="oY" aria-pressed="false">Vertical</button>
          </div>
        </div>

        <!-- Cues -->
        <div class="cell" style="grid-column:span 12">
          <label>Cues (phase list)</label>
          <input id="cues" type="text" value="0,0.25,0.5,0.75,1">
          <button id="applyCues" class="btn">Apply cues</button>
          <span class="muted">Fires when œÜ crosses values (wrap-aware).</span>
        </div>

        <!-- Status -->
        <div class="cell" style="grid-column:span 12">
          <div class="stat">
            <span class="pill">œÜ=<span id="phi">0.000</span></span>
            <span class="pill">open=<span id="open">0.000</span></span>
            <span class="pill">cycle=<span id="cyc">0</span></span>
            <span class="pill">period=<span id="per">8000</span>ms</span>
            <span class="pill">mode=<span id="modeLbl">time</span></span>
            <span class="pill">fps=<span id="fps">‚Äî</span></span>
            <span class="muted">Keys: <span class="kbd">Space</span> play/pause ¬∑ <span class="kbd">T</span> tap ¬∑ <span class="kbd">1</span>/<span class="kbd">2</span> œÜ=0/1 ¬∑ <span class="kbd">H</span> œÜ=.5</span>
          </div>
        </div>
      </div>
    </div>
  </header>

  <!-- Fixed visual stage -->
  <div class="stage" aria-hidden="true">
    <div class="back"></div>
    <div class="circle"></div>

    <div class="curtains dir-x">
      <div class="panel"></div>
      <div class="panel"></div>
    </div>

    <div class="curtains dir-y">
      <div class="panel"></div>
      <div class="panel"></div>
    </div>
  </div>

  <!-- Scroll rail to scrub in scroll/hybrid -->
  <main class="rail" id="rail"></main>

  <div class="footer stat">
    <span>Clean-switch defers class changes to œÜ‚àà{0,1}. Period control is exact; phase snaps within Œµ.</span>
  </div>

<script>
/* =========================
   Curtain Clock (phase œÜ)
   ========================= */
function createCurtainClock(opts={}){
  const cfg = {
    mode: 'time',            // 'time' | 'scroll' | 'hybrid'
    periodMs: 8000,          // one cycle duration
    bpm: null,               // alternative (60_000 / bpm)
    phaseOffset: 0,          // 0..1
    epsilon: 0.002,          // snap hard 0/1 ¬±Œµ
    cleanSwitch: true,       // defer side-effects to œÜ==0 or œÜ==1
    // scroll mapping
    scrollStartPx: 0,
    scrollSpanPx: 4000,
    hybridNudge: 0.12,       // 0..1 bias toward scroll
    cues: [0, 0.25, 0.5, 0.75, 1],
    onCue: (i, phase, cycle)=>{},
    onTick: (phase, cycle)=>{},
    ...opts
  };
  if (cfg.bpm) cfg.periodMs = 60000 / cfg.bpm;

  let rafId = null, running = true;
  let t0 = performance.now();
  let baseCycle = 0;
  let lastPhase = 0;
  let pending = [];
  let lastCueSide = 0; // monotonically increasing cue id for display (not used functionally)

  const taps = [];

  const now = ()=>performance.now();
  const norm = v => { v = v % 1; return v < 0 ? v + 1 : v; };
  const snapHard01 = p => (p < cfg.epsilon ? 0 : (p > 1 - cfg.epsilon ? 1 : p));
  const setCSSPhase = p => document.documentElement.style.setProperty('--phase', String(p));

  function timePhase(n){
    const dt = n - t0;
    const cyc = dt / cfg.periodMs;
    baseCycle = Math.floor(cyc);
    return norm((cyc - baseCycle) + cfg.phaseOffset);
  }
  function scrollPhase(){
    const y = window.scrollY || document.documentElement.scrollTop || 0;
    const u = (y - cfg.scrollStartPx) / cfg.scrollSpanPx; // cycles since start
    baseCycle = Math.floor(u);
    return norm(u - baseCycle + cfg.phaseOffset);
  }
  function hybridPhase(n){
    const pt = timePhase(n);
    const ps = scrollPhase();
    let diff = ps - pt;
    if (diff >  0.5) diff -= 1;
    if (diff < -0.5) diff += 1;
    return norm(pt + cfg.hybridNudge * diff);
  }
  function phaseAt(n){
    switch(cfg.mode){
      case 'scroll': return scrollPhase();
      case 'hybrid': return hybridPhase(n);
      default:       return timePhase(n);
    }
  }

  // cue crossing detection
  function checkCues(prev, curr){
    // handle wrap (prev > curr)
    const wrapped = curr < prev;
    const xs = cfg.cues.slice().sort((a,b)=>a-b).map(norm);
    for (let i=0;i<xs.length;i++){
      const c = xs[i];
      const hit = wrapped ? (prev < 1 && (prev < c || c <= curr)) : (prev < c && c <= curr);
      if (hit){
        try { cfg.onCue(i, curr, baseCycle + (wrapped ? 1 : 0)); lastCueSide++; } catch(e){ console.warn(e); }
      }
    }
  }

  // tick loop
  let fpsAcc=0, fpsCount=0, fpsLast=now(), fps=0;
  const tick = ()=>{
    const n = now();
    let p = phaseAt(n);
    p = snapHard01(p);

    // cues
    checkCues(lastPhase, p);
    lastPhase = p;

    // CSS + external tick
    setCSSPhase(p);
    try { cfg.onTick(p, baseCycle); } catch(e){}

    // fps calc (approx)
    fpsAcc += 1; fpsCount += 1;
    if (n - fpsLast >= 500){
      fps = Math.round((fpsAcc / (n - fpsLast)) * 1000);
      document.getElementById('fps').textContent = fps;
      fpsLast = n; fpsAcc = 0;
    }

    if (running) rafId = requestAnimationFrame(tick);
  };

  // public API
  function play(){
    if (!running){
      running = true;
      t0 = now() - lastPhase * cfg.periodMs;
      rafId = requestAnimationFrame(tick);
    }
  }
  function pause(){ running = false; if (rafId) cancelAnimationFrame(rafId); rafId = null; }

  function setPeriodMs(ms){
    cfg.periodMs = Math.max(1, +ms || 1);
    if (cfg.mode !== 'scroll') t0 = now() - lastPhase * cfg.periodMs;
  }
  function setBPM(bpm){ setPeriodMs(60000 / Math.max(1, +bpm || 1)); }
  function setMode(m){ cfg.mode = m; if (m !== 'scroll') t0 = now() - lastPhase * cfg.periodMs; }
  function setPhase(phi){
    phi = norm(+phi || 0);
    lastPhase = phi;
    if (cfg.mode === 'scroll'){
      const y = cfg.scrollStartPx + phi * cfg.scrollSpanPx;
      window.scrollTo({ top:y, left:0, behavior:'auto' });
    } else {
      t0 = now() - phi * cfg.periodMs;
    }
    setCSSPhase(phi);
  }
  function setOffset(off){ cfg.phaseOffset = norm(+off || 0); }
  function setScrollSpan(px){ cfg.scrollSpanPx = Math.max(1, +px || 1); }
  function setCues(arr){ cfg.cues = arr.map(x=>norm(+x)).sort((a,b)=>a-b); }
  function onCue(cb){ cfg.onCue = cb; }
  function onTick(cb){ cfg.onTick = cb; }
  function setEpsilon(e){ cfg.epsilon = Math.max(0, +e || 0); }
  function setCleanSwitch(v){ cfg.cleanSwitch = !!v; }
  function clean(fn){ if (!cfg.cleanSwitch) return fn(); pending.push(fn); }

  function tapTempo(){
    const t = now();
    taps.push(t);
    if (taps.length > 6) taps.shift();
    if (taps.length >= 3){
      const ivals = [];
      for (let i=1;i<taps.length;i++) ivals.push(taps[i]-taps[i-1]);
      const avg = ivals.reduce((a,b)=>a+b,0)/ivals.length;
      setPeriodMs(Math.max(200, Math.min(60000, avg)));
    }
  }

  // Clean-switch executor: run deferred at exact 0 or 1
  onTick((œÜ)=>{
    if (!cfg.cleanSwitch) return;
    if (œÜ === 0 || œÜ === 1){
      const batch = pending.slice(); pending.length = 0;
      for (const fn of batch){ try{ fn(); }catch(e){ console.warn(e); } }
    }
  });

  // start
  setCSSPhase(0);
  rafId = requestAnimationFrame(tick);

  return { play, pause, setPeriodMs, setBPM, setMode, setPhase, setOffset,
           setScrollSpan, setCues, onCue, onTick, setEpsilon, setCleanSwitch,
           tapTempo, clean };
}

/* =========================
   Demo Wiring
   ========================= */
const curtains = createCurtainClock({
  mode:'time',
  periodMs:8000,
  scrollSpanPx:4000,
  cues:[0, 0.5, 1],
  onCue(i, œÜ, cyc){
    // Example: at œÜ=0 switch orientation each cycle, but only via clean-switch.
    if (i === 0){
      curtains.clean(()=>{
        const body = document.body;
        const oX = body.classList.contains('o-x');
        body.classList.toggle('o-x', !oX);
        body.classList.toggle('o-y',  oX);
      });
    }
  },
  onTick(œÜ, cyc){
    // Compute triangle open amount (0 closed, 1 widest at œÜ=0.5)
    const open = 1 - Math.abs(1 - 2*œÜ);

    // Apply transforms to both orientations; only one is visible.
    const xPanels = document.querySelectorAll('.curtains.dir-x .panel');
    xPanels[0].style.transform = `scaleX(${1-open})`;
    xPanels[1].style.transform = `scaleX(${1-open})`;
    const yPanels = document.querySelectorAll('.curtains.dir-y .panel');
    yPanels[0].style.transform = `scaleY(${1-open})`;
    yPanels[1].style.transform = `scaleY(${1-open})`;

    // Stats
    document.documentElement.style.setProperty('--open', String(open));
    document.getElementById('phi').textContent  = œÜ.toFixed(3);
    document.getElementById('open').textContent = open.toFixed(3);
    document.getElementById('cyc').textContent  = String(cyc);
    document.getElementById('per').textContent  = String(Math.round(getPeriod()));
  }
});

window.CURTAIN = curtains; // for console debugging

function getPeriod(){
  // a tiny helper because we don't expose a getter
  const per = document.getElementById('per').textContent;
  return +per || 8000;
}

/* ===== UI bindings ===== */
const periodRange = document.getElementById('periodRange');
const periodNum   = document.getElementById('periodNum');
const bpmNum      = document.getElementById('bpmNum');
const spanPx      = document.getElementById('spanPx');
const playPause   = document.getElementById('playPause');
const tapBtn      = document.getElementById('tap');
const modeLbl     = document.getElementById('modeLbl');
const epsInput    = document.getElementById('eps');
const cleanSwitch = document.getElementById('cleanSwitch');
const mTime   = document.getElementById('mTime');
const mHybrid = document.getElementById('mHybrid');
const mScroll = document.getElementById('mScroll');
const to0     = document.getElementById('to0');
const to1     = document.getElementById('to1');
const toHalf  = document.getElementById('toHalf');
const oX      = document.getElementById('oX');
const oY      = document.getElementById('oY');
const cuesInp = document.getElementById('cues');
const cuesBtn = document.getElementById('applyCues');
const rail    = document.getElementById('rail');

function setModeUI(mode){
  mTime.setAttribute('aria-pressed', String(mode==='time'));
  mHybrid.setAttribute('aria-pressed', String(mode==='hybrid'));
  mScroll.setAttribute('aria-pressed', String(mode==='scroll'));
  modeLbl.textContent = mode;
  rebuildRail();
}

function syncPeriodInputs(ms){
  const s = ms/1000;
  periodRange.value = String(s);
  periodNum.value   = String(s.toFixed(2).replace(/\.00$/,''));
  const bpm = Math.round(60000 / ms);
  bpmNum.value = String(bpm);
}

function parseCuesString(s){
  return s.split(/[, ]+/).map(x=>x.trim()).filter(Boolean).map(Number).filter(x=>isFinite(x));
}

/* Events */
periodRange.addEventListener('input', e=>{
  const ms = +e.target.value * 1000;
  curtains.setPeriodMs(ms);
  syncPeriodInputs(ms);
});
periodNum.addEventListener('change', e=>{
  const ms = Math.max(200, +e.target.value * 1000);
  curtains.setPeriodMs(ms);
  syncPeriodInputs(ms);
});
bpmNum.addEventListener('change', e=>{
  curtains.setBPM(+e.target.value);
  // read back effective period to sync displays
  const ms = Math.round(60000 / Math.max(1, +e.target.value || 1));
  syncPeriodInputs(ms);
});
spanPx.addEventListener('change', e=>{
  curtains.setScrollSpan(+e.target.value);
  rebuildRail();
});
playPause.addEventListener('click', ()=>{
  const pausing = playPause.textContent.trim().toLowerCase() !== 'pause' ? false : true;
  if (pausing){ curtains.pause(); playPause.textContent = 'Play'; }
  else { curtains.play(); playPause.textContent = 'Pause'; }
});
tapBtn.addEventListener('click', ()=>{ curtains.tapTempo(); syncPeriodInputs(estimateCurrentPeriod()); });

mTime.addEventListener('click', ()=>{ curtains.setMode('time'); setModeUI('time'); });
mHybrid.addEventListener('click', ()=>{ curtains.setMode('hybrid'); setModeUI('hybrid'); });
mScroll.addEventListener('click', ()=>{ curtains.setMode('scroll'); setModeUI('scroll'); });

to0.addEventListener('click', ()=>curtains.setPhase(0));
to1.addEventListener('click', ()=>curtains.setPhase(1));
toHalf.addEventListener('click', ()=>curtains.setPhase(0.5));

oX.addEventListener('click', ()=>{
  oX.setAttribute('aria-pressed','true'); oY.setAttribute('aria-pressed','false');
  curtains.clean(()=>{ document.body.classList.add('o-x'); document.body.classList.remove('o-y'); });
});
oY.addEventListener('click', ()=>{
  oX.setAttribute('aria-pressed','false'); oY.setAttribute('aria-pressed','true');
  curtains.clean(()=>{ document.body.classList.add('o-y'); document.body.classList.remove('o-x'); });
});

epsInput.addEventListener('change', e=>{
  curtains.setEpsilon(+e.target.value);
  document.documentElement.style.setProperty('--epsilon', String(+e.target.value));
});
cleanSwitch.addEventListener('change', e=>{
  curtains.setCleanSwitch(e.target.checked);
});

cuesBtn.addEventListener('click', ()=>{
  const arr = parseCuesString(cuesInp.value);
  if (arr.length) curtains.setCues(arr);
});

/* Keyboard shortcuts */
window.addEventListener('keydown', (ev)=>{
  if (ev.key === ' '){ ev.preventDefault(); playPause.click(); }
  if (ev.key === '1'){ curtains.setPhase(0); }
  if (ev.key.toLowerCase() === 'h'){ curtains.setPhase(0.5); }
  if (ev.key === '2'){ curtains.setPhase(1); }
  if (ev.key.toLowerCase() === 't'){ curtains.tapTempo(); syncPeriodInputs(estimateCurrentPeriod()); }
});

/* Helpers */
function estimateCurrentPeriod(){
  // read from inputs (authoritative)
  const s = parseFloat(periodNum.value); return isFinite(s) ? s*1000 : 8000;
}

/* Build scroll rail markers so you can scrub cleanly */
function rebuildRail(){
  rail.innerHTML = '';
  const mode = mTime.getAttribute('aria-pressed')==='true' ? 'time'
             : mHybrid.getAttribute('aria-pressed')==='true' ? 'hybrid'
             : 'scroll';
  const span = +spanPx.value || 4000;
  const cycles = mode==='time' ? 1 : 6; // show more space when scrubbing
  rail.style.minHeight = (mode==='time' ? '220px' : (cycles*span + 240) + 'px');

  if (mode !== 'time'){
    const start = 120; // some space below header
    for (let i=0;i<=cycles;i++){
      const tick = document.createElement('div');
      tick.className = 'tick';
      tick.style.marginTop = (i===0 ? (start+'px') : (span - 40) + 'px');
      const label = document.createElement('span');
      label.textContent = `cycle ${i}`;
      tick.appendChild(label);
      rail.appendChild(tick);
    }
  } else {
    const p = document.createElement('p');
    p.className='muted';
    p.textContent = 'Time mode: rail height is minimal. Use controls, not scroll.';
    rail.appendChild(p);
  }
}

/* Init UI state */
(function init(){
  syncPeriodInputs(8000);
  setModeUI('time');
  rebuildRail();
})();
</script>
</body>
</html>
