<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>_Curtains · Guard-railed Controls</title>
<style>
  :root{
    --period: 4000vh;     /* gradient cycle height (background only) */
    --stripes: 18;
    --gridCols: 10;
    --gridRows: 7;
  }

  html,body{min-height:100%; background:#000; color:#000; margin:0; font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}

  /* Background gradient (base layer) */
  body{
    background-image:
      linear-gradient(180deg,
        #9000FF00 0%, #3C00FF26 10%, #0011FF59 20%, #0099FF99 30%, #00FFEFD6 40%,
        #00FF55FF 50%, #66FF00F0 60%, #FFA6009C 70%, #FF37003F 80%, #FF130018 90%, #FF000000 100%
      ),
      linear-gradient(180deg,
        #9000FF00 0%, #3C00FF26 10%, #0011FF59 20%, #0099FF99 30%, #00FFEFD6 40%,
        #00FF55FF 50%, #66FF00F0 60%, #FFA6009C 70%, #FF37003F 80%, #FF130018 90%, #FF000000 100%
      );
    background-repeat: repeat-y, repeat-y;
    background-size: 100% var(--period), 100% var(--period);
    background-color:#050505;
  }

  /* ===== Layering: gradient -> images -> curtains -> text -> controls */
  .scene{ position: relative; z-index:0; }

  /* Image stack (does NOT push layout at top; appears below first viewport) */
  .imagesWrap{
    position:absolute; left:0; right:0; top:100vh; z-index:2;
    display:grid; place-items:center; will-change:transform;
  }
  .bgStack{ display:flex; flex-direction:column; gap:16px; }
  .bgStack img{
    width:100vw; max-width:100vw; height:auto; object-fit:cover; display:block;
    box-shadow:0 8px 26px rgba(0,0,0,.45);
  }

  /* Curtains overlay (sticky) */
  .pin{ position: sticky; top:0; height:100svh; height:100vh; overflow:hidden; z-index:5; pointer-events:none; }
  .layer{ position:absolute; inset:0; will-change:opacity,transform; }
  .vstripes{ display:flex; }
  .vstripes .stripe{ flex:1 0 auto; background:#fff; transform-origin:center center; will-change:transform,opacity; }
  .hstripes{ display:flex; flex-direction:column; }
  .hstripes .stripe{ flex:1 0 auto; background:#fff; transform-origin:center center; will-change:transform,opacity; }
  .grid{ display:grid; grid-template-columns: repeat(var(--gridCols), 1fr); grid-template-rows: repeat(var(--gridRows), 1fr); }
  .grid .cell{ background:#fff; will-change:transform,opacity; }
  .diag{ position:absolute; inset:-40% -40%; display:flex; }
  .diag.diag45{ transform: rotate(45deg); }
  .diag.diag135{ transform: rotate(-45deg); }
  .diag .stripe{ flex:1 0 auto; background:#fff; transform-origin:center center; will-change:transform,opacity; }

  /* Foreground text */
  .content{ position: relative; z-index:7; padding:12vh 20px 0; display:grid; place-items:center; }
  .content-inner{ width:min(860px, 92vw); display:grid; gap:22px; }
  .copy h1, .copy h2, .copy h3{ color:#000; margin:.1rem 0 .4rem; text-wrap:balance; }
  .copy h1{ font:800 clamp(22px,4.6vw,40px)/1.14 ui-sans-serif,system-ui; letter-spacing:.2px; }
  .copy h2{ font:700 clamp(16px,2.6vw,24px)/1.2 ui-sans-serif,system-ui; letter-spacing:.3px; text-transform:uppercase; }
  .copy h3{ font:700 14px/1.2 ui-sans-serif,system-ui; letter-spacing:.6px; text-transform:uppercase; opacity:.9; }
  .copy p{ margin:.45rem 0; font:14px/1.68 ui-sans-serif,system-ui; letter-spacing:.2px; hyphens:auto; color:#000; }
  .copy .lede{ font:15px/1.7 ui-sans-serif,system-ui; letter-spacing:.25px; }
  .copy .rule{ height:1px; background:linear-gradient(90deg,transparent,#000 45%,#000 55%,transparent); opacity:.25; margin:.8rem 0; }
  .copy blockquote{ margin:.8rem 0; padding:.4rem 0 .4rem 1rem; border-left:3px solid #000; font:italic 14px/1.6 ui-sans-serif,system-ui; color:#000; }
  .copy ul, .copy ol{ margin:.3rem 0 .2rem 1.2rem; padding:0; }
  .copy li{ font:14px/1.6 ui-sans-serif,system-ui; margin:.25rem 0; letter-spacing:.2px; color:#000; }
  .cols{ columns: 2 280px; column-gap: 26px; }
  .caption{ font:12px/1.5 ui-sans-serif,system-ui; letter-spacing:.2px; opacity:.95; color:#000; }
  .spacer{ height:12vh; }
  .imgSpacer{ height:0; }

  /* FAB */
  .fab{
    position:fixed; right:.75rem; bottom:.75rem;
    width:48px; height:48px; border-radius:50%;
    display:grid; place-items:center;
    background:#0f1117; border:1px solid rgba(255,255,255,.18);
    color:#fff; font-size:18px; line-height:1; cursor:pointer;
    box-shadow:0 8px 20px rgba(0,0,0,.35);
    z-index:30;
    touch-action:manipulation;
  }

  /* Control Center (CC) */
  .ctrlWrap{ position:fixed; left:0; right:0; bottom:0; display:flex; justify-content:center; z-index:29; pointer-events:none; padding:.5rem; }
  .ctrl{
    width:min(98vw, 1120px);
    background:rgba(0,0,0,.75); border:1px solid rgba(255,255,255,.18);
    border-radius:16px; padding:1rem 1rem 1.1rem;
    backdrop-filter: blur(8px);
    box-shadow: 0 12px 30px rgba(0,0,0,.55);
    pointer-events:auto;
    transform: translateY(110%); transition: transform .28s ease;
    color:#fff;
    max-height: min(78vh, 900px);
    overflow:auto;
  }
  .ctrl.open{ transform: translateY(0%); }
  .ctrl h3{ margin:.25rem 0 .5rem; font:700 12px/1.1 ui-monospace; letter-spacing:.25px; color:#fff; text-transform:uppercase; opacity:.95; }
  .grid3{ display:grid; grid-template-columns: repeat(3, minmax(0,1fr)); gap:.7rem .9rem; }
  .row{ display:grid; grid-template-columns: 220px 1fr 110px; align-items:center; gap:.55rem; }
  .row label{ font:12px/1 ui-monospace; opacity:.95; color:#fff; user-select:none; }
  .row input[type="range"], .row input[type="number"]{ width:100%; }
  .row input[type="number"]{ padding:.35rem .45rem; border-radius:10px; border:1px solid rgba(255,255,255,.18); background:#0f141d; color:#fff; font:12px ui-monospace; }
  .val{ text-align:right; font:12px/1 ui-monospace; opacity:.95; color:#fff; white-space:nowrap; }
  .row .chk{ display:flex; align-items:center; gap:.55rem; color:#fff; }
  .row .btns{ display:flex; gap:.5rem; flex-wrap:wrap; }
  .btn{ appearance:none; border:1px solid rgba(255,255,255,.25); background:#10141d; color:#fff; border-radius:12px; padding:.55rem .75rem; font:12px ui-monospace; cursor:pointer; touch-action:manipulation; }
  .sep{ height:1px; background:linear-gradient(90deg,transparent,rgba(255,255,255,.22),transparent); margin:.2rem 0; grid-column:1 / -1; }

  /* Big, friendly sliders */
  input[type="range"]{
    -webkit-appearance:none; appearance:none; height:38px; background:transparent;
    touch-action:manipulation;
  }
  input[type="range"]::-webkit-slider-runnable-track{
    height:10px; border-radius:999px; background:linear-gradient(180deg,rgba(255,255,255,.25),rgba(255,255,255,.18));
  }
  input[type="range"]::-webkit-slider-thumb{
    -webkit-appearance:none; appearance:none; width:22px; height:22px; border-radius:50%;
    background:#fff; border:0; margin-top:-6px; box-shadow:0 2px 6px rgba(0,0,0,.4);
  }
  input[type="range"]::-moz-range-track{
    height:10px; border-radius:999px; background:rgba(255,255,255,.2);
  }
  input[type="range"]::-moz-range-thumb{
    width:22px; height:22px; border-radius:50%; background:#fff; border:none; box-shadow:0 2px 6px rgba(0,0,0,.4);
  }
  .row input[type="range"]{ min-width: 380px; }
  @media (max-width:1100px){ .row{ grid-template-columns: 180px 1fr 90px; } .row input[type="range"]{ min-width: 300px; } }
  @media (max-width:860px){
    .grid3{ grid-template-columns: 1fr; }
    .row{ grid-template-columns: 150px 1fr 70px; }
    .row input[type="range"]{ min-width: 220px; }
  }

  /* HUD */
  .hud{
    position:fixed; left:.75rem; top:.75rem; width:340px; font:12px/1.25 ui-monospace;
    background:rgba(0,0,0,.6); border:1px solid rgba(255,255,255,.15); border-radius:10px; padding:.6rem .7rem; display:none; z-index:28; color:#fff;
  }
  .hud.on{display:block;}
  .bar{height:6px; background:rgba(255,255,255,.12); border-radius:4px; overflow:hidden; margin:.35rem 0 .2rem;}
  .bar > i{display:block; height:100%; width:0%; background:#fff; opacity:.85; border-radius:4px;}
  .hr{height:1px; background:rgba(255,255,255,.14); margin:.35rem 0;}
  .badge{ display:inline-block; padding:.08rem .35rem; border-radius:6px; font-weight:700; font-size:11px; vertical-align:baseline;}
  .ok{ background:#0b5135; color:#b6ffe0; }
  .warn{ background:#5c4b12; color:#ffe9a8; }
  .clamped{ background:#5b1c1c; color:#ffd0d0; }
</style>
</head>
<body>

  <section class="scene" id="scene">

    <!-- IMAGES (full-width, parallax, don't push initial view) -->
    <div class="imagesWrap" id="imagesWrap">
      <div class="bgStack" id="bgStack" aria-hidden="true"></div>
    </div>

    <!-- STICKY CURTAINS OVERLAY -->
    <div class="pin">
      <div class="layer vstripes" id="vLayer" aria-hidden="true"></div>
      <div class="layer hstripes" id="hLayer" aria-hidden="true"></div>
      <div class="layer grid" id="gLayer" aria-hidden="true"></div>
      <div class="layer diag diag45" id="d1Layer" aria-hidden="true"></div>
      <div class="layer diag diag135" id="d2Layer" aria-hidden="true"></div>
    </div>

    <!-- TEXT -->
    <div class="content" id="content">
      <div class="content-inner copy" id="copy">
        <div class="caption">Notes from the atelier — Field series</div>
        <h1>Quiet Headline for a Loud World</h1>
        <p class="lede">
          A paragraph to set cadence. Keep the voice calm. Use space as punctuation.
          Let motion be an accent, not the message.
        </p>
        <blockquote>“Design tells you what to pay attention to. The rest is noise.”</blockquote>

        <div class="rule"></div>

        <h2>Rhythm over spectacle</h2>
        <p>
          We aim for a tempo you can breathe with. Scroll is not a trigger—it’s a negotiation.
          The curtains modulate exposure; the images cooperate rather than perform.
        </p>
        <ul>
          <li>Hierarchy grows from contrast, not volume.</li>
          <li>Transitions should read as intent, not inertia.</li>
          <li>Use fewer elements; orchestrate more carefully.</li>
        </ul>

        <div class="rule"></div>

        <h2>Edges, weight, and silence</h2>
        <p>
          Thin edges feel faster; heavy blocks slow the scene. Silence is a weight class of its own.
          We calibrate all three as if they were type sizes.
        </p>
        <p>
          Pixels don’t know restraint. Designers do. This is where the controls speak the same
          language as composition: fewer knobs, broader ranges, predictable curves.
        </p>

        <div class="rule"></div>

        <h2>Interlude—field notes</h2>
        <div class="cols">
          <p>Typography: keep it black. No backplates. Let the contrast fight and win or lose.</p>
          <p>Motion: anchor it to meaning. Parallax is grammar—it clarifies which layer speaks.</p>
          <p>Sequencing: give users agency without confusion. The same gesture should say the same thing.</p>
        </div>

        <div class="rule"></div>

        <h2>Checklist for humane motion</h2>
        <ol>
          <li>Set a baseline pace; make deviations rare and legible.</li>
          <li>Keep reveals reversible; no traps.</li>
          <li>Prefer position-based logic to time-based suspense.</li>
        </ol>

        <div class="rule"></div>

        <h2>Close with intent</h2>
        <p>The project is a lens, not a mirror. If the lens shouts, we see the lens. Keep it quiet.</p>
        <p class="caption">— Draft, living document. Adjust in daylight.</p>

        <div class="spacer"></div>
      </div>

      <div class="imgSpacer" id="imgSpacer"></div>
    </div>

  </section>

  <!-- HUD + Controls -->
  <div class="hud" id="hud" role="status" aria-live="polite" aria-atomic="true">
    <div>p (0–1): <b id="pVal">0.00</b></div>
    <div class="bar"><i id="pBar"></i></div>
    <div>q (p*N): <b id="qVal">0.00</b></div>
    <div>open: <b id="oVal">0.00</b></div>
    <div class="hr"></div>
    <div>period px: <b id="hudPeriod">–</b></div>
    <div>eff none / overlap / eff closed: <b id="hudSegs">–</b></div>
    <div>stop-frames px: <b id="hudStop">–</b></div>
    <div>budget: <span id="budgetBadge" class="badge ok">ok</span></div>
  </div>

  <button class="fab" id="fab" aria-label="Show controls">⚙</button>
  <div class="ctrlWrap">
    <form class="ctrl" id="controls" onsubmit="return false;">
      <div class="grid3">

        <div>
          <h3>Timing</h3>
          <div class="row">
            <label for="inertia">Inertia</label>
            <input id="inertia" type="range" min="0" max="100" value="10" />
            <div class="val" id="inertiaVal">10</div>
          </div>
          <div class="row">
            <label for="snap">Snap</label>
            <input id="snap" type="range" min="40" max="95" value="85" />
            <div class="val" id="snapVal">85</div>
          </div>
          <div class="row">
            <label for="stages">Stages</label>
            <input id="stages" type="range" min="1" max="6" value="4" />
            <div class="val" id="stagesVal">4</div>
          </div>
          <div class="row">
            <label for="plateau">Plateau</label>
            <input id="plateau" type="range" min="0" max="100" value="10" />
            <div class="val" id="plateauVal">10</div>
          </div>
          <div class="row">
            <label for="hold">Hold (ms)</label>
            <input id="hold" type="range" min="0" max="600" value="120" />
            <div class="val" id="holdVal">120</div>
          </div>
          <div class="row chk">
            <input id="cleanSwitch" type="checkbox" checked />
            <label for="cleanSwitch">Clean switch at full-open/closed</label>
          </div>
        </div>

        <div>
          <h3>Parallax & Media</h3>
          <div class="row">
            <label for="parallax">Parallax ×</label>
            <input id="parallax" type="range" min="85" max="135" value="100" />
            <div class="val" id="parallaxVal">×1.00</div>
          </div>
          <div class="row btns">
            <button id="btnUpload" class="btn" type="button">Upload images…</button>
            <button id="btnClear" class="btn" type="button">Clear</button>
            <label class="chk"><input id="bgShow" type="checkbox" checked /> Show stack</label>
            <input id="imgInput" type="file" accept="image/*" multiple style="display:none" />
          </div>
        </div>

        <div>
          <h3>Effects (cycle order)</h3>
          <div class="row chk"><input id="effV" type="checkbox" checked /><label for="effV">Vertical stripes</label></div>
          <div class="row chk"><input id="effH" type="checkbox" checked /><label for="effH">Horizontal stripes</label></div>
          <div class="row chk"><input id="effG" type="checkbox" checked /><label for="effG">Grid push</label></div>
          <div class="row chk"><input id="effD45" type="checkbox" checked /><label for="effD45">Diagonal 45°</label></div>
          <div class="row chk"><input id="effD135" type="checkbox" /><label for="effD135">Diagonal 135°</label></div>
        </div>

        <div class="sep"></div>

        <!-- Pixel-based period + segments -->
        <div>
          <h3>Curtain Period (px)</h3>
          <div class="row">
            <label for="periodPx">Period px</label>
            <input id="periodPx" type="range" min="600" max="12000" value="1600" />
            <div class="val" id="periodPxVal">1600</div>
          </div>
          <div class="row">
            <label for="nonePx">Open hold px</label>
            <input id="nonePx" type="range" min="0" max="480" value="400" />
            <div class="val" id="nonePxVal">400</div>
          </div>
          <div class="row">
            <label for="closedPx">Closed hold px</label>
            <input id="closedPx" type="range" min="0" max="480" value="400" />
            <div class="val" id="closedPxVal">400</div>
          </div>
          <div class="row">
            <label for="overlapPx">Ramp px (per side)</label>
            <input id="overlapPx" type="range" min="48" max="400" value="300" />
            <div class="val" id="overlapPxVal">300</div>
          </div>
        </div>

        <div>
          <h3>Numbers</h3>
          <div class="row">
            <label>Period px</label>
            <input id="periodPxNum" type="number" min="600" max="20000" step="10" value="1600" />
            <div class="val">px</div>
          </div>
          <div class="row">
            <label>Open hold px</label>
            <input id="nonePxNum" type="number" min="0" max="12000" step="10" value="400" />
            <div class="val">px</div>
          </div>
          <div class="row">
            <label>Closed hold px</label>
            <input id="closedPxNum" type="number" min="0" max="12000" step="10" value="400" />
            <div class="val">px</div>
          </div>
          <div class="row">
            <label>Ramp px</label>
            <input id="overlapPxNum" type="number" min="0" max="8000" step="10" value="300" />
            <div class="val">px</div>
          </div>
        </div>

        <div>
          <h3>Stop-frames & Cycles</h3>
          <div class="row">
            <label for="stopPx">Stop-frames px</label>
            <input id="stopPx" type="range" min="0" max="300" value="0" />
            <div class="val" id="stopPxVal">0</div>
          </div>
          <div class="row">
            <label>Stop-frames px</label>
            <input id="stopPxNum" type="number" min="0" max="1000" step="10" value="0" />
            <div class="val">px</div>
          </div>
          <div class="row chk"><input id="enforceExtremes" type="checkbox" checked /><label for="enforceExtremes">Force exact 0% / 100% in holds</label></div>
          <div class="row chk"><input id="linkRampToPlateau" type="checkbox" /><label for="linkRampToPlateau">Shape ramps by Plateau</label></div>
          <div class="row">
            <label>Cycles (periods)</label>
            <input id="cyclesNum" type="number" min="1" max="12" step="1" value="6" />
            <div class="val">×</div>
          </div>
        </div>

      </div>
    </form>
  </div>

<script>
(() => {
  const clamp = (x, a=0, b=1) => Math.max(a, Math.min(b, x));
  const smooth = t => (t<0?0:(t>1?1:(t*t*(3-2*t)))); // C2 smoothstep
  const clampNum = (x,a,b)=> Math.max(a, Math.min(b, x));
  const vw = ()=> Math.max(document.documentElement.clientWidth,  window.innerWidth  || 0);
  const vh = ()=> Math.max(document.documentElement.clientHeight, window.innerHeight || 0);

  const scene   = document.getElementById('scene');
  const content = document.getElementById('content');
  const imgSpacer = document.getElementById('imgSpacer');
  const imagesWrap = document.getElementById('imagesWrap');
  const bgStack = document.getElementById('bgStack');

  const vLayer = document.getElementById('vLayer');
  const hLayer = document.getElementById('hLayer');
  const gLayer = document.getElementById('gLayer');
  const d1Layer = document.getElementById('d1Layer');
  const d2Layer = document.getElementById('d2Layer');

  const hud = document.getElementById('hud');
  const pBar = document.getElementById('pBar');
  const pVal = document.getElementById('pVal');
  const qVal = document.getElementById('qVal');
  const oVal = document.getElementById('oVal');
  const hudPeriod = document.getElementById('hudPeriod');
  const hudSegs = document.getElementById('hudSegs');
  const hudStop = document.getElementById('hudStop');
  const budgetBadge = document.getElementById('budgetBadge');

  const fab = document.getElementById('fab');
  const panel = document.getElementById('controls');

  const ctrl = {
    inertia: document.getElementById('inertia'),
    snap: document.getElementById('snap'),
    stages: document.getElementById('stages'),
    plateau: document.getElementById('plateau'),
    hold: document.getElementById('hold'),
    cleanSwitch: document.getElementById('cleanSwitch'),
    parallax: document.getElementById('parallax'),

    effV: document.getElementById('effV'),
    effH: document.getElementById('effH'),
    effG: document.getElementById('effG'),
    effD45: document.getElementById('effD45'),
    effD135: document.getElementById('effD135'),

    periodPx: document.getElementById('periodPx'),
    nonePx: document.getElementById('nonePx'),
    closedPx: document.getElementById('closedPx'),
    overlapPx: document.getElementById('overlapPx'),
    periodPxNum: document.getElementById('periodPxNum'),
    nonePxNum: document.getElementById('nonePxNum'),
    closedPxNum: document.getElementById('closedPxNum'),
    overlapPxNum: document.getElementById('overlapPxNum'),
    stopPx: document.getElementById('stopPx'),
    stopPxNum: document.getElementById('stopPxNum'),
    enforceExtremes: document.getElementById('enforceExtremes'),
    linkRampToPlateau: document.getElementById('linkRampToPlateau'),
    cyclesNum: document.getElementById('cyclesNum'),

    vals: {
      inertia: document.getElementById('inertiaVal'),
      snap: document.getElementById('snapVal'),
      stages: document.getElementById('stagesVal'),
      plateau: document.getElementById('plateauVal'),
      hold: document.getElementById('holdVal'),
      parallax: document.getElementById('parallaxVal'),
      periodPx: document.getElementById('periodPxVal'),
      nonePx: document.getElementById('nonePxVal'),
      closedPx: document.getElementById('closedPxVal'),
      overlapPx: document.getElementById('overlapPxVal'),
      stopPx: document.getElementById('stopPxVal'),
    },
    imgInput: document.getElementById('imgInput'),
    btnUpload: document.getElementById('btnUpload'),
    btnClear: document.getElementById('btnClear'),
    bgShow: document.getElementById('bgShow')
  };

  // sync helpers (slider <-> number)
  function linkRangeAndNumber(rangeEl, numEl, valEl){
    const sync = v=>{
      const min = parseInt(rangeEl.min||0), max = parseInt(rangeEl.max||100000);
      const n = Math.max(min, Math.min(max, parseInt(v||0)));
      rangeEl.value = n; numEl.value = n; if(valEl) valEl.textContent = n;
      enforceBudgetAndReflect();
    };
    rangeEl.addEventListener('input', ()=> sync(rangeEl.value), {passive:true});
    numEl.addEventListener('input', ()=> sync(numEl.value), {passive:true});
  }

  /* ------- Build geometry ------- */
  const STRIPES = 18, GRID_COLS=10, GRID_ROWS=7;
  for(let i=0;i<STRIPES;i++){
    const d = document.createElement('div');
    d.className = 'stripe';
    d.style.transformOrigin = (i%2 ? 'left center' : 'right center');
    vLayer.appendChild(d);
  }
  for(let i=0;i<STRIPES;i++){
    const d = document.createElement('div');
    d.className = 'stripe';
    d.style.transformOrigin = (i%2 ? 'center top' : 'center bottom');
    hLayer.appendChild(d);
  }
  for(let r=0;r<GRID_ROWS;r++){
    for(let c=0;c<GRID_COLS;c++){
      const cell = document.createElement('div');
      cell.className = 'cell';
      const nx = (c/(GRID_COLS-1))*2-1;
      const ny = (r/(GRID_ROWS-1))*2-1;
      cell.dataset.nx = nx.toFixed(3);
      cell.dataset.ny = ny.toFixed(3);
      cell.style.transformOrigin = (nx>0? 'right':'left') + ' ' + (ny>0? 'bottom':'top');
      gLayer.appendChild(cell);
    }
  }
  for(let i=0;i<STRIPES;i++){ d1Layer.appendChild(Object.assign(document.createElement('div'),{className:'stripe'})); }
  for(let i=0;i<STRIPES;i++){ d2Layer.appendChild(Object.assign(document.createElement('div'),{className:'stripe'})); }

  /* ------- Image upload (stack) ------- */
  let imgURLs = [];
  function clearImages(){ imgURLs.forEach(u=>URL.revokeObjectURL(u)); imgURLs=[]; bgStack.innerHTML=''; updateLayout(); }
  ctrl.btnUpload.addEventListener('click', ()=> ctrl.imgInput.click());
  ctrl.btnClear.addEventListener('click', ()=> clearImages());
  ctrl.bgShow.addEventListener('change', ()=> { imagesWrap.style.display = ctrl.bgShow.checked ? '' : 'none'; });
  ctrl.imgInput.addEventListener('change', (e)=>{
    const files = Array.from(e.target.files||[]);
    if(!files.length) return;
    clearImages();
    let loaded = 0;
    files.forEach(f => {
      const url = URL.createObjectURL(f);
      imgURLs.push(url);
      const im = document.createElement('img');
      im.loading='eager'; im.decoding='async'; im.src=url;
      im.onload = ()=>{ loaded++; if(loaded===files.length) updateLayout(); };
      bgStack.appendChild(im);
    });
  });

  /* ------- Effects guard (always at least one) ------- */
  function getEnabledPatterns(){
    const arr = [];
    if(ctrl.effV.checked) arr.push(0);
    if(ctrl.effH.checked) arr.push(1);
    if(ctrl.effG.checked) arr.push(2);
    if(ctrl.effD45.checked) arr.push(3);
    if(ctrl.effD135.checked) arr.push(4);
    if(!arr.length){ ctrl.effV.checked = true; arr.push(0); }
    return arr;
  }

  /* ------- Perceptual mins / domains ------- */
  function perceptualMins(){
    const Vh = vh();
    const minHoldPx  = clampNum(Math.round(0.12*Vh), 120, 360);
    const minRampPx  = clampNum(Math.round(0.06*Vh),  48, 240);
    const maxStopPx  = clampNum(Math.round(0.15*minHoldPx), 0, 300);
    return {minHoldPx, minRampPx, maxStopPx};
  }

  let lastClamped = false;

  function setDependentDomains(){
    const period = Math.max(600, parseInt(ctrl.periodPx.value||ctrl.periodPxNum.value)||1600);
    const {minHoldPx, minRampPx, maxStopPx} = perceptualMins();

    const maxHold   = Math.floor(0.40 * period);
    const maxRamp   = Math.floor(0.25 * period);
    const stopMax   = Math.min(maxStopPx, Math.floor(0.15 * period));

    // Update input attributes
    [
      [ctrl.nonePx,   ctrl.nonePxNum,   0, maxHold],
      [ctrl.closedPx, ctrl.closedPxNum, 0, maxHold],
      [ctrl.overlapPx,ctrl.overlapPxNum,minRampPx, maxRamp],
      [ctrl.stopPx,   ctrl.stopPxNum,   0, stopMax],
    ].forEach(([range,num,min,max])=>{
      range.min=min; range.max=max; num.min=min; num.max=max;
    });

    // Clamp current values into new domains
    lastClamped = false;
    function clampPair(range,num,min,max){
      const before = parseInt(range.value);
      const v = clampNum(before, min, max);
      if (v !== before) lastClamped = true;
      range.value = v; num.value = v;
    }
    clampPair(ctrl.nonePx,   ctrl.nonePxNum,   0, maxHold);
    clampPair(ctrl.closedPx, ctrl.closedPxNum, 0, maxHold);
    clampPair(ctrl.overlapPx,ctrl.overlapPxNum,minRampPx, maxRamp);
    clampPair(ctrl.stopPx,   ctrl.stopPxNum,   0, stopMax);

    // Snap range guard (couple lightly to inertia)
    const inertiaUi = (parseInt(ctrl.inertia.value)||0)/100; // 0..1
    ctrl.snap.value = String(clampNum(parseInt(ctrl.snap.value), 40, 95));
  }

  /* ------- Parameters ------- */
  function getParams(){
    const inertia = (parseInt(ctrl.inertia.value)||0)/100;
    const SCROLL_TAU = 0.04 + 1.16 * inertia;    // 0.04..1.20 s
    const OPEN_TAU   = 0.24 + 0.66 * inertia;

    const snapUi = (parseInt(ctrl.snap.value)||0)/100;
    const snapWindow = 0.02 + 0.25 * Math.pow(snapUi, 1.4);
    const snapSharp  = 1 + 28 * Math.pow(snapUi, 2.0);

    const stages = Math.max(1, Math.min(6, parseInt(ctrl.stages.value)||4));
    const plateau = (parseInt(ctrl.plateau.value)||0)/100;
    const holdMs = parseInt(ctrl.hold.value)||0;
    const cleanSwitch = ctrl.cleanSwitch.checked;

    const C = clampNum((parseInt(ctrl.parallax.value)||100)/100, 0.85, 1.35);
    const enabled = getEnabledPatterns();

    // Pixel period (values already domain-clamped by setDependentDomains)
    let periodPx = Math.max(600, parseInt(ctrl.periodPx.value||ctrl.periodPxNum.value)||1600);
    let nonePx   = parseInt(ctrl.nonePx.value||ctrl.nonePxNum.value)||0;
    let closedPx = parseInt(ctrl.closedPx.value||ctrl.closedPxNum.value)||0;
    let overlapPx= parseInt(ctrl.overlapPx.value||ctrl.overlapPxNum.value)||0;
    const stopPx = parseInt(ctrl.stopPx.value||ctrl.stopPxNum.value)||0;

    // Perceptual minima
    const {minHoldPx, minRampPx} = perceptualMins();

    // Hard feasibility lift for tiny period
    const minFeasible = 2*minRampPx + 2*stopPx + 2*minHoldPx;
    if (periodPx < minFeasible){
      periodPx = minFeasible;
      ctrl.periodPx.value = ctrl.periodPxNum.value = periodPx;
      lastClamped = true;
    }

    // Effective holds with non-negotiable stop-frames
    let effNoneBase = Math.max(nonePx,   minHoldPx);
    let effClosedBase = Math.max(closedPx, minHoldPx);
    let overlapEff = Math.max(overlapPx, minRampPx);
    const mandatory = stopPx;

    const needTotal = effNoneBase + effClosedBase + 2*overlapEff + 2*mandatory;

    if (needTotal > periodPx){
      lastClamped = true;
      // 1) Trim overlap first
      const maxForOverlap = Math.max(0, periodPx - (effNoneBase + effClosedBase + 2*mandatory));
      overlapEff = Math.max(minRampPx, Math.min(overlapEff, Math.floor(maxForOverlap/2)));

      // 2) If still over, proportionally trim base holds (keep mandatory & minHold)
      let stillNeed = effNoneBase + effClosedBase + 2*overlapEff + 2*mandatory - periodPx;
      if (stillNeed > 0){
        const baseSum = Math.max(1, effNoneBase + effClosedBase);
        const k = Math.max(0, (periodPx - (2*mandatory) - 2*overlapEff) / baseSum);
        effNoneBase   = Math.max(minHoldPx, Math.floor(effNoneBase * k));
        effClosedBase = Math.max(minHoldPx, Math.floor(effClosedBase * k));
      }
    }

    const effNone   = effNoneBase + mandatory;
    const effClosed = effClosedBase + mandatory;

    const enforceExtremes = ctrl.enforceExtremes.checked;
    const linkRampToPlateau = ctrl.linkRampToPlateau.checked;

    return {
      SCROLL_TAU, OPEN_TAU, snapWindow, snapSharp, stages, plateau, holdMs, cleanSwitch,
      C, enabled,
      periodPx,
      nonePx: effNoneBase, closedPx: effClosedBase, overlapPx: overlapEff, // show bases in UI
      stopPx,
      effNone, effClosed, overlapEff,
      enforceExtremes, linkRampToPlateau
    };
  }

  function reflectUI(P){
    ctrl.vals.inertia.textContent = Math.round(((P.SCROLL_TAU-0.04)/1.16)*100);
    ctrl.vals.snap.textContent = Math.round((Math.pow((P.snapWindow-0.02)/0.25, 1/1.4))*100);
    ctrl.vals.stages.textContent = P.stages;
    ctrl.vals.plateau.textContent = Math.round(P.plateau*100);
    ctrl.vals.hold.textContent = P.holdMs;
    ctrl.vals.parallax.textContent = '×'+P.C.toFixed(2);

    // Reflect (possibly clamped) base inputs back to fields
    ctrl.periodPx.value = ctrl.periodPxNum.value = P.periodPx;
    ctrl.nonePx.value   = ctrl.nonePxNum.value   = P.nonePx;
    ctrl.closedPx.value = ctrl.closedPxNum.value = P.closedPx;
    ctrl.overlapPx.value= ctrl.overlapPxNum.value= P.overlapPx;
    ctrl.stopPx.value   = ctrl.stopPxNum.value   = P.stopPx;

    ctrl.vals.periodPx.textContent = P.periodPx;
    ctrl.vals.nonePx.textContent   = P.nonePx;
    ctrl.vals.closedPx.textContent = P.closedPx;
    ctrl.vals.overlapPx.textContent= P.overlapPx;
    ctrl.vals.stopPx.textContent   = P.stopPx;

    hudPeriod.textContent = P.per
