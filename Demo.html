<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Real HUD: Horizon & Compass</title>
    <style>
        :root {
            --hud-color: #00ffaa;
            --hud-glow: 0 0 5px var(--hud-color), 0 0 10px var(--hud-color);
            --background-color: #020408;
        }

        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            color: var(--hud-color);
            font-family: 'Courier New', Courier, monospace;
            width: 100%;
            height: 100%;
        }

        #camera-view {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: translate(-50%, -50%) scaleX(-1);
            opacity: 0.4;
            z-index: 1;
        }

        #hud-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
        }
        
        #permission-prompt {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 10;
            font-size: 1.5em;
            cursor: pointer;
            text-shadow: var(--hud-glow);
        }
    </style>
</head>
<body>

    <video id="camera-view" autoplay playsinline></video>
    <canvas id="hud-canvas"></canvas>
    
    <div id="permission-prompt">
        TAP SCREEN TO<br>INITIALIZE SENSORS
    </div>

    <script>
        // --- DOM Elements ---
        const video = document.getElementById('camera-view');
        const canvas = document.getElementById('hud-canvas');
        const ctx = canvas.getContext('2d');
        const permissionPrompt = document.getElementById('permission-prompt');

        // --- State Variables ---
        let orientation = { alpha: 0, beta: 0, gamma: 0 }; // alpha: yaw, beta: pitch, gamma: roll
        let sensorsActive = false;
        
        // --- Setup & Permissions ---
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        async function init() {
            // Request Camera
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' } });
                video.srcObject = stream;
            } catch (err) {
                console.error("Camera access denied:", err);
                alert("Camera access is required for this experience.");
            }

            // Request Motion Sensors
            if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                // This is the modern way for iOS 13+
                const permission = await DeviceOrientationEvent.requestPermission();
                if (permission === 'granted') {
                    window.addEventListener('deviceorientation', handleOrientation);
                    sensorsActive = true;
                } else {
                    alert("Sensor access is required for the HUD.");
                    return;
                }
            } else {
                // This is for other browsers and older iOS
                window.addEventListener('deviceorientation', handleOrientation);
                sensorsActive = true;
            }
            
            permissionPrompt.style.display = 'none'; // Hide the prompt
            requestAnimationFrame(drawHUD); // Start the drawing loop
        }

        permissionPrompt.addEventListener('click', init, { once: true });
        
        function handleOrientation(event) {
            orientation.alpha = event.alpha || 0;
            orientation.beta = event.beta || 0;
            orientation.gamma = event.gamma || 0;
        }

        // --- HUD Drawing ---
        function drawHUD() {
            if (!sensorsActive) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Shared styles
            ctx.strokeStyle = 'var(--hud-color)';
            ctx.fillStyle = 'var(--hud-color)';
            ctx.shadowColor = 'var(--hud-color)';
            ctx.shadowBlur = 10;
            ctx.lineWidth = 2;

            drawArtificialHorizon();
            drawCompass();
            drawDataReadout();
            drawStaticElements();
            
            requestAnimationFrame(drawHUD);
        }

        function drawArtificialHorizon() {
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            
            // Convert degrees to radians for canvas functions
            const roll = orientation.gamma * (Math.PI / 180);
            const pitch = orientation.beta; // Pitch value directly affects vertical position
            
            // The pitch ladder moves up/down. Max movement capped at 90px.
            const pitchOffset = Math.max(-90, Math.min(90, pitch)) * 2;
            
            ctx.save();
            // Center the coordinate system and apply rotation and translation
            ctx.translate(centerX, centerY);
            ctx.rotate(roll);
            ctx.translate(0, pitchOffset); // Apply pitch after roll

            // Draw the horizon line
            ctx.beginPath();
            ctx.moveTo(-canvas.width, 0);
            ctx.lineTo(canvas.width, 0);
            ctx.stroke();
            
            // Draw pitch markers (simple lines for now)
            ctx.lineWidth = 1;
            for(let i = -4; i <= 4; i++) {
                if (i === 0) continue;
                const y = i * -40; // Pitch lines are 40px apart
                ctx.beginPath();
                ctx.moveTo(-40, y);
                ctx.lineTo(40, y);
                ctx.stroke();
            }

            ctx.restore(); // Reset transformations
        }
        
        function drawCompass() {
            const centerX = canvas.width / 2;
            const heading = orientation.alpha; // 0-360 degrees

            ctx.save();
            ctx.font = '16px "Courier New"';
            ctx.textAlign = 'center';
            
            // Draw heading markers
            for (let i = -4; i <= 4; i++) {
                const angle = Math.round(heading) + (i * 20);
                const xPos = centerX + (i * 80);
                
                let label;
                let normalizedAngle = (angle % 360 + 360) % 360;
                if (Math.abs(normalizedAngle - 0) < 10 || Math.abs(normalizedAngle - 360) < 10) label = 'N';
                else if (Math.abs(normalizedAngle - 90) < 10) label = 'E';
                else if (Math.abs(normalizedAngle - 180) < 10) label = 'S';
                else if (Math.abs(normalizedAngle - 270) < 10) label = 'W';
                else label = normalizedAngle;

                ctx.fillText(label, xPos, 50);
            }
            
            // Main heading indicator
            ctx.beginPath();
            ctx.moveTo(centerX, 60);
            ctx.lineTo(centerX - 10, 70);
            ctx.lineTo(centerX + 10, 70);
            ctx.closePath();
            ctx.fill();
            
            ctx.restore();
        }
        
        function drawDataReadout() {
            ctx.font = '12px "Courier New"';
            ctx.textAlign = 'left';
            const x = 20;
            const y = canvas.height - 50;
            ctx.fillText(`HDG: ${orientation.alpha.toFixed(1)}°`, x, y);
            ctx.fillText(`PCH: ${orientation.beta.toFixed(1)}°`, x, y + 15);
            ctx.fillText(`RLL: ${orientation.gamma.toFixed(1)}°`, x, y + 30);
        }

        function drawStaticElements() {
            // Static aircraft symbol / crosshair
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(centerX - 50, centerY);
            ctx.lineTo(centerX - 15, centerY);
            ctx.moveTo(centerX + 15, centerY);
            ctx.lineTo(centerX + 50, centerY);
            ctx.moveTo(centerX, centerY - 10);
            ctx.lineTo(centerX, centerY - 25);
            ctx.stroke();
        }
    </script>

</body>
</html>
