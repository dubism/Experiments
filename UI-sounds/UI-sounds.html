<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>UI Sounds — iPhone</title>
<style>
  :root{
    --bg:#0b0d10; --ink:#e7eef6; --muted:#9ab0c6;
    --card:#0f1318; --line:#1b2330; --accent:#79f5cc; --accent2:#3bd4ff;
    --glow: 0 8px 18px rgba(0,0,0,.45), 0 0 0 1px #1b2330 inset, 0 0 22px rgba(61,225,255,.18);
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;
    color:var(--ink); background: radial-gradient(1200px 800px at 10% 0%, #10202b 0%, #0b0d10 40%, #0b0d10 100%);
    -webkit-tap-highlight-color: transparent;
  }
  header{position:sticky;top:0;background:rgba(15,19,24,.85);backdrop-filter: blur(6px);border-bottom:1px solid var(--line);padding:14px 12px;z-index:10}
  h1{margin:0 0 4px;font-size:18px;letter-spacing:.2px}
  .row{display:flex;gap:12px;align-items:center;flex-wrap:wrap}
  .card{border:1px solid var(--line);background:rgba(15,19,24,.8);border-radius:16px;padding:14px;margin:14px;box-shadow:var(--glow)}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(120px,1fr));gap:10px}
  button.sound{
    padding:14px 10px;border-radius:18px;border:1px solid var(--line);background:linear-gradient(180deg,#14202b,#0f1318);
    color:var(--ink);cursor:pointer;box-shadow:var(--glow); position:relative; overflow:hidden;
    transition:transform .06s ease-out, filter .08s ease-out, box-shadow .2s ease;
    display:flex; align-items:center; justify-content:center; gap:8px; font-size:15px;
    touch-action: manipulation; user-select:none; -webkit-user-select:none;
  }
  button.sound::after{content:"";position:absolute;inset:0;background:radial-gradient(120px 40px at 50% 0%, rgba(255,255,255,.08), transparent 55%);pointer-events:none}
  button.sound:active{transform:scale(.97)}
  button.sound.pressed{transform:scale(.97); box-shadow:0 0 0 1px #2ad0ff inset, 0 0 30px rgba(58, 208, 255, .35)}
  .ok{color:var(--accent)}
  .overlay{position:fixed;inset:0;background:rgba(7,9,12,.9);display:flex;align-items:center;justify-content:center;z-index:1000}
  .panel{background:#0f1318;border:1px solid var(--line);border-radius:16px;padding:22px;max-width:460px;text-align:center;box-shadow:var(--glow)}
  .hint{color:var(--muted);font-size:14px;margin-top:6px}
  input[type="range"]{width:220px}
  .small{font-size:12px;color:var(--muted)}
  .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);padding:8px 12px;border-radius:999px;background:#111823}
  .chip{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:#0f151f;margin:4px 6px;font-size:12px}
  .dot{width:8px;height:8px;border-radius:50%;background:#6b7685;box-shadow:0 0 0 1px #1b2330}
  .dot.ok{background:#67f3c4}
  .dot.err{background:#ff6b6b}
  .scroller{display:flex;flex-wrap:wrap;margin-top:8px}
  .meter{height:10px;background:#0f1722;border:1px solid var(--line);border-radius:8px;overflow:hidden;min-width:180px}
  .fill{height:100%; background:linear-gradient(90deg, var(--accent), var(--accent2)); width:0%}
  .hide{display:none}
  .bubbly{animation:bob 3.2s ease-in-out infinite}
  @keyframes bob{ 0%,100%{ transform:translateY(0) } 50%{ transform:translateY(-2px) } }
</style>
</head>
<body>
  <div id="unlock" class="overlay">
    <div class="panel bubbly">
      <h2 style="margin:0 0 6px">Tap to enable sound</h2>
      <div class="hint">No permission prompt will appear. This just unlocks audio playback on iOS.</div>
      <div style="margin-top:14px">
        <button id="unlockBtn" class="sound" style="padding:12px 18px">Enable</button>
      </div>
      <div class="hint" id="unlockState"></div>
    </div>
  </div>

  <header>
    <h1 class="bubbly">UI Sounds — iPhone</h1>
    <div class="row">
      <span class="pill"><span>Volume</span> <input id="vol" type="range" min="0" max="1" step="0.01" value="0.9"></span>
      <label class="pill"><input id="cut" type="checkbox" checked> Cut previous</label>
      <span id="status" class="small">Scanning…</span>
      <span class="pill"><span>Found</span> <strong id="found">0</strong></span>
      <span class="pill"><span>Audio</span> <strong id="audioState">Locked</strong></span>
      <div class="meter"><div class="fill" id="meterFill"></div></div>
    </div>
  </header>

  <main class="card">
    <div id="chips" class="scroller"></div>
    <div class="grid" id="grid" style="margin-top:10px"></div>
    <div class="row" style="margin-top:16px">
      <button id="seq" class="sound">▶️ Quick playthrough</button>
      <button id="stopAll" class="sound">⏹️ Stop All</button>
    </div>
    <p class="small" style="margin-top:10px">
      Files are in <code>./sounds/</code>. We load <code>manifest.json</code> or probe <code>clip_001.wav…</code> if missing.
    </p>
  </main>

<script>
// ===== Utility =====
const $ = (sel) => document.querySelector(sel);
const statusEl = $("#status");
const volEl = $("#vol");
const cutEl = $("#cut");
const foundEl = $("#found");
const chipsEl = $("#chips");
const gridEl = $("#grid");
const meterFill = $("#meterFill");
const unlockOverlay = $("#unlock");
const unlockState = $("#unlockState");
const audioStateEl = $("#audioState");

function setStatus(msg, ok=false){ statusEl.textContent = msg; statusEl.classList.toggle("ok", ok); }
function setAudioState(){ audioStateEl.textContent = unlocked ? "Unlocked" : "Locked"; }

// Enable :active on iOS
document.body.addEventListener("touchstart", ()=>{}, {passive:true});

// ===== Discover files =====
async function fetchJSON(url){
  try{
    const res = await fetch(url, {cache:"no-store"});
    if(!res.ok) throw new Error(res.status);
    return await res.json();
  }catch(e){ return null; }
}

async function head(url){
  try{
    const res = await fetch(url, {method:"HEAD", cache:"no-store"});
    return res.ok;
  }catch(e){ return false; }
}

function chip(name, ok){
  const el = document.createElement("span");
  el.className = "chip";
  el.innerHTML = `<span class="dot ${ok?"ok":"err"}"></span><span>${name}</span>`;
  chipsEl.appendChild(el);
}

async function discover(){
  setStatus("Scanning…");
  let files = [];
  const m = await fetchJSON("sounds/manifest.json");
  if(m && Array.isArray(m.files) && m.files.length){
    files = m.files.filter(f => f.endsWith(".wav"));
    for(const f of files) chip(f, true);
    foundEl.textContent = files.length;
    setStatus("Manifest loaded", true);
    return files;
  }
  // Fallback probe
  let misses = 0;
  for(let i=1;i<=200;i++){
    const name = `clip_${String(i).padStart(3,"0")}.wav`;
    const ok = await head("sounds/"+name);
    chip(name, ok);
    if(ok){ files.push(name); misses = 0; }
    else{ misses++; if(misses>=25 && files.length>0) break; }
    foundEl.textContent = files.length;
  }
  setStatus(files.length? "Probed files" : "No files found", files.length>0);
  return files;
}

// ===== Audio engine =====
let ctx, masterGain;
let buffers = new Map();
let voices = new Set();
let unlocked = false;
let ready = false;
const FADE_MS = 8;
const MAX_POLYPHONY = 16;

function createCtx(){
  if(!ctx || ctx.state==="closed"){
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    masterGain = ctx.createGain();
    masterGain.gain.value = parseFloat(volEl.value);
    masterGain.connect(ctx.destination);
  }
  setAudioState();
}

function setVolume(){
  if(masterGain) masterGain.gain.setTargetAtTime(parseFloat(volEl.value), ctx.currentTime, 0.01);
}
volEl.addEventListener("input", setVolume);

// Promise-based unlock to allow chaining from first button tap
let unlockPromise = null;
function ensureUnlocked(){
  if(unlocked){
    if(ctx && ctx.state!=="running") return ctx.resume().then(()=>true);
    return Promise.resolve(true);
  }
  if(unlockPromise) return unlockPromise;
  unlockPromise = (async ()=>{
    createCtx();
    try{
      // 1-frame silent buffer
      const silent = ctx.createBuffer(1, 1, ctx.sampleRate);
      const src = ctx.createBufferSource();
      src.buffer = silent; src.connect(masterGain);
      src.start(0); src.stop(0);
      await ctx.resume();
      unlocked = true;
      unlockState.textContent = "Audio unlocked ✅";
    }catch(e){
      unlockState.textContent = "Unlock failed: " + (e.message||e);
    }
    setAudioState();
    unlockOverlay.classList.add("hide");
    return true;
  })();
  return unlockPromise;
}

async function unlockAudio(){ await ensureUnlocked(); if(!ready) loadAll().catch(()=>{}); }

// Multiple gesture hooks to satisfy iOS
["click","pointerdown","pointerup","touchstart","touchend"].forEach(ev=>{
  window.addEventListener(ev, unlockAudio, { once:true });
});
$("#unlockBtn").addEventListener("click", unlockAudio);

// ===== Loading & UI =====
let FILES = [];
async function loadAll(){
  if(!FILES.length){ setStatus("No files to load"); return; }
  setStatus("Loading 0/"+FILES.length+"…");
  for(let i=0;i<FILES.length;i++){
    const url = "sounds/" + FILES[i];
    try{
      const res = await fetch(url, {cache:"no-store"});
      const arr = await res.arrayBuffer();
      if(ctx.state==="suspended") await ctx.resume();
      const buf = await ctx.decodeAudioData(arr);
      buffers.set(FILES[i], buf);
      meterFill.style.width = Math.round(((i+1)/FILES.length)*100) + "%";
      setStatus(`Loaded ${i+1}/${FILES.length}`, (i+1)===FILES.length);
    }catch(e){
      setStatus("Decode error "+FILES[i]);
    }
  }
  ready = true;
  renderGrid();
}

function addPressFeedback(el){
  const add = ()=>{ el.classList.add("pressed"); try{ navigator.vibrate && navigator.vibrate(8); }catch(_){ } };
  const remove = ()=> el.classList.remove("pressed");
  ["pointerdown","touchstart","mousedown"].forEach(ev=> el.addEventListener(ev, add));
  ["pointerup","pointercancel","touchend","touchcancel","mouseleave","mouseup","blur"].forEach(ev=> el.addEventListener(ev, remove));
}

function makeButton(file, idx){
  const b = document.createElement("button");
  b.className = "sound";
  b.innerHTML = `▶️ <span>${String(idx+1).padStart(2,"0")}</span>`;
  b.title = file;
  addPressFeedback(b);
  b.addEventListener("pointerdown", async ()=>{ await ensureUnlocked(); if(!buffers.has(file)) await loadOne(file); play(file, b); });
  b.addEventListener("keydown", async (e)=>{ if(e.key==="Enter"||e.key===" "){ e.preventDefault(); await ensureUnlocked(); if(!buffers.has(file)) await loadOne(file); play(file, b); }});
  return b;
}

function renderGrid(){
  gridEl.innerHTML = "";
  FILES.forEach((f,i)=> gridEl.appendChild(makeButton(f,i)));
}

async function loadOne(file){
  setStatus("Decoding "+file);
  try{
    const res = await fetch("sounds/"+file, {cache:"no-store"});
    const arr = await res.arrayBuffer();
    if(ctx.state==="suspended") await ctx.resume();
    const buf = await ctx.decodeAudioData(arr);
    buffers.set(file, buf);
    setStatus("Ready", true);
  }catch(e){
    setStatus("Decode error "+file);
  }
}

function now(){ return ctx.currentTime; }

function fadeInOut(g, start, durMs){
  const t = start;
  const d = durMs/1000;
  const A = Math.max(FADE_MS, 1)/1000;
  g.gain.cancelScheduledValues(t);
  g.gain.setValueAtTime(0.0, t);
  g.gain.linearRampToValueAtTime(parseFloat(volEl.value), t + A);
  g.gain.setValueAtTime(parseFloat(volEl.value), t + d - A);
  g.gain.linearRampToValueAtTime(0.0, t + d);
}

function stopAll(){
  voices.forEach(v => { try{ v.src.stop(); }catch(_){} v.src.disconnect(); v.g.disconnect(); });
  voices.clear();
}
document.getElementById("stopAll").addEventListener("click", stopAll);

function play(file, btn){
  if(!buffers.has(file)) return;
  if(voices.size >= MAX_POLYPHONY){
    const oldest = voices.values().next().value;
    try{ oldest.src.stop(); }catch(_){}
    oldest.src.disconnect(); oldest.g.disconnect(); voices.delete(oldest);
  }
  const buf = buffers.get(file);
  if(!buf) return;
  if(cutEl.checked){
    for(const v of Array.from(voices)){
      if(v.file===file){ try{ v.src.stop(); }catch(_){}
        v.src.disconnect(); v.g.disconnect(); voices.delete(v);
      }
    }
  }
  const src = ctx.createBufferSource();
  src.buffer = buf;
  const g = ctx.createGain();
  src.connect(g).connect(masterGain);
  const t = now();
  fadeInOut(g, t, buf.duration*1000);
  src.start(t);
  const voice = {file, src, g, btn};
  voices.add(voice);
  btn && btn.classList.add("pressed");
  src.onended = () => { try{ src.disconnect(); g.disconnect(); }catch(_){ } voices.delete(voice); btn && btn.classList.remove("pressed"); };
}

document.getElementById("seq").addEventListener("pointerdown", async (e)=>{
  const button = e.currentTarget;
  button.classList.add("pressed");
  await ensureUnlocked();
  if(!ready){
    FILES.length && await loadAll();
  }
  let t = 0;
  const buttons = Array.from(document.querySelectorAll("button.sound")).filter(b=>b!==button);
  for(let i=0;i<FILES.length;i++){
    const f = FILES[i];
    if(!buffers.has(f)) await loadOne(f);
    const btn = buttons[i];
    setTimeout(()=>play(f, btn), t);
    t += 120;
  }
  setTimeout(()=>button.classList.remove("pressed"), 200);
});

// Boot
(async ()=>{
  FILES = await discover();
})();

document.addEventListener("visibilitychange", ()=>{
  if(!ctx) return;
  if(document.hidden) ctx.suspend().catch(()=>{}); else ctx.resume().catch(()=>{});
});
</script>
</body>
</html>
