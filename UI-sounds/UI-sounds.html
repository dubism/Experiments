<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<meta name="theme-color" content="#0b0d10">
<title>UI Sounds — /sounds/ clip_001…</title>
<style>
  :root{--bg:#0b0d10;--ink:#e7eef6;--muted:#9ab0c6;--card:#0f1318;--line:#1b2330;--accent:#79f5cc;--accent2:#3bd4ff;--glow:0 8px 18px rgba(0,0,0,.45),0 0 0 1px #1b2330 inset,0 0 22px rgba(61,225,255,.18)}
  *{box-sizing:border-box}
  html,body{height:100%;background:#0b0d10;color:var(--ink);color-scheme:dark}
  body{margin:0;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial,sans-serif;background:radial-gradient(1200px 800px at 10% 0%,#10202b 0%,#0b0d10 40%,#0b0d10 100%);-webkit-tap-highlight-color:transparent}
  header{position:sticky;top:0;background:rgba(15,19,24,.85);backdrop-filter:blur(6px);border-bottom:1px solid var(--line);padding:12px;z-index:10}
  h1{margin:0 0 6px;font-size:18px}
  .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
  .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);padding:8px 12px;border-radius:999px;background:#111823}
  input[type="range"]{width:220px}
  .small{font-size:12px;color:var(--muted)}
  .card{border:1px solid var(--line);background:rgba(15,19,24,.9);border-radius:14px;padding:12px;margin:12px;box-shadow:var(--glow)}
  .grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(140px,1fr));gap:10px}
  .tile{display:flex;flex-direction:column;gap:6px}
  button.sound{padding:12px;border-radius:14px;border:1px solid var(--line);background:linear-gradient(180deg,#14202b,#0f1318);color:var(--ink);cursor:pointer;box-shadow:var(--glow);display:flex;justify-content:center;align-items:center;gap:8px;transition:transform .06s,box-shadow .18s;user-select:none;touch-action:manipulation}
  button.sound:active,button.sound.pressed{transform:scale(.97);box-shadow:0 0 0 1px #2ad0ff inset,0 0 30px rgba(58,208,255,.35)}
  .fname{font-size:12px;color:var(--muted);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
  .meter{height:10px;background:#0f1722;border:1px solid var(--line);border-radius:8px;overflow:hidden;min-width:180px}
  .fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--accent2));width:0%}
  .ok{color:var(--accent)}
</style>
</head>
<body>
  <header>
    <h1>UI Sounds — /sounds/</h1>
    <div class="row">
      <span class="pill"><span>Volume</span> <input id="vol" type="range" min="0" max="1" step="0.01" value="0.9"></span>
      <label class="pill"><input id="cut" type="checkbox" checked> Cut previous</label>
      <span id="status" class="small">Scanning…</span>
      <span class="pill"><span>Found</span> <strong id="found">0</strong></span>
      <div class="meter"><div class="fill" id="meter"></div></div>
    </div>
  </header>

  <main class="card">
    <div class="grid" id="grid"></div>
    <div class="row" style="margin-top:12px">
      <button id="seq" class="sound">▶️ Quick playthrough</button>
      <button id="stopAll" class="sound">⏹️ Stop All</button>
    </div>
  </main>

<script>
/* ===== Config: ONLY clip_001.wav.. and stop at first gap ===== */
const DIR = "sounds/";
const START = 1;             // starts at clip_001.wav
const PAD   = 3;
const PREFIX= "clip_";
const SUFFIX= ".wav";

/* ===== Shorthands ===== */
const $ = s => document.querySelector(s);
const grid=$("#grid"), statusEl=$("#status"), foundEl=$("#found"), volEl=$("#vol"), cutEl=$("#cut"), meter=$("#meter");
document.body.addEventListener("touchstart",()=>{}, {passive:true});
const setStatus = (m, ok=false)=>{ statusEl.textContent=m; statusEl.classList.toggle("ok", ok); };

/* ===== Audio (unlock on first tap only) ===== */
let ctx, masterGain, unlocked=false, buffers=new Map(), voices=new Set();
function createCtx(){ if(!ctx||ctx.state==="closed"){ ctx=new (window.AudioContext||window.webkitAudioContext)(); masterGain=ctx.createGain(); masterGain.gain.value=parseFloat(volEl.value); masterGain.connect(ctx.destination);} }
async function ensureUnlocked(){ if(unlocked){ if(ctx?.state!=="running") await ctx.resume(); return; } createCtx(); try{ const silent=ctx.createBuffer(1,1,ctx.sampleRate); const src=ctx.createBufferSource(); src.buffer=silent; src.connect(masterGain); src.start(0); src.stop(0); await ctx.resume(); unlocked=true; }catch{} }
volEl.addEventListener("input",()=>{ if(masterGain) masterGain.gain.setTargetAtTime(parseFloat(volEl.value), ctx.currentTime, .01); });

/* ===== Discovery: sequential probe; stop at first miss ===== */
async function exists(name){
  try{
    const r=await fetch(DIR+name, {cache:"no-store", headers:{"Range":"bytes=0-0"}});
    return r.ok;
  }catch{ return false; }
}
async function discover(){
  setStatus("Scanning /sounds/…");
  const files=[];
  for(let i=START;;i++){
    const name = `${PREFIX}${String(i).padStart(PAD,"0")}${SUFFIX}`;
    const ok = await exists(name);
    if(!ok) break;          // STOP on first miss
    files.push(name);
  }
  foundEl.textContent = files.length;
  setStatus(files.length?`Found ${files.length}`:"No files found", !!files.length);
  return files;
}

/* ===== UI + Loading ===== */
function addPress(el){
  const on=()=>{ el.classList.add("pressed"); try{navigator.vibrate&&navigator.vibrate(8);}catch{} };
  const off=()=> el.classList.remove("pressed");
  ["pointerdown","touchstart","mousedown"].forEach(ev=>el.addEventListener(ev,on,{passive:true}));
  ["pointerup","pointercancel","touchend","touchcancel","mouseleave","mouseup","blur"].forEach(ev=>el.addEventListener(ev,off));
}
function makeTile(name){
  const t=document.createElement("div"); t.className="tile";
  const b=document.createElement("button"); b.className="sound"; b.textContent="▶️ Play"; addPress(b);
  const l=document.createElement("div"); l.className="fname"; l.textContent=name;
  b.addEventListener("pointerdown", async()=>{ await ensureUnlocked(); if(!buffers.has(name)) await loadOne(name); play(name,b); });
  t.appendChild(b); t.appendChild(l); return t;
}
function render(files){
  grid.innerHTML=""; files.forEach(n=>grid.appendChild(makeTile(n)));
  $("#seq").addEventListener("pointerdown", async e=>{
    const btn=e.currentTarget; btn.classList.add("pressed");
    await ensureUnlocked();
    let t=0, btns=[...document.querySelectorAll(".tile > .sound")];
    for(let i=0;i<files.length;i++){ const f=files[i]; if(!buffers.has(f)) await loadOne(f); setTimeout(()=>play(f,btns[i]), t); t+=120; }
    setTimeout(()=>btn.classList.remove("pressed"),220);
  });
  $("#stopAll").addEventListener("click", stopAll);
}
async function loadAll(files){
  setStatus(`Loading 0/${files.length}…`);
  for(let i=0;i<files.length;i++){
    try{
      const arr = await (await fetch(DIR+files[i], {cache:"no-store"})).arrayBuffer();
      if(!ctx) createCtx();                           // do NOT resume here
      const buf = await ctx.decodeAudioData(arr);
      buffers.set(files[i], buf);
      meter.style.width = Math.round(((i+1)/files.length)*100) + "%";
      setStatus(`Loading ${i+1}/${files.length}…`, i+1===files.length);
    }catch{ setStatus("Decode error "+files[i]); }
  }
  setStatus("Ready", true);
}
async function loadOne(name){
  try{
    const arr = await (await fetch(DIR+name, {cache:"no-store"})).arrayBuffer();
    if(!ctx) createCtx();                             // do NOT resume here
    buffers.set(name, await ctx.decodeAudioData(arr));
  }catch{}
}

/* ===== Playback ===== */
const FADE_MS=8, MAX_POLYPHONY=16;
function now(){ return ctx.currentTime; }
function fadeInOut(g,start,durMs){
  const t=start, d=durMs/1000, A=Math.max(FADE_MS,1)/1000;
  g.gain.cancelScheduledValues(t);
  g.gain.setValueAtTime(0.0, t);
  g.gain.linearRampToValueAtTime(parseFloat(volEl.value), t + A);
  g.gain.setValueAtTime(parseFloat(volEl.value), t + d - A);
  g.gain.linearRampToValueAtTime(0.0, t + d);
}
function stopAll(){ voices.forEach(v=>{ try{v.src.stop()}catch{} v.src.disconnect(); v.g.disconnect(); }); voices.clear(); }
function play(name,btn){
  if(!buffers.has(name)) return;
  if(voices.size>=MAX_POLYPHONY){ const v=voices.values().next().value; try{v.src.stop()}catch{} v.src.disconnect(); v.g.disconnect(); voices.delete(v); }
  const buf=buffers.get(name); if(!buf) return;
  if(cutEl.checked){ for(const v of Array.from(voices)){ if(v.name===name){ try{v.src.stop()}catch{} v.src.disconnect(); v.g.disconnect(); voices.delete(v); } } }
  const src=ctx.createBufferSource(), g=ctx.createGain(); src.buffer=buf; src.connect(g).connect(masterGain);
  const t=now(); fadeInOut(g,t,buf.duration*1000); src.start(t);
  const voice={name,src,g,btn}; voices.add(voice); btn&&btn.classList.add("pressed");
  src.onended=()=>{ try{src.disconnect(); g.disconnect();}catch{} voices.delete(voice); btn&&btn.classList.remove("pressed"); };
}

/* ===== Boot ===== */
(async()=>{
  const files = await discover();     // strictly sequential from 001; stop at first gap
  if(files.length){
    render(files);                     // show UI
    loadAll(files);                    // preload in background
  }
})();
document.addEventListener("visibilitychange",()=>{ if(!ctx) return; if(document.hidden) ctx.suspend().catch(()=>{}); else ctx.resume().catch(()=>{}); });
</script>
</body>
</html>