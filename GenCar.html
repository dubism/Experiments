<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Pollinations — Time-first + Camera Angle Recipes</title>
<link rel="preconnect" href="https://image.pollinations.ai" crossorigin>
<link rel="dns-prefetch" href="//image.pollinations.ai">
<link rel="dns-prefetch" href="//images.weserv.nl">
<style>
  :root{ --fg:#e8eef5; --muted:#a6b0bd; --c1:#0e0e0f; --c2:#0b0b0c; --c3:#101011; --c4:#0a0a0a; }
  *{box-sizing:border-box}
  html,body{
    height:100%;margin:0;background:
      radial-gradient(at 0% 0%, var(--c1), transparent 60%),
      radial-gradient(at 100% 0%, var(--c2), transparent 60%),
      radial-gradient(at 0% 100%, var(--c3), transparent 60%),
      radial-gradient(at 100% 100%, var(--c4), transparent 60%), #0a0a0a;
    color:var(--fg); font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
    overflow-y:auto; overflow-x:hidden;
  }
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:8px}
  .stage{width:min(96vw, 980px); display:flex; justify-content:center; align-items:center}
  .frame{position:relative; width:100%; aspect-ratio:3/2; border-radius:12px; overflow:hidden;
    box-shadow:0 10px 28px rgba(0,0,0,.45), inset 0 0 0 1px rgba(255,255,255,.06); background:#111;}
  .frame img{position:absolute; inset:0; margin:auto; max-width:100%; max-height:100%; object-fit:contain; filter:contrast(1.02) saturate(1.02)}
  .loading{position:absolute; left:0; right:0; bottom:8px; text-align:center; font-size:12px; color:var(--muted);
    transition:opacity .2s; opacity:0; pointer-events:none}
  .loading.show{opacity:1}
  .controls{width:min(96vw, 980px); margin-top:4px}
  .row{padding:6px 4px}
  .top{display:flex; justify-content:space-between; align-items:baseline; margin:0 2px 4px}
  .label{font-weight:600; letter-spacing:.2px}
  .val{font-variant-numeric:tabular-nums; color:var(--muted); font-size:12px}
  input[type="range"]{width:100%; -webkit-appearance:none; appearance:none; height:28px; background:transparent}
  input[type="range"]::-webkit-slider-runnable-track{height:6px; border-radius:999px; background:linear-gradient(90deg, rgba(255,255,255,.28), rgba(255,255,255,.14))}
  input[type="range"]::-moz-range-track{height:6px; border-radius:999px; background:linear-gradient(90deg, rgba(255,255,255,.28), rgba(255,255,255,.14))}
  input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none; width:18px; height:18px; border-radius:50%; background:#fff; box-shadow:0 2px 8px rgba(0,0,0,.5); margin-top:-6px}
  input[type="range"]::-moz-range-thumb{width:18px; height:18px; border-radius:50%; background:#fff; border:none; box-shadow:0 2px 8px rgba(0,0,0,.5)}
  input[type="range"]:disabled{opacity:.55; cursor:not-allowed}
  input[type="range"]:disabled::-webkit-slider-thumb, input[type="range"]:disabled::-moz-range-thumb{background:#c9c9c9; box-shadow:none}
  .hint{opacity:.75; font-size:11px; text-align:center; margin:6px 0 10px; color:var(--muted)}
  .errbar{position:fixed; left:12px; right:12px; bottom:12px; padding:10px 12px; border-radius:10px;
    background:#2b1212; color:#ffd6d6; border:1px solid #913c3c; font-size:12px; display:none; z-index:9998}
  .peek{position:fixed; right:12px; bottom:12px; z-index:9999; width:36px; height:36px; border-radius:50%; display:grid; place-items:center;
    background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.18); color:#fff; cursor:pointer; backdrop-filter: blur(8px); transition:transform .2s}
  .peek[aria-expanded="true"]{transform:rotate(180deg)}
  .overlay{position:fixed; inset:12px; z-index:9997; display:none; background:rgba(10,10,10,.88); border:1px solid rgba(255,255,255,.1); border-radius:12px; backdrop-filter: blur(10px)}
  .overlay.show{display:block}
  .overlay .inner{height:100%; display:flex; flex-direction:column}
  .overlay header{display:flex; align-items:center; justify-content:space-between; padding:10px 12px; border-bottom:1px solid rgba(255,255,255,.08); font-weight:600}
  .overlay main{flex:1; overflow:auto; padding:10px 12px; display:grid; grid-template-columns:1fr; gap:12px}
  .card{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:10px}
  .card h3{margin:0 0 6px 0; font-size:13px; color:#dfe6ef}
  pre{white-space:pre-wrap; word-break:break-word; margin:0; font:12px/1.35 ui-monospace,SFMono-Regular,Consolas,monospace; color:#dfe6ef}
  .actions{display:flex; gap:8px; flex-wrap:wrap; margin-top:8px}
  .btn{appearance:none; border:1px solid rgba(255,255,255,.12); border-radius:8px; padding:6px 10px; background:rgba(255,255,255,.06); color:var(--fg); font:12px; cursor:pointer; text-decoration:none}
</style>
</head>
<body>
  <div class="wrap">
    <div class="stage">
      <div class="frame">
        <img id="img" alt="Generated scene" crossorigin="anonymous" referrerpolicy="no-referrer" decoding="async" loading="eager" fetchpriority="high">
        <div class="loading" id="loading" aria-live="polite">Loading…</div>
      </div>
    </div>

    <div class="controls">
      <div class="row">
        <div class="top"><div class="label">Time</div><div class="val" id="timeVal"></div></div>
        <input id="time" type="range" min="0" max="23" step="1">
      </div>
      <div class="row">
        <div class="top"><div class="label">Environment</div><div class="val" id="envVal"></div></div>
        <input id="env" type="range" min="0" max="11" step="1">
      </div>
      <div class="row">
        <div class="top"><div class="label">Vehicle</div><div class="val" id="carVal"></div></div>
        <input id="car" type="range" min="0" max="5" step="1">
      </div>
      <div class="row">
        <div class="top"><div class="label">Era</div><div class="val" id="eraVal"></div></div>
        <input id="era" type="range" min="0" max="11" step="1">
      </div>
      <div class="row">
        <div class="top"><div class="label">View</div><div class="val" id="dirVal"></div></div>
        <input id="dir" type="range" min="0" max="3" step="1">
      </div>
      <div class="row">
        <div class="top"><div class="label">Color</div><div class="val" id="paintVal"></div></div>
        <input id="paint" type="range" min="0" max="9" step="1">
      </div>
      <div class="hint">Updates after 500 ms pause</div>
    </div>
  </div>

  <!-- prompt/debug overlay -->
  <button id="peek" class="peek" aria-expanded="false" title="Show prompt & debug">⌄</button>
  <div id="overlay" class="overlay" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="inner">
      <header>
        <span>Prompt & Debug</span>
        <div class="actions">
          <button class="btn" id="copyPrompt">Copy prompt</button>
          <button class="btn" id="copyDebug">Copy debug</button>
          <button class="btn" id="copyURL">Copy image URL</button>
          <button class="btn" id="retry">Retry</button>
          <button class="btn" id="selfTest">Self-test</button>
          <a class="btn" id="openImg" target="_blank" rel="noopener">Open image</a>
        </div>
      </header>
      <main>
        <div class="card"><h3>Current Prompt</h3><pre id="promptText">—</pre></div>
        <div class="card"><h3>Debug log</h3><pre id="debugText">—</pre></div>
      </main>
    </div>
  </div>

  <div id="errbar" class="errbar"></div>

<script>
'use strict';
(() => {
  const VERSION = 'angles-applied-2025-09-08';
  const WAIT_MS = 500;
  const MIN_API_INTERVAL_MS = 6500;   // ~5s per IP → pad
  const ATTEMPT_GAP_MS = 6500;
  const MAX_PATH_BYTES = 900;         // safe path budget
  const WIDTH = 1536, HEIGHT = 1024;  // 3:2 landscape per recipe

  /* error bar */
  const errbar = document.getElementById('errbar');
  const showError = (msg)=>{ errbar.textContent = msg; errbar.style.display='block'; clearTimeout(showError._t); showError._t=setTimeout(()=>errbar.style.display='none',7000); };
  window.addEventListener('error', e => showError(`Script error: ${e.message}`));
  window.addEventListener('unhandledrejection', e => showError(`Promise error: ${e.reason?.message || e.reason}`));

  const $ = s => document.querySelector(s);
  const req = (s)=>{ const el=$(s); if(!el){ throw new Error(`Missing element: ${s}`);} return el; };

  const img = req('#img'), loading = req('#loading');
  const promptText = req('#promptText'), openImg = req('#openImg');
  const debugText = req('#debugText'), selfTestBtn = req('#selfTest'), retryBtn = req('#retry');
  const copyURLBtn = req('#copyURL'), copyPromptBtn = req('#copyPrompt'), copyDebugBtn = req('#copyDebug');
  const peekBtn = req('#peek'), overlay = req('#overlay');

  const timeEl=req('#time'), envEl=req('#env'), carEl=req('#car'), eraEl=req('#era'), dirEl=req('#dir'), paintEl=req('#paint');
  const timeVal=req('#timeVal'), envVal=req('#envVal'), carVal=req('#carVal'), eraVal=req('#eraVal'), dirVal=req('#dirVal'), paintVal=req('#paintVal');
  const sliders=[timeEl,envEl,carEl,eraEl,dirEl,paintEl];

  /* data */
  const habitats = [
    "alpine mountain pass","temperate forest","grassland steppe","sandy desert dunes","arctic ice and snow",
    "rocky coastal cliffs","Mediterranean scrubland","savanna","farmland and orchards",
    "rural village lanes","historic European old-town streets","modern glass high-rise city center"
  ];
  const envShort = ["mountain pass","forest","steppe","desert","arctic","coast","scrubland","savanna","farmland","village","old-town","city center"];
  const envLead = [
    {np:"a mountain pass", prep:"on"},{np:"a forest", prep:"in"},{np:"a grassland steppe", prep:"in"},
    {np:"a desert", prep:"on"},{np:"arctic ice and snow", prep:"on"},{np:"rocky coastal cliffs", prep:"by"},
    {np:"Mediterranean scrubland", prep:"in"},{np:"a savanna", prep:"in"},{np:"farmland and orchards", prep:"in"},
    {np:"rural village lanes", prep:"in"},{np:"historic old-town streets", prep:"in"},{np:"a modern city center", prep:"in"}
  ];
  const cars = [
    "mid-engine powerful supercar","elegant simple boat-tail coupe cabrio","midsize SUV",
    "midsize sedan","microcar (A-segment)","minibus / van"
  ];
  const carShort = ["supercar","boat-tail cabrio","SUV","sedan","microcar","minibus"];
  const eras = ["1890s","1920s","1950s","1960s","1970s","1980s","1990s","2000s","2010s","2020s","futuristic","unbelievably mesmerizingly sci-fi"];
  function eraCue(label){
    const map = {
      "1890s": "1890s (eighteen-nineties) — horseless carriage spirit; exposed coachwork; spindly wheels; brass fittings",
      "1920s": "1920s (20s, nineteen-twenties) — early streamlining; art-deco cues; upright radiators; coachbuilt bodies",
      "1950s": "1950s (50s, nineteen-fifties) — jet-age optimism; tailfins; chrome; two-tone trims; whitewall tires",
      "1960s": "1960s (60s, nineteen-sixties) — clean curves; coke-bottle waists; muscle stance; simple brightwork",
      "1970s": "1970s (70s, nineteen-seventies) — iconic wedge car edges; compact proportions; louvers; vinyl textures",
      "1980s": "1980s (80s, nineteen-eighties) — boxy precision; sharp creases; pop-up headlamps; black rub strips",
      "1990s": "1990s (90s, nineteen-nineties) — aero-organic rounding; cab-forward; flush glass; smooth cladding",
      "2000s": "2000s (00s, two-thousands) — taut surfaces; flame-surfacing hints; big alloys; high beltlines",
      "2010s": "2010s (10s, twenty-tens) — LED signatures; assertive grilles; origami creases; crossover boom",
      "2020s": "2020s (20s, twenty-twenties) — EV minimalism; sealed grilles; parametric lighting; slipperier aero",
      "futuristic": "futuristic — near-future concept; seamless panels; advanced composites; plausible sensors",
      "unbelievably mesmerizingly sci-fi": "unbelievably mesmerizingly sci-fi — starship-like; alien megastructures; impossible engineering; luminous seams"
    };
    return map[label] || `${label} style authenticity`;
  }

  /* Views — UI labels */
  const viewShort = ["Front 3/4","Side","Front head-on","Top-down"]; // matches 1,3,4,6 in your recipe

  /* Paints — simple */
  const paints = [
    {label:"White",name:"white"},{label:"Black",name:"black"},{label:"Silver",name:"silver"},
    {label:"Gray",name:"gray"},{label:"Red",name:"red"},{label:"Blue",name:"blue"},
    {label:"Green",name:"green"},{label:"Yellow",name:"yellow"},{label:"Orange",name:"orange"},{label:"Beige",name:"beige"}
  ];

  /* overlay toggle */
  function toggleOverlay(force){
    const open = typeof force==='boolean' ? force : !overlay.classList.contains('show');
    overlay.classList.toggle('show', open);
    overlay.setAttribute('aria-hidden', String(!open));
    peekBtn.setAttribute('aria-expanded', String(open));
  }
  peekBtn.addEventListener('click', ()=>toggleOverlay());
  window.addEventListener('keydown', e=>{ if(e.key==='Escape') toggleOverlay(false); });

  /* time tokens — canonical + lighting, used inside camera recipe */
  function timeTokens(h){
    if (h>=4 && h<6)  return {prime:"pre-dawn blue hour",      light:"cool indigo ambience, faint orange horizon glow, long soft shadows"};
    if (h>=6 && h<8)  return {prime:"sunrise golden hour",     light:"warm golden sunlight, amber rim light, gentle morning mist"};
    if (h>=8 && h<12) return {prime:"morning daylight",        light:"neutral-white sunlight, pale sky, crisp short shadows"};
    if (h===12)       return {prime:"noon",                     light:"bright white sun overhead, high contrast, very short shadows"};
    if (h>12 && h<17) return {prime:"afternoon",               light:"warm sunlight with light yellow tint, gradually softening shadows"};
    if (h>=17 && h<20)return {prime:"sunset golden hour",      light:"golden-orange sunlight, long deep shadows, glowing sky band"};
    if (h>=20 && h<22)return {prime:"twilight blue hour",      light:"cobalt-blue ambient glow, first stars visible"};
    if (h>=22 || h<2) return {prime:"night",                   light:"silvery moonlight, deep navy sky, stars visible"};
    return {prime:"late night",                                 light:"sparse lighting, inky sky, subdued reflections"};
  }

  /* UI labels — simple */
  const labelHour=(h)=>{const hh=String(h).padStart(2,'0')+":00";
    if (h>=4 && h<6)  return `pre-dawn · ${hh}`;
    if (h>=6 && h<8)  return `sunrise · ${hh}`;
    if (h>=8 && h<12) return `morning · ${hh}`;
    if (h===12)       return `noon · 12:00`;
    if (h>12 && h<17) return `afternoon · ${hh}`;
    if (h>=17 && h<20)return `sunset · ${hh}`;
    if (h>=20 && h<22)return `twilight · ${hh}`;
    if (h>=22 || h<2) return `night · ${hh}`;
    return `late night · ${hh}`; };

  function reflectLabels(){
    timeVal.textContent  = labelHour(+timeEl.value);
    envVal.textContent   = envShort[+envEl.value] || habitats[+envEl.value];
    carVal.textContent   = carShort[+carEl.value] || cars[+carEl.value];
    eraVal.textContent   = eras[+eraEl.value];
    dirVal.textContent   = viewShort[+dirEl.value] || "View";
    paintVal.textContent = paints[+paintEl.value].label;
  }

  /* scene lead — "a blue car on a desert." */
  function sceneLead(colorWord, envIdx){
    const e = envLead[envIdx] || {np:"a location", prep:"in"};
    return `a ${colorWord} car ${e.prep} ${e.np}.`;
  }

  /* CAMERA/VIEW ANGLE SECTION — applied from your recipes (angles 1,3,4,6) */
  // Returns the full camera phrase, with {background}=env and {lighting}=time tokens
  function cameraRecipe(dirIdx, carName, envStr, timeObj){
    const L = `${timeObj.prime}, ${timeObj.light}`;
    switch (dirIdx|0){
      // 1. Front three-quarter (hero)
      case 0: return `photo of a ${carName}, front three-quarter view, camera height 1.2 m, eye-level, 50mm lens, car facing right, wheels straight, horizon level, camera roll 0 degrees, ${envStr} background, ${L}, 3:2 landscape, no dutch angle, no fisheye, no people, no text`;
      // 3. Side profile (90°)
      case 1: return `photo of a ${carName}, perfect side profile, car perpendicular to camera, camera height 1.2 m, eye-level, 100mm telephoto, wheels straight, horizon level, camera roll 0 degrees, ${envStr} background, ${L}, 3:2 landscape, no wide-angle distortion, no people, no text`;
      // 4. Head-on (straight frontal view)
      case 2: return `photo of a ${carName}, head-on, straight frontal view, camera centered on grille, camera height 1.0 m, eye-level, 70mm lens, wheels straight, horizon level, camera roll 0 degrees, ${envStr} background, ${L}, 3:2 landscape, no dutch angle, no fisheye, no people, no text`;
      // 6. Bird’s-eye (top-down)
      default: return `photo of a ${carName}, bird’s-eye view from above, camera height 6 m, high angle, 24mm lens, car centered, wheels straight, horizon level not visible, camera roll 0 degrees, ${envStr} background, ${L}, 3:2 landscape, no eye-level, no dutch angle, no people, no text`;
    }
  }
  // Compact version for URL-length fallback
  function cameraRecipeCompact(dirIdx, carName, envStr, timeObj){
    const L = `${timeObj.prime}`;
    switch (dirIdx|0){
      case 0: return `photo of a ${carName}, front three-quarter, h=1.2m eye-level, 50mm, facing right, wheels straight, horizon level, roll 0°, ${envStr} background, ${L}, 3:2, no dutch angle, no fisheye, no people, no text`;
      case 1: return `photo of a ${carName}, side profile 90°, h=1.2m eye-level, 100mm, wheels straight, horizon level, roll 0°, ${envStr} background, ${L}, 3:2, no wide-angle distortion, no people, no text`;
      case 2: return `photo of a ${carName}, head-on straight frontal, centerline, h=1.0m, 70mm, wheels straight, horizon level, roll 0°, ${envStr} background, ${L}, 3:2, no dutch angle, no fisheye, no people, no text`;
      default: return `photo of a ${carName}, bird’s-eye top-down, h=6m, 24mm, centered, wheels straight, roll 0°, ${envStr} background, ${L}, 3:2, no people, no text`;
    }
  }

  /* short helpers */
  function eraCueShort(label){
    const m={
      "1890s":"1890s coachbuilt, brass, spindly wheels","1920s":"1920s deco, early streamlining",
      "1950s":"1950s jet-age, chrome, two-tone","1960s":"1960s clean curves, muscle stance",
      "1970s":"1970s iconic wedge edges, louvers","1980s":"1980s boxy, sharp creases",
      "1990s":"1990s aero-rounded, cab-forward","2000s":"2000s taut surfaces, big alloys",
      "2010s":"2010s LEDs, assertive grilles","2020s":"2020s EV minimal, sealed grille",
      "futuristic":"near-future concept sleek","unbelievably mesmerizingly sci-fi":"starship-like, luminous seams"
    }; return m[label]||label;
  }

  /* PROMPTS — time FIRST, then camera recipe, then era + paint */
  function buildPromptLong(){
    const envIdx = +envEl.value;
    const env   = habitats[envIdx];
    const car   = cars[+carEl.value];
    const era   = eras[+eraEl.value];
    const color = (paints[+paintEl.value].name || paints[+paintEl.value].label).toLowerCase();
    const t     = timeTokens(+timeEl.value);
    const cam   = cameraRecipe(+dirEl.value, car, env, t);

    return [
      sceneLead(color, envIdx),
      `Time of day: ${t.prime}; ${t.light}.`,
      cam + ",", // already contains “photo of a …”
      `Era: ${eraCue(era)}.`,
      `Car paint finished in ${color}; body paint in ${color}; overall body color ${color}.`,
      `Photorealistic, high detail`
    ].join(' ');
  }
  function buildPromptShort(){
    const envIdx=+envEl.value;
    const env   = habitats[envIdx];
    const car   = cars[+carEl.value];
    const era   = eras[+eraEl.value];
    const color = (paints[+paintEl.value].name || paints[+paintEl.value].label).toLowerCase();
    const t     = timeTokens(+timeEl.value);
    const cam   = cameraRecipeCompact(+dirEl.value, car, env, t);

    return [
      sceneLead(color, envIdx),
      `Time: ${t.prime}.`,
      cam + ",",
      `Era: ${eraCueShort(era)}.`,
      `Car paint ${color}; body paint ${color}.`,
      `Photorealistic, high detail`
    ].join(' ');
  }
  function choosePrompt(){
    const long = buildPromptLong();
    const bytes = encodeURIComponent(long).length;
    if (bytes <= MAX_PATH_BYTES) return long;
    const short = buildPromptShort();
    log(`Prompt too long (${bytes} bytes). Using compact form (${encodeURIComponent(short).length}).`);
    return short;
  }

  /* deterministic seed — stable by (view, car, env) so time/color tweak lighting without jumping framing */
  function stableSeed(){
    const s = `${+dirEl.value}|${+carEl.value}|${+envEl.value}`;
    let h = 2166136261>>>0; // FNV-1a
    for(let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h = Math.imul(h, 16777619); }
    return (h>>>0) % 1000000000; // 0..999,999,999
  }

  /* URLs + fallbacks per Pollinations recipe (flux→turbo, private=true) */
  const uBase=(prompt,model,w,h,seed)=>{
    const p = encodeURIComponent(prompt);
    const base=`https://image.pollinations.ai/prompt/${p}?model=${model||'flux'}&width=${w}&height=${h}&seed=${seed}&enhance=false&private=true`;
    return base;
  };
  const uFlux = (p,seed)=>uBase(p,'flux',WIDTH,HEIGHT,seed);
  const uTurbo= (p,seed)=>uBase(p,'turbo',WIDTH,HEIGHT,seed);
  const uProxy=url=>`https://images.weserv.nl/?url=${encodeURIComponent(url.replace(/^https?:\/\//,''))}`;
  const candidates=(p,seed)=>{ const a=uFlux(p,seed), b=uTurbo(p,seed); return [a,b,uProxy(a),uProxy(b)]; };

  /* UI state */
  const setLoading=(on,txt='')=>{loading.classList.toggle('show',!!on); loading.textContent=on?`Loading…${txt}`:'';};
  const setControlsEnabled=(enabled)=>{ sliders.forEach(el=>{ if (el) el.disabled=!enabled; }); };

  /* palette & waiting gradient (very dark greys) */
  const clamp=(v,min,max)=>Math.min(max,Math.max(min,v));
  const rgbToHex=(r,g,b)=>"#"+[r,g,b].map(v=>clamp(v|0,0,255).toString(16).padStart(2,'0')).join('');
  function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
  function kmeansRGB(points,k=4,iters=7){
    const centers=Array.from({length:k}, _=>{const p=points[(Math.random()*points.length)|0]; return {r:p[0],g:p[1],b:p[2],count:1};});
    for(let t=0;t<iters;t++){
      const acc=centers.map(_=>({r:0,g:0,b:0,n:0}));
      for(let i=0;i<points.length;i++){
        const p=points[i]; let bi=0,bd=Infinity;
        for(let j=0;j<k;j++){const c=centers[j],dr=p[0]-c.r,dg=p[1]-c.g,db=p[2]-c.b; const d=dr*dr+dg*dg+db*db; if(d<bd){bd=d;bi=j;}}
        const A=acc[bi]; A.r+=p[0]; A.g+=p[1]; A.b+=p[2]; A.n++;
      }
      for(let j=0;j<k;j++){const A=acc[j]; if(A.n>0){ centers[j].r=A.r/A.n; centers[j].g=A.g/A.n; centers[j].b=A.b/A.n; centers[j].count=A.n; }}
    }
    return centers;
  }
  function applyGradient(cols){
    const [c1="#0e0e0f",c2="#0b0b0c",c3="#101011",c4="#0a0a0a"]=cols;
    const root=document.documentElement.style;
    root.setProperty('--c1',c1); root.setProperty('--c2',c2); root.setProperty('--c3',c3); root.setProperty('--c4',c4);
  }
  function setVeryDarkWaitingGradient(){
    const g = (v)=>`#${[v,v,v].map(x=>x.toString(16).padStart(2,'0')).join('')}`;
    const base = 8 + (Math.random()*8|0); // 8..15
    applyGradient([g(base+4), g(base+2), g(base+5), g(base)]);
  }
  function extractPaletteToBackground(imageEl){
    const S=64, cvs=document.createElement('canvas'), ctx=cvs.getContext('2d',{willReadFrequently:true});
    cvs.width=S; cvs.height=S;
    try{ ctx.drawImage(imageEl,0,0,S,S); }catch{ setVeryDarkWaitingGradient(); return; }
    let data;
    try{ data=ctx.getImageData(0,0,S,S).data; }catch(e){ log(`Palette error: ${e}`); setVeryDarkWaitingGradient(); return; }
    const pts=[]; let sumL=0, n=0;
    for (let i=0;i<data.length;i+=4){
      const a=data[i+3]; if (a<16) continue;
      const r=data[i], g=data[i+1], b=data[i+2];
      pts.push([r,g,b]); sumL += luminance(r,g,b); n++;
    }
    if (!pts.length){ setVeryDarkWaitingGradient(); return; }
    const Lmean = sumL/n;
    const centers = kmeansRGB(pts,4,8).map(c=>({r:c.r|0,g:c.g|0,b:c.b|0,count:c.count||1}));
    centers.sort((A,B)=>B.count-A.count);
    const cols = centers.slice(0,4).map(c=>rgbToHex(c.r,c.g,c.b));
    applyGradient(cols);
    log(`Palette: ${cols.join(', ')} | L_mean=${Lmean.toFixed(1)}`);
  }

  /* debug */
  function log(m){ debugText.textContent=`[${(new Date).toLocaleTimeString()}] ${m}\n`+debugText.textContent; }
  copyPromptBtn.onclick = async()=>{ try{ await navigator.clipboard.writeText(promptText.textContent||''); log('Copied prompt'); }catch{ showError('Clipboard blocked'); } };
  copyDebugBtn.onclick  = async()=>{ try{ await navigator.clipboard.writeText(debugText.textContent||'');  log('Copied debug');  }catch{ showError('Clipboard blocked'); } };
  function updatePromptUI(prompt,url){
    promptText.textContent=prompt;
    openImg.href=url;
    copyURLBtn.onclick=async()=>{ try{ await navigator.clipboard.writeText(url); log('Copied URL'); }catch{ showError('Clipboard blocked'); } };
  }

  /* throttled loader (keeps previous image while waiting) */
  let genToken=0, lastRequestAt=0;
  function loadSequence(prompt){
    const seed = stableSeed();
    const seq=candidates(prompt, seed); let i=0; const token=++genToken;
    setVeryDarkWaitingGradient();
    setLoading(true,` (attempt ${i+1}/${seq.length})`);
    log(`SEED=${seed} | model order: flux→turbo | dims=${WIDTH}x${HEIGHT}`);
    tryOne(seq[i]);

    function tryOne(url){
      if(token!==genToken) return;
      const pre=new Image(); pre.crossOrigin='anonymous'; pre.referrerPolicy='no-referrer';
      const start=performance.now();

      pre.onload=()=>{ if(token!==genToken) return;
        img.src=pre.src; setLoading(false); setControlsEnabled(true);
        log(`Loaded OK in ${Math.round(performance.now()-start)}ms via ${url.includes('weserv.nl')?'proxy':'direct'}`);
        try{ extractPaletteToBackground(pre); }catch{ setVeryDarkWaitingGradient(); }
      };
      pre.onerror=()=>{ if(token!==genToken) return;
        if(++i<seq.length){
          setLoading(true,` (attempt ${i+1}/${seq.length})`);
          setTimeout(()=>tryOne(seq[i]), ATTEMPT_GAP_MS);
        } else {
          setLoading(false); setControlsEnabled(true);
          showError('Image load failed repeatedly.');
          log('All attempts failed (respecting API interval).');
        }
      };

      const now=Date.now();
      const wait=Math.max(0, MIN_API_INTERVAL_MS - (now - lastRequestAt));
      const go=()=>{ lastRequestAt=Date.now(); const bust=`&t=${Date.now()%1e7}`; pre.src=url + bust; if(pre.decode) pre.decode().catch(()=>{}); updatePromptUI(prompt,url); };
      if(wait>0){ log(`Throttling ${wait}ms before request to respect API interval`); setTimeout(go, wait); } else { go(); }
    }
  }

  /* debounce + binding */
  let debounceT=0, dragging=false;
  function scheduleGenerate(){
    clearTimeout(debounceT);
    setControlsEnabled(false);
    setLoading(true,' (queued)');
    setVeryDarkWaitingGradient();
    debounceT=setTimeout(()=>{
      setLoading(true,'');
      const p=choosePrompt();
      const n=encodeURIComponent(p).length;
      log(`Generate with prompt bytes=${n}`);
      loadSequence(p);
    }, WAIT_MS);
  }
  function on(el, type, handler, opts){ if(!el) return; el.addEventListener(type, handler, opts||false); }
  const supportsPointer = 'onpointerdown' in window;
  function bindSlider(el){
    on(el,'input', reflectLabels);
    on(el,'change', ()=>{ if(!dragging) scheduleGenerate(); });
    on(el,'keyup', (e)=>{ if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','Home','End','PageUp','PageDown'].includes(e.key)) scheduleGenerate(); });
    const release = ()=>{ if(dragging){ dragging=false; scheduleGenerate(); } };
    if(supportsPointer){
      on(el,'pointerdown', ()=>{ dragging=true; clearTimeout(debounceT); setControlsEnabled(true); setLoading(false); });
      on(el,'pointerup', release); on(el,'pointercancel', release); on(el,'lostpointercapture', release);
    }else{
      on(el,'mousedown', ()=>{ dragging=true; clearTimeout(debounceT); setControlsEnabled(true); setLoading(false); });
      on(window,'mouseup', release);
      on(el,'touchstart', ()=>{ dragging=true; clearTimeout(debounceT); setControlsEnabled(true); setLoading(false); }, {passive:true});
      on(window,'touchend', release, {passive:true}); on(window,'touchcancel', release, {passive:true});
    }
  }

  retryBtn.onclick=()=>scheduleGenerate();
  selfTestBtn.onclick=async()=>{
    log(`VERSION ${VERSION} | online=${navigator.onLine} | UA: ${navigator.userAgent}`);
    await probe('https://picsum.photos/4');
  };
  async function probe(url){
    return new Promise(res=>{
      const t0=performance.now();
      const im=new Image();
      im.onload=()=>{ log(`PROBE OK ${url} (${Math.round(performance.now()-t0)}ms)`); res(); };
      im.onerror=()=>{ log(`PROBE ERR ${url}`); res(); };
      im.referrerPolicy='no-referrer'; im.crossOrigin='anonymous'; im.src=url+`?p=${Date.now()%1e7}`;
    });
  }

  /* init */
  try{
    timeEl.value =(Math.random()*24)|0;
    envEl.value  =(Math.random()*habitats.length)|0;
    carEl.value  =(Math.random()*cars.length)|0;
    eraEl.value  =(Math.random()*eras.length)|0;
    dirEl.value  =(Math.random()*viewShort.length)|0;
    paintEl.value=(Math.random()*paints.length)|0;

    [timeEl, envEl, carEl, eraEl, dirEl, paintEl].forEach(bindSlider);
    reflectLabels();
    log('INIT OK — listeners bound, scheduling first generation');
    scheduleGenerate();
    setTimeout(()=>{ log('HEALTH: alive'); }, 1500);
  }catch(err){
    showError(`Init failed: ${err.message}`); console.error(err);
  }
})();
</script>
</body>
</html>