<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Lunar Eclipse â€” Frames (Moon / Shadow / Horizon), Physically Correct</title>
<style>
  :root{
    --bg:#000; --fg:#e8eef5; --muted:#9aa1ad;
    --moon-hi:#dddddd; --moon-lo:#bfc3c8;
    --ring:rgba(255,255,255,.22);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden;}
  #stage{position:relative; width:100vw; height:min(100svh,100vh);
    display:flex; align-items:center; justify-content:center;}
  #cv{width:92vmin; height:92vmin; display:block; border-radius:12px;}

  .hud-top{
    position:absolute; top:calc(env(safe-area-inset-top,0px) + 10px); left:10px; right:10px;
    display:flex; justify-content:space-between; gap:8px; z-index:3;
  }
  .left, .right{display:flex; gap:8px; align-items:center;}
  .btn{
    -webkit-tap-highlight-color:transparent; border:1px solid #293242; background:#12161d; color:var(--fg);
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .btn:active{transform:translateY(1px)}
  .select{
    border:1px solid #293242; background:#12161d; color:var(--fg);
    padding:8px 10px; border-radius:10px; font-weight:600;
  }

  .bottom-ui{
    position:absolute; left:calc(env(safe-area-inset-left,0px) + 10px);
    right:calc(env(safe-area-inset-right,0px) + 10px);
    bottom:calc(env(safe-area-inset-bottom,0px) + 10px);
    display:flex; flex-direction:column; gap:6px; align-items:stretch; z-index:3;
  }
  .time{
    text-align:center; color:var(--fg); font-weight:600;
    padding:6px 10px; border-radius:10px; background:rgba(18,22,29,.75);
    border:1px solid #2a3445; backdrop-filter:saturate(120%) blur(6px);
  }
  .timeline{
    appearance:none; width:100%; height:36px; margin:0; padding:0 2px; background:transparent;
  }
  .timeline::-webkit-slider-runnable-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-moz-range-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-webkit-slider-thumb{-webkit-appearance:none; width:24px; height:24px; margin-top:-10px; border-radius:50%;
    background:#e6eef8; border:0;}
  .timeline::-moz-range-thumb{width:24px; height:24px; border:0; border-radius:50%; background:#e6eef8;}

  #err{position:absolute; top:8px; left:8px; padding:4px 8px; border-radius:8px; font-size:12px;
    background:#3b1e1e; color:#ffd4d4; border:1px solid #592b2b; display:none; z-index:9;}
</style>
</head>
<body>
  <div id="stage">
    <canvas id="cv"></canvas>

    <div id="err"></div>

    <div class="hud-top">
      <div class="left">
        <button id="nowBtn"  class="btn">Now</button>
        <button id="playBtn" class="btn">Play</button>
        <button id="compassBtn" class="btn" title="Enable live heading">ðŸ§­ Turn-to-Moon</button>
      </div>
      <div class="right">
        <label for="frameSelect" style="color:var(--muted);font-weight:600">Frame:</label>
        <select id="frameSelect" class="select">
          <option value="moon" selected>Moon fixed (local)</option>
          <option value="shadow">Earthâ€™s shadow fixed (local)</option>
          <option value="horizon">Horizon fixed (sky view)</option>
        </select>
      </div>
    </div>

    <div class="bottom-ui">
      <div id="timeLabel" class="time">â€”</div>
      <input id="timeSlider" class="timeline" type="range" min="0" max="100" step="1" />
    </div>
  </div>

<script>
(()=>{
// ---------------- small error badge ----------------
const badge = document.getElementById('err');
function showErr(m){ badge.textContent=m; badge.style.display='inline-block'; console.error(m); }

// =================== Besselian polynomials (TT baseline) ===================
const poly = {
  t0TT: Date.parse("2025-09-07T18:00:00Z"),
  dTsec: 71.9, // TT-UTC
  // x,y,d,f1(pen),f2(umb),f3(Moon SD) [deg on sky]; x east+, y north+
  x:[ 0.02402,  0.48791,  0.00019, -0.00001],
  y:[-0.29632,  0.26398,  0.00016, -0.00000],
  d:[ 0.10060, -0.00030, -0.00000,  0.00000],
  f1:[ 1.26901,  0.00040, -0.00000,  0.00000],
  f2:[ 0.73989,  0.00040, -0.00000,  0.00000],
  f3:[ 0.26935,  0.00011, -0.00000,  0.00000]
};
function evalPoly(c,t){ return ((c[3]||0)*t + (c[2]||0))*t*t + (c[1]||0)*t + c[0]; }
function besselAtUTC(msUTC){
  const msTT = msUTC + poly.dTsec*1000;
  const t = (msTT - poly.t0TT)/3600000;
  const x=evalPoly(poly.x,t), y=evalPoly(poly.y,t);
  const f1=evalPoly(poly.f1,t), f2=evalPoly(poly.f2,t), sm=evalPoly(poly.f3,t);
  return { x, y, f1, f2, sm };
}

// =================== Contacts (UTC window) ===================
const contacts = [
  { k:"P1", ms:Date.parse("2025-09-07T15:28:06Z") },
  { k:"U1", ms:Date.parse("2025-09-07T16:26:51Z") },
  { k:"U2", ms:Date.parse("2025-09-07T17:30:36Z") },
  { k:"GE", ms:Date.parse("2025-09-07T18:11:46Z") },
  { k:"U3", ms:Date.parse("2025-09-07T18:53:18Z") },
  { k:"U4", ms:Date.parse("2025-09-07T19:56:53Z") },
  { k:"P4", ms:Date.parse("2025-09-07T20:55:27Z") },
];
const T0=contacts[0].ms, T1=contacts[contacts.length-1].ms;

// =================== DOM refs ===================
const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
const slider = document.getElementById('timeSlider');
const playBtn = document.getElementById('playBtn');
const nowBtn  = document.getElementById('nowBtn');
const compassBtn = document.getElementById('compassBtn');
const timeLabel = document.getElementById('timeLabel');
const frameSelect = document.getElementById('frameSelect');

slider.min=T0; slider.max=T1; slider.step=1000; slider.value=clamp(Date.now(),T0,T1);

// =================== Topocentric Moon + parallactic angle ===================
const rad=Math.PI/180, dayMs=86400000;
const obs={lat:50.0755, lon:14.4378}; // default Prague; geoloc overwrites
let deviceHeading=null, moonBearing=null, moonAlt=null, parAng=0;
let aligned=false, linkToNow=false;
let frameMode='moon';

function toJulian(d){return d.valueOf()/dayMs - 0.5 + 2440588;}
function toDays(d){return toJulian(d) - 2451545;}
function rightAsc(l,b){ const e=23.4397*rad; return Math.atan2(Math.sin(l)*Math.cos(e)-Math.tan(b)*Math.sin(e), Math.cos(l)); }
function decl(l,b){ const e=23.4397*rad; return Math.asin(Math.sin(b)*Math.cos(e)+Math.cos(b)*Math.sin(e)*Math.sin(l)); }
function sidereal(D,lw){return rad*(280.16 + 360.9856235*D) - lw;}
function moonCoords(D){
  const L=rad*(218.316+13.176396*D), M=rad*(134.963+13.064993*D), F=rad*(93.272+13.229350*D);
  const l=L + rad*6.289*Math.sin(M), b=rad*5.128*Math.sin(F), dist=385001 - 20905*Math.cos(M);
  return { ra:rightAsc(l,b), dec:decl(l,b), dist };
}
function getMoonPosAndEqu(date, lat, lon){
  const D=toDays(date), lw=-lon*rad, Ï†=lat*rad, c=moonCoords(D), H=sidereal(D,lw)-c.ra;
  let h=Math.asin(Math.sin(Ï†)*Math.sin(c.dec)+Math.cos(Ï†)*Math.cos(c.dec)*Math.cos(H));
  const az=Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(Ï†)-Math.tan(c.dec)*Math.cos(Ï†));
  const hp=Math.asin(1/(c.dist/6371)); h=h-hp*Math.cos(h);
  // parallactic angle (angle from celestial North to local Up at Moon)
  const q = Math.atan2(Math.sin(H), Math.tan(Ï†)*Math.cos(c.dec) - Math.sin(c.dec)*Math.cos(H));
  return { alt:h, az, q };
}
function azToBearing(az){ let b=(az+Math.PI)*180/Math.PI; b%=360; if(b<0)b+=360; return b; }
function normDeg(a){ a%=360; if(a<0)a+=360; return a; }

// =================== Events (bind BEFORE first paint) ===================
let playing=false;
slider.addEventListener('input', ()=>{ linkToNow=false; safeUpdate(Number(slider.value)); });
nowBtn.addEventListener('click', ()=>{ linkToNow=true; safeUpdate(clamp(Date.now(),T0,T1)); });
playBtn.addEventListener('click', ()=>{ playing=!playing; linkToNow=false; playBtn.textContent=playing?'Pause':'Play'; });
frameSelect.addEventListener('change', ()=>{ frameMode = frameSelect.value; safeUpdate(Number(slider.value)); });

compassBtn.addEventListener('click', ()=>{
  if (navigator.geolocation){
    navigator.geolocation.getCurrentPosition(p=>{obs.lat=p.coords.latitude; obs.lon=p.coords.longitude;}, ()=>{});
  }
  function onDO(e){
    let h=null;
    if (typeof e.webkitCompassHeading==='number') h=e.webkitCompassHeading; // iOS true-north
    else if (typeof e.alpha==='number'){
      h = 360 - e.alpha;
      const ang=(screen.orientation && typeof screen.orientation.angle==='number')?screen.orientation.angle:(window.orientation||0);
      h = (h + ang);
    }
    if (h!=null && isFinite(h)){ deviceHeading=normDeg(h); safeUpdate(Number(slider.value)); }
  }
  const type=('ondeviceorientationabsolute' in window)?'deviceorientationabsolute':'deviceorientation';
  if (window.DeviceOrientationEvent){
    if (typeof DeviceOrientationEvent.requestPermission==='function'){
      DeviceOrientationEvent.requestPermission().then(s=>{ if(s==='granted') window.addEventListener(type,onDO,true); }).catch(()=>{});
    } else window.addEventListener(type,onDO,true);
  }
});

// =================== Layout (guards) ===================
let compassCenter={x:0,y:0,r:0};
function cacheCompassPlacement(){
  const W=cv.clientWidth|0, H=cv.clientHeight|0; if(!W||!H) return;
  const compR=Math.min(W,H)*0.095;
  const canvasRect=cv.getBoundingClientRect(), sliderRect=slider.getBoundingClientRect();
  const sliderTopInCanvas=sliderRect.top - canvasRect.top;
  const cy=Math.min(H-16-compR, Math.max(compR+16, sliderTopInCanvas - 10 - compR));
  compassCenter={x:W/2, y:cy, r:compR};
}
function resize(){
  try{
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const w=cv.clientWidth|0, h=cv.clientHeight|0;
    if(!w||!h){ requestAnimationFrame(resize); return; }
    cv.width=Math.round(w*dpr); cv.height=Math.round(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    cacheCompassPlacement();
    safeUpdate(Number(slider.value));
  }catch(e){ showErr('resize:'+e.message); }
}
window.addEventListener('resize', resize, {passive:true});
requestAnimationFrame(resize);

// =================== RAF loop ===================
let last=performance.now(), RATE=120;
function loop(now){
  try{
    const nowMs=Date.now();
    if (linkToNow){
      const v=clamp(nowMs,T0,T1);
      if(Math.abs(v-Number(slider.value))>250) slider.value=v;
      safeUpdate(v);
    } else if (playing){
      const dt=(now-last)/1000; let v=Number(slider.value)+dt*1000*RATE; if(v>T1) v=T0;
      slider.value=v; safeUpdate(v);
    }
    last=now;
  }catch(e){ showErr('loop:'+e.message); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =================== Update + Draw ===================
function safeUpdate(ms){ try{ updateForTime(ms); }catch(e){ showErr('update:'+e.message); } }
function updateForTime(ms){
  const p = getMoonPosAndEqu(new Date(ms), obs.lat, obs.lon);
  moonAlt = p.alt*180/Math.PI;
  moonBearing = azToBearing(p.az);
  parAng = p.q; // radians
  const isNow=linkToNow && !playing;
  const txt=new Date(ms).toLocaleString([], {weekday:'short', hour:'2-digit', minute:'2-digit', second:'2-digit', timeZoneName:'short'});
  timeLabel.textContent=(playing?'Sim ': (isNow?'Now ':'Sim ')) + txt;
  safeDraw(ms);
}
function safeDraw(ms){ try{ draw(ms); }catch(e){ showErr('draw:'+e.message); } }

// ------- Core draw with frame switching -------
function draw(msUTC){
  const W=cv.clientWidth|0, H=cv.clientHeight|0; if(!W||!H) return;
  const cx=W/2, cy=H/2;
  const Rpx=Math.max(1, Math.min(W,H)*0.28);

  // Besselian â†’ Moon radii, rotate from equatorial into local horizon frame (up=zenith)
  const B=besselAtUTC(msUTC);
  const toMR=1/Math.max(1e-6,B.sm);

  // Equatorial (east,right / north,up) â†’ rotate by -parAng to local up
  const xe =  B.x*toMR, yn = B.y*toMR;
  const cq=Math.cos(parAng), sq=Math.sin(parAng);
  const x_loc =  xe*cq + yn*sq;   // right+
  const y_loc = -xe*sq + yn*cq;   // up+

  // Common radii (Moon radii)
  const penR=B.f1*toMR, umbR=B.f2*toMR;

  // Branch: horizon vs object-centered
  if (frameMode==='horizon'){
    drawHorizonView(W,H,B, x_loc, y_loc);
    return;
  }

  // Object-centered frames (local view)
  let moonCx=0, moonCy=0, shCx=0, shCy=0;
  if (frameMode==='moon'){
    // Moon at center; shadow offset by (x_loc,y_loc)
    moonCx = 0; moonCy = 0;
    shCx =  x_loc; shCy = -y_loc;
  } else {
    // SHADOW fixed: shadow at center; moon offset oppositely
    shCx = 0; shCy = 0;
    moonCx = -x_loc; moonCy =  y_loc;
  }

  // Clear
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  // 1) Background shadow (unclipped)
  ctx.save(); ctx.translate(cx,cy); ctx.scale(Rpx,Rpx);
  drawConcentricShadow(shCx, shCy, umbR, penR, 'background');
  ctx.restore();

  // 2) Moon base (at moonCx,moonCy)
  ctx.save(); ctx.translate(cx + moonCx*Rpx, cy + (-moonCy)*Rpx);
  const g = ctx.createRadialGradient(-Rpx*0.25,-Rpx*0.25,Math.max(1,Rpx*0.2), 0,0,Rpx);
  g.addColorStop(0, getCSS('--moon-hi')); g.addColorStop(1, getCSS('--moon-lo'));
  ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();

  // 3) Shadow ON the Moon (clip + multiply)
  ctx.save();
  ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.clip();
  ctx.globalCompositeOperation='multiply';
  ctx.translate( (shCx - moonCx)*Rpx, (shCy - moonCy)*Rpx );
  ctx.scale(Rpx,Rpx);
  drawConcentricShadow(0, 0, umbR, penR, 'onMoon');
  ctx.globalCompositeOperation='source-over';
  ctx.restore(); // unclip
  ctx.restore(); // moon

  // 4) Turn-to-Moon compass
  drawTurnToMoon(compassCenter.x,compassCenter.y,compassCenter.r);
}

// ---- Horizon-fixed sky view (both Moon and shadow move; true horizon line & az scale) ----
function drawHorizonView(W,H,B, x_loc, y_loc){
  // Angular scale (degâ†’px): consistent (isotropic) so circles stay circles.
  const pad = Math.round(Math.min(W,H)*0.06);
  const Sx = (W - 2*pad) / 360; // deg az per px
  const Sy = (H - 2*pad) / 90;  // deg alt per px
  const S  = Math.min(Sx, Sy);  // isotropic scale (deg â†’ px)

  // Moon topocentric alt/az (deg)
  const altM = moonAlt; // already in degrees
  // az center for mapping: center the view on current Moon az to avoid wrap issues
  const az0 = moonBearing; // degrees [0,360)

  // Local tangent offsets (deg) from Moon to shadow:
  // small-angle approx on the sphere:
  const dAlt =  y_loc;                  // deg up
  const dAz  =  x_loc / Math.max(1e-6, Math.cos(altM*rad)); // deg in azimuth

  const altS = altM + dAlt;                  // shadow altitude
  const azS  = normDeg(az0 + dAz);           // shadow azimuth

  // Mapping helpers (center az around az0)
  const mapAz = (azDeg)=>{ let d = ((azDeg - az0 + 540)%360)-180; return d; }; // [-180,180]
  const toX = (azDeg)=> Math.round(W/2 + mapAz(azDeg)*S);
  const toY = (altDeg)=> Math.round(H - pad - altDeg*S);

  // Positions
  const xM = toX(az0), yM = toY(altM);
  const xS = toX(azS), yS = toY(altS);

  // Radii in degrees (B.f1/f2 are already degrees), convert to px via S
  const rPenPx = B.f1 * S;
  const rUmbPx = B.f2 * S;
  // Moon apparent semidiameter (deg) â†’ pixels
  const rMoonPx = B.sm * S;

  // Clear
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  // Horizon line and azimuth ticks (every 30Â°)
  const yH = toY(0);
  ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(pad,yH); ctx.lineTo(W-pad,yH); ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,.5)'; ctx.font='600 11px system-ui,-apple-system,Segoe UI';
  for(let a=-180;a<=180;a+=30){
    const x = Math.round(W/2 + a*S);
    ctx.beginPath(); ctx.moveTo(x,yH); ctx.lineTo(x,yH+6); ctx.stroke();
    const label = normDeg(az0 + a) + 'Â°';
    ctx.fillText(label, x-12, yH+18);
  }

  // Background shadow rings (center at xS,yS) â€” faint
  drawRingsAt(xS,yS,rUmbPx,rPenPx,'background');

  // Moon disk (center at xM,yM)
  ctx.save(); ctx.translate(xM,yM);
  const g = ctx.createRadialGradient(-rMoonPx*0.25,-rMoonPx*0.25,Math.max(1,rMoonPx*0.2), 0,0,rMoonPx);
  g.addColorStop(0, getCSS('--moon-hi')); g.addColorStop(1, getCSS('--moon-lo'));
  ctx.beginPath(); ctx.arc(0,0,rMoonPx,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();

  // Shadow on Moon (clip + multiply) with same rings, translated into Moon-local
  ctx.save();
  ctx.beginPath(); ctx.arc(0,0,rMoonPx,0,Math.PI*2); ctx.clip();
  ctx.globalCompositeOperation='multiply';
  ctx.translate(xS - xM, yS - yM);
  drawRingsAt(0,0,rUmbPx,rPenPx,'onMoon');
  ctx.globalCompositeOperation='source-over';
  ctx.restore(); // unclip
  ctx.restore(); // moon

  // Turn-to-Moon compass
  drawTurnToMoon(compassCenter.x,compassCenter.y,compassCenter.r);
}

// Helper to draw rings in pixel space (for horizon view)
function drawRingsAt(cx,cy,rUmbPx,rPenPx,mode){
  const Npen=20, Numb=28;
  const k=(mode==='onMoon') ? {pen:0.45, umbCtr:0.92, umbEdg:0.40} : {pen:0.10, umbCtr:0.24, umbEdg:0.12};

  // Penumbra
  for(let i=0;i<Npen;i++){
    const t0=i/Npen, t1=(i+1)/Npen;
    const r0=lerp(rUmbPx,rPenPx,t0), r1=lerp(rUmbPx,rPenPx,t1);
    const u=1 - t0; const a=k.pen*(u*u);
    ringPx(cx,cy,r1,r0,a,mode,false);
  }
  // Umbra
  for(let i=0;i<Numb;i++){
    const t0=i/Numb, t1=(i+1)/Numb;
    const r0=lerp(0,rUmbPx,t0), r1=lerp(0,rUmbPx,t1);
    const a=(mode==='onMoon') ? (k.umbCtr - (k.umbCtr-k.umbEdg)*Math.pow(t0,0.8))
                              : (k.umbCtr*0.3 + (k.umbEdg*0.7)*(1-t0));
    ringPx(cx,cy,r1,r0,a,mode,true);
  }

  if(mode==='background'){
    ctx.lineWidth=1; ctx.strokeStyle=getCSS('--ring');
    ctx.beginPath(); ctx.arc(cx,cy,rPenPx,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(cx,cy,rUmbPx,0,Math.PI*2); ctx.stroke();
  }
}
function ringPx(cx,cy,rOuter,rInner,alpha,mode,isUmbra){
  if(rOuter<=0||rOuter<=rInner) return;
  ctx.beginPath(); ctx.arc(cx,cy,rOuter,0,Math.PI*2);
  if(rInner>0) ctx.arc(cx,cy,rInner,0,Math.PI*2,true);
  ctx.fillStyle=(mode==='onMoon' && isUmbra) ? `rgba(130,40,30,${clamp(alpha,0,1)})`
                                             : `rgba(0,0,0,${clamp(alpha,0,1)})`;
  try{ ctx.fill('evenodd'); }catch(_){ ctx.fill(); }
}

// ---- Concentric shadow (Moon/Shadow frames; units: Moon radii) ----
function drawConcentricShadow(cxR,cyR,umbR,penR,mode){
  const Npen=20, Numb=28;
  const k=(mode==='onMoon') ? {pen:0.45, umbCtr:0.92, umbEdg:0.40} : {pen:0.10, umbCtr:0.24, umbEdg:0.12};

  // penumbra: outerâ†’inner
  for(let i=0;i<Npen;i++){
    const t0=i/Npen, t1=(i+1)/Npen;
    const r0=lerp(umbR,penR,t0), r1=lerp(umbR,penR,t1);
    const u=1 - t0; const a=k.pen*(u*u);
    ringR(cxR,cyR,r1,r0,a,mode,false);
  }
  // umbra: centerâ†’edge
  for(let i=0;i<Numb;i++){
    const t0=i/Numb, t1=(i+1)/Numb;
    const r0=lerp(0,umbR,t0), r1=lerp(0,umbR,t1);
    const a=(mode==='onMoon') ? (k.umbCtr - (k.umbCtr-k.umbEdg)*Math.pow(t0,0.8))
                              : (k.umbCtr*0.3 + (k.umbEdg*0.7)*(1-t0));
    ringR(cxR,cyR,r1,r0,a,mode,true);
  }

  if(mode==='background'){
    const s=1/Math.max(1, cv.clientWidth*0.28);
    ctx.lineWidth=s; ctx.strokeStyle=getCSS('--ring');
    ctx.beginPath(); ctx.arc(cxR,cyR,penR,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(cxR,cyR,umbR,0,Math.PI*2); ctx.stroke();
  }
}
function ringR(cxR,cyR,rOuterR,rInnerR,alpha,mode,isUmbra){
  if(rOuterR<=0||rOuterR<=rInnerR) return;
  ctx.beginPath(); ctx.arc(cxR,cyR,rOuterR,0,Math.PI*2);
  if(rInnerR>0) ctx.arc(cxR,cyR,rInnerR,0,Math.PI*2,true);
  ctx.fillStyle=(mode==='onMoon' && isUmbra) ? `rgba(130,40,30,${clamp(alpha,0,1)})`
                                             : `rgba(0,0,0,${clamp(alpha,0,1)})`;
  try{ ctx.fill('evenodd'); }catch(_){ ctx.fill(); }
}

// ---- Turn-to-Moon compass: one relative arrow (no north) ----
function drawTurnToMoon(cx,cy,r){
  if(!r) return;
  ctx.save(); ctx.translate(cx,cy);
  ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.2)';
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();

  if(moonBearing!=null && deviceHeading!=null){
    const rel=normDeg(moonBearing - deviceHeading); // 0 = straight ahead
    const a=(rel-90)*rad;
    const inner=r*0.62;
    ctx.save(); ctx.rotate(a);
    ctx.beginPath(); ctx.moveTo(inner*0.1,0); ctx.lineTo(inner*0.1,-6);
    ctx.lineTo(r*0.88,0); ctx.lineTo(inner*0.1,6); ctx.closePath();
    ctx.fillStyle=(moonAlt!=null && moonAlt>0)?'rgba(255,220,140,.98)':'rgba(180,180,180,.85)';
    ctx.fill(); ctx.restore();

    const diff=rel<=180?rel:360-rel;
    const ok=diff<=8;
    if(ok){
      ctx.beginPath(); ctx.arc(0,0,r+6,0,Math.PI*2);
      ctx.strokeStyle='rgba(255,220,140,.85)'; ctx.lineWidth=4; ctx.stroke();
      if(!aligned && 'vibrate' in navigator) navigator.vibrate(20);
    }
    aligned=ok;
  } else {
    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.25)';
    ctx.beginPath(); ctx.moveTo(0,-r*0.62); ctx.lineTo(0,-r); ctx.stroke();
  }

  ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,.9)'; ctx.fill();
  ctx.restore();
}

// =================== Helpers ===================
function lerp(a,b,t){return a+(b-a)*t;}
function getCSS(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}
function clamp(v,a,b){return Math.min(Math.max(v,a),b);}

})();
</script>
</body>
</html>