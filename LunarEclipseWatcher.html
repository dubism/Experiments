<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Lunar Eclipse â€” Frames (Moon / Shadow / Horizon) â€” Corrected & Zoomed</title>
<style>
  :root{
    --bg:#000; --fg:#e8eef5; --muted:#9aa1ad;
    --moon-hi:#dddddd; --moon-lo:#bfc3c8;
    --ring:rgba(255,255,255,.22);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden;}
  #stage{position:relative; width:100vw; height:min(100svh,100vh);
    display:flex; align-items:center; justify-content:center;}
  #cv{width:92vmin; height:92vmin; display:block; border-radius:12px;}

  .hud-top{
    position:absolute; top:calc(env(safe-area-inset-top,0px) + 10px); left:10px; right:10px;
    display:flex; justify-content:space-between; gap:8px; z-index:3;
  }
  .left, .right{display:flex; gap:8px; align-items:center;}
  .btn{
    -webkit-tap-highlight-color:transparent; border:1px solid #293242; background:#12161d; color:var(--fg);
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .btn:active{transform:translateY(1px)}
  .select{
    border:1px solid #293242; background:#12161d; color:var(--fg);
    padding:8px 10px; border-radius:10px; font-weight:600;
  }

  .bottom-ui{
    position:absolute; left:calc(env(safe-area-inset-left,0px) + 10px);
    right:calc(env(safe-area-inset-right,0px) + 10px);
    bottom:calc(env(safe-area-inset-bottom,0px) + 10px);
    display:flex; flex-direction:column; gap:6px; align-items:stretch; z-index:3;
  }
  .time{
    text-align:center; color:var(--fg); font-weight:600;
    padding:6px 10px; border-radius:10px; background:rgba(18,22,29,.75);
    border:1px solid #2a3445; backdrop-filter:saturate(120%) blur(6px);
  }
  .timeline{
    appearance:none; width:100%; height:36px; margin:0; padding:0 2px; background:transparent;
  }
  .timeline::-webkit-slider-runnable-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-moz-range-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-webkit-slider-thumb{-webkit-appearance:none; width:24px; height:24px; margin-top:-10px; border-radius:50%;
    background:#e6eef8; border:0;}
  .timeline::-moz-range-thumb{width:24px; height:24px; border:0; border-radius:50%; background:#e6eef8;}

  #err{position:absolute; top:8px; left:8px; padding:4px 8px; border-radius:8px; font-size:12px;
    background:#3b1e1e; color:#ffd4d4; border:1px solid #592b2b; display:none; z-index:9;}
</style>
</head>
<body>
  <div id="stage">
    <canvas id="cv"></canvas>

    <div id="err"></div>

    <div class="hud-top">
      <div class="left">
        <button id="nowBtn"  class="btn">Now</button>
        <button id="playBtn" class="btn">Play</button>
        <button id="compassBtn" class="btn" title="Enable live heading">ðŸ§­ Turn-to-Moon</button>
      </div>
      <div class="right">
        <label for="frameSelect" style="color:var(--muted);font-weight:600">Frame:</label>
        <select id="frameSelect" class="select">
          <option value="moon" selected>Moon fixed (local)</option>
          <option value="shadow">Earthâ€™s shadow fixed (local)</option>
          <option value="horizon">Horizon fixed (sky view)</option>
        </select>
      </div>
    </div>

    <div class="bottom-ui">
      <div id="timeLabel" class="time">â€”</div>
      <input id="timeSlider" class="timeline" type="range" min="0" max="100" step="1" />
    </div>
  </div>

<script>
(()=>{
// ---------- small inline error badge ----------
const badge = document.getElementById('err');
function showErr(m){ badge.textContent=m; badge.style.display='inline-block'; console.error(m); }

// =================== Besselian polynomials (TT baseline) ===================
const poly = {
  t0TT: Date.parse("2025-09-07T18:00:00Z"),
  dTsec: 71.9,                      // Î”T = TTâˆ’UTC (s)
  // x,y,d,f1(pen),f2(umb),f3(Moon SD) â€” degrees on sky; x east+, y north+
  x:[ 0.02402,  0.48791,  0.00019, -0.00001],
  y:[-0.29632,  0.26398,  0.00016, -0.00000],
  d:[ 0.10060, -0.00030, -0.00000,  0.00000],
  f1:[ 1.26901,  0.00040, -0.00000,  0.00000],
  f2:[ 0.73989,  0.00040, -0.00000,  0.00000],
  f3:[ 0.26935,  0.00011, -0.00000,  0.00000]
};
function evalPoly(c,t){ return ((c[3]||0)*t + (c[2]||0))*t*t + (c[1]||0)*t + c[0]; }
function besselAtUTC(msUTC){
  const msTT = msUTC + poly.dTsec*1000;
  const t = (msTT - poly.t0TT)/3600000; // hours from t0 (TT)
  const x=evalPoly(poly.x,t), y=evalPoly(poly.y,t);
  const f1=evalPoly(poly.f1,t), f2=evalPoly(poly.f2,t), sm=evalPoly(poly.f3,t);
  return { x, y, f1, f2, sm }; // all in degrees
}

// =================== Contacts (UTC) ===================
const contacts = [
  { k:"P1", ms:Date.parse("2025-09-07T15:28:06Z") },
  { k:"U1", ms:Date.parse("2025-09-07T16:26:51Z") },
  { k:"U2", ms:Date.parse("2025-09-07T17:30:36Z") },
  { k:"GE", ms:Date.parse("2025-09-07T18:11:46Z") },
  { k:"U3", ms:Date.parse("2025-09-07T18:53:18Z") },
  { k:"U4", ms:Date.parse("2025-09-07T19:56:53Z") },
  { k:"P4", ms:Date.parse("2025-09-07T20:55:27Z") },
];
const T0=contacts[0].ms, T1=contacts[contacts.length-1].ms;

// =================== DOM ===================
const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
const slider = document.getElementById('timeSlider');
const playBtn = document.getElementById('playBtn');
const nowBtn  = document.getElementById('nowBtn');
const compassBtn = document.getElementById('compassBtn');
const timeLabel = document.getElementById('timeLabel');
const frameSelect = document.getElementById('frameSelect');

slider.min=T0; slider.max=T1; slider.step=1000; slider.value=clamp(Date.now(),T0,T1);

// =================== Topocentric Moon + parallactic angle ===================
const rad=Math.PI/180, dayMs=86400000;
const obs={lat:50.0755, lon:14.4378}; // default; geolocation can overwrite
let deviceHeading=null, moonBearing=null, moonAlt=null, parAng=0;
let aligned=false, linkToNow=false;
let frameMode='moon';

function toJulian(d){return d.valueOf()/dayMs - 0.5 + 2440588;}
function toDays(d){return toJulian(d) - 2451545;}
function rightAsc(l,b){ const e=23.4397*rad; return Math.atan2(Math.sin(l)*Math.cos(e)-Math.tan(b)*Math.sin(e), Math.cos(l)); }
function decl(l,b){ const e=23.4397*rad; return Math.asin(Math.sin(b)*Math.cos(e)+Math.cos(b)*Math.sin(e)*Math.sin(l)); }
function sidereal(D,lw){return rad*(280.16 + 360.9856235*D) - lw;}
function moonCoords(D){
  const L=rad*(218.316+13.176396*D), M=rad*(134.963+13.064993*D), F=rad*(93.272+13.229350*D);
  const l=L + rad*6.289*Math.sin(M), b=rad*5.128*Math.sin(F), dist=385001 - 20905*Math.cos(M);
  return { ra:rightAsc(l,b), dec:decl(l,b), dist };
}
function getMoonPosAndEqu(date, lat, lon){
  const D=toDays(date), lw=-lon*rad, Ï†=lat*rad, c=moonCoords(D), H=sidereal(D,lw)-c.ra;
  let h=Math.asin(Math.sin(Ï†)*Math.sin(c.dec)+Math.cos(Ï†)*Math.cos(c.dec)*Math.cos(H));
  const az=Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(Ï†)-Math.tan(c.dec)*Math.cos(Ï†));
  const hp=Math.asin(1/(c.dist/6371)); h=h-hp*Math.cos(h);                  // parallax approx
  const q = Math.atan2(Math.sin(H), Math.tan(Ï†)*Math.cos(c.dec) - Math.sin(c.dec)*Math.cos(H)); // parallactic
  return { alt:h, az, q };
}
function azToBearing(az){ let b=(az+Math.PI)*180/Math.PI; b%=360; if(b<0)b+=360; return b; }
function normDeg(a){ a%=360; if(a<0)a+=360; return a; }

// =================== Events (bind BEFORE first paint) ===================
let playing=false;
slider.addEventListener('input', ()=>{ linkToNow=false; safeUpdate(Number(slider.value)); });
nowBtn.addEventListener('click', ()=>{ linkToNow=true; safeUpdate(clamp(Date.now(),T0,T1)); });
playBtn.addEventListener('click', ()=>{ playing=!playing; linkToNow=false; playBtn.textContent=playing?'Pause':'Play'; });
frameSelect.addEventListener('change', ()=>{ frameMode = frameSelect.value; safeUpdate(Number(slider.value)); });

compassBtn.addEventListener('click', ()=>{
  if (navigator.geolocation){
    navigator.geolocation.getCurrentPosition(p=>{obs.lat=p.coords.latitude; obs.lon=p.coords.longitude;}, ()=>{});
  }
  function onDO(e){
    let h=null;
    if (typeof e.webkitCompassHeading==='number') h=e.webkitCompassHeading; // iOS true-north
    else if (typeof e.alpha==='number'){
      h = 360 - e.alpha;
      const ang=(screen.orientation && typeof screen.orientation.angle==='number')?screen.orientation.angle:(window.orientation||0);
      h = (h + ang);
    }
    if (h!=null && isFinite(h)){ deviceHeading=normDeg(h); safeUpdate(Number(slider.value)); }
  }
  const type=('ondeviceorientationabsolute' in window)?'deviceorientationabsolute':'deviceorientation';
  if (window.DeviceOrientationEvent){
    if (typeof DeviceOrientationEvent.requestPermission==='function'){
      DeviceOrientationEvent.requestPermission().then(s=>{ if(s==='granted') window.addEventListener(type,onDO,true); }).catch(()=>{});
    } else window.addEventListener(type,onDO,true);
  }
});

// =================== Layout (guards) ===================
let compassCenter={x:0,y:0,r:0};
function cacheCompassPlacement(){
  const W=cv.clientWidth|0, H=cv.clientHeight|0; if(!W||!H) return;
  const compR=Math.min(W,H)*0.095;
  const canvasRect=cv.getBoundingClientRect(), sliderRect=slider.getBoundingClientRect();
  const sliderTopInCanvas=sliderRect.top - canvasRect.top;
  const cy=Math.min(H-16-compR, Math.max(compR+16, sliderTopInCanvas - 10 - compR));
  compassCenter={x:W/2, y:cy, r:compR};
}
function resize(){
  try{
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const w=cv.clientWidth|0, h=cv.clientHeight|0;
    if(!w||!h){ requestAnimationFrame(resize); return; }
    cv.width=Math.round(w*dpr); cv.height=Math.round(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    cacheCompassPlacement();
    safeUpdate(Number(slider.value));
  }catch(e){ showErr('resize:'+e.message); }
}
window.addEventListener('resize', resize, {passive:true});
requestAnimationFrame(resize);

// =================== RAF loop ===================
let last=performance.now(), RATE=120;
function loop(now){
  try{
    const nowMs=Date.now();
    if (linkToNow){
      const v=clamp(nowMs,T0,T1);
      if(Math.abs(v-Number(slider.value))>250) slider.value=v;
      safeUpdate(v);
    } else if (playing){
      const dt=(now-last)/1000; let v=Number(slider.value)+dt*1000*RATE; if(v>T1) v=T0;
      slider.value=v; safeUpdate(v);
    }
    last=now;
  }catch(e){ showErr('loop:'+e.message); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =================== Update + Draw ===================
function safeUpdate(ms){ try{ updateForTime(ms); }catch(e){ showErr('update:'+e.message); } }
function updateForTime(ms){
  const p = getMoonPosAndEqu(new Date(ms), obs.lat, obs.lon);
  moonAlt = p.alt*180/Math.PI;
  moonBearing = azToBearing(p.az);
  parAng = p.q; // radians
  const isNow=linkToNow && !playing;
  const txt=new Date(ms).toLocaleString([], {weekday:'short', hour:'2-digit', minute:'2-digit', second:'2-digit', timeZoneName:'short'});
  timeLabel.textContent=(playing?'Sim ': (isNow?'Now ':'Sim ')) + txt;
  safeDraw(ms);
}
function safeDraw(ms){ try{ draw(ms); }catch(e){ showErr('draw:'+e.message); } }

// ------- Core draw with frames -------
function draw(msUTC){
  const W=cv.clientWidth|0, H=cv.clientHeight|0; if(!W||!H) return;
  const cx=W/2, cy=H/2;
  const Rpx=Math.max(1, Math.min(W,H)*0.28);

  // Besselian at t (degrees) & rotate by âˆ’parAng into local horizon frame
  const B=besselAtUTC(msUTC);
  const sm=B.sm; // Moon SD in deg
  const xe =  B.x;              // east+
  const yn =  B.y;              // north+
  const cq=Math.cos(parAng), sq=Math.sin(parAng);
  // local tangent-plane offsets (deg): +x right, +y up
  const dx_deg =  xe*cq + yn*sq;
  const dy_deg = -xe*sq + yn*cq;

  // Convert to Moon-radii for object-centred views, and to SCREEN coords (y down)
  const dxR_screen =  (dx_deg / sm);
  const dyR_screen = -(dy_deg / sm);   // screen y: down+

  // Shadow radii (in Moon radii)
  const penR=B.f1/sm, umbR=B.f2/sm;

  if (frameMode==='horizon'){ drawHorizonView(W,H, B, dx_deg, dy_deg); return; }

  // ----- Object-centred frames -----
  // A single, consistent vector v = shadowRelativeToMoon (screen coords, Moon radii)
  const vx = dxR_screen, vy = dyR_screen;

  let moonCxR=0, moonCyR=0, shCxR=0, shCyR=0;
  if (frameMode==='moon'){
    // Moon fixed; shadow at +v
    moonCxR=0; moonCyR=0; shCxR=vx; shCyR=vy;
  } else { // 'shadow'
    // Shadow fixed; moon at âˆ’v  (this removes any residual vertical drift)
    shCxR=0; shCyR=0; moonCxR=-vx; moonCyR=-vy;
  }

  // Clear
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  // 1) Background shadow (unclipped) at shadow centre (stationary in 'shadow' frame)
  ctx.save(); ctx.translate(cx,cy); ctx.scale(Rpx,Rpx);
  drawConcentricShadow(shCxR, shCyR, umbR, penR, 'background');
  ctx.restore();

  // 2) Moon base
  ctx.save(); ctx.translate(cx + moonCxR*Rpx, cy + moonCyR*Rpx);
  const g = ctx.createRadialGradient(-Rpx*0.25,-Rpx*0.25,Math.max(1,Rpx*0.2), 0,0,Rpx);
  g.addColorStop(0, getCSS('--moon-hi')); g.addColorStop(1, getCSS('--moon-lo'));
  ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();

  // 3) Shadow ON the Moon (clip + multiply), positioned by (shadowâˆ’moon)
  ctx.save();
  ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.clip();
  ctx.globalCompositeOperation='multiply';
  ctx.translate( (shCxR - moonCxR)*Rpx, (shCyR - moonCyR)*Rpx );
  ctx.scale(Rpx,Rpx);
  drawConcentricShadow(0, 0, umbR, penR, 'onMoon');
  ctx.globalCompositeOperation='source-over';
  ctx.restore(); // unclip
  ctx.restore(); // moon

  // 4) Turn-to-Moon compass
  drawTurnToMoon(compassCenter.x,compassCenter.y,compassCenter.r);
}

// ---- Horizon-fixed sky view (auto-zoom: top-of-shadow at end maps to screen top) ----
function drawHorizonView(W,H,B_now, dx_deg_now, dy_deg_now){
  const pad = Math.round(Math.min(W,H)*0.06);

  // Compute anchored scale using END of window (T1):
  const P_end = getMoonPosAndEqu(new Date(T1), obs.lat, obs.lon);
  const B_end = besselAtUTC(T1);
  const cqE=Math.cos(P_end.q), sqE=Math.sin(P_end.q);
  const dxE =  B_end.x*cqE + B_end.y*sqE;           // deg (right+)
  const dyE = -B_end.x*sqE + B_end.y*cqE;           // deg (up+)
  const altM_end = P_end.alt*180/Math.PI;           // deg
  const altS_end = altM_end + dyE;                  // center altitude of shadow at end
  const topAlt_end = altS_end + B_end.f1;           // TOP of penumbra at end (deg)

  // Set isotropic scale S so that this topAlt_end maps to the very top (pad)
  const S_anchor = (H - 2*pad) / Math.max(1e-6, topAlt_end);  // degâ†’px

  // Current Moon/topo quantities
  const altM = moonAlt;                 // deg
  const az0  = moonBearing;             // deg (center x at Moon)
  const dAlt =  dy_deg_now;             // deg
  const dAz  =  dx_deg_now / Math.max(1e-6, Math.cos(altM*rad));  // deg in azimuth

  const altS = altM + dAlt;
  const azS  = normDeg(az0 + dAz);

  // Mapping helpers (center az around az0; horizon at alt=0 near bottom)
  const mapAz = (azDeg)=>{ let d = ((azDeg - az0 + 540)%360)-180; return d; }; // [-180,180]
  const toX = (azDeg)=> Math.round(W/2 + mapAz(azDeg)*S_anchor);
  const toY = (altDeg)=> Math.round(H - pad - altDeg*S_anchor);

  const xM = toX(az0), yM = toY(altM);
  const xS = toX(azS), yS = toY(altS);

  // Radii in pixels (use current B, isotropic S)
  const rPenPx = B_now.f1 * S_anchor;
  const rUmbPx = B_now.f2 * S_anchor;
  const rMoonPx = B_now.sm * S_anchor;

  // Clear
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  // Horizon line + sparse ticks (donâ€™t clutter when zoomed)
  const yH = toY(0);
  ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.lineWidth=1;
  ctx.beginPath(); ctx.moveTo(pad,yH); ctx.lineTo(W-pad,yH); ctx.stroke();
  ctx.fillStyle='rgba(255,255,255,.55)'; ctx.font='600 11px system-ui,-apple-system,Segoe UI';
  // Center az label only (others fly off-screen at large zoom)
  ctx.fillText((Math.round(az0)%360)+'Â°', W/2-12, yH+18);

  // Background shadow rings (faint)
  drawRingsAt(xS,yS,rUmbPx,rPenPx,'background');

  // Moon disk
  ctx.save(); ctx.translate(xM,yM);
  const g = ctx.createRadialGradient(-rMoonPx*0.25,-rMoonPx*0.25,Math.max(1,rMoonPx*0.2), 0,0,rMoonPx);
  g.addColorStop(0, getCSS('--moon-hi')); g.addColorStop(1, getCSS('--moon-lo'));
  ctx.beginPath(); ctx.arc(0,0,rMoonPx,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();

  // Shadow on Moon (clip + multiply)
  ctx.save();
  ctx.beginPath(); ctx.arc(0,0,rMoonPx,0,Math.PI*2); ctx.clip();
  ctx.globalCompositeOperation='multiply';
  ctx.translate(xS - xM, yS - yM);
  drawRingsAt(0,0,rUmbPx,rPenPx,'onMoon');
  ctx.globalCompositeOperation='source-over';
  ctx.restore(); // unclip
  ctx.restore(); // moon

  drawTurnToMoon(compassCenter.x,compassCenter.y,compassCenter.r);
}

// Helper to draw rings in