<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Lunar Eclipse â€” Physics-Precise (Besselian + Compass)</title>
<style>
  :root{
    --bg:#000; --fg:#e8eef5; --muted:#9aa1ad; --accent:#5ac8fa;
    --moon-hi:#dddddd; --moon-lo:#bfc3c8;
    --pen-fill:rgba(0,0,0,.18); --umb-fill:rgba(0,0,0,.35);
    --ring:rgba(255,255,255,.22);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden;}
  /* Fullscreen stage (robust height) */
  #stage{position:relative; width:100vw; height:min(100svh, 100vh); display:flex; align-items:center; justify-content:center;}
  /* Square canvas; Moon visual scale (kept) */
  #cv{width:92vmin; height:92vmin; display:block; border-radius:12px;}
  /* Top controls */
  .hud-top{position:absolute; top:calc(env(safe-area-inset-top,0px) + 10px); left:10px; right:10px;
    display:flex; justify-content:space-between; gap:8px; z-index:3;}
  .btn{
    -webkit-tap-highlight-color:transparent; border:1px solid #293242; background:#12161d; color:var(--fg);
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;
  }
  .btn:active{transform:translateY(1px)}
  /* Bottom timeline: fixed; no page scroll needed */
  .hud-bottom{position:absolute; left:calc(env(safe-area-inset-left,0px) + 10px);
    right:calc(env(safe-area-inset-right,0px) + 10px);
    bottom:calc(env(safe-area-inset-bottom,0px) + 12px);
    display:flex; gap:8px; align-items:center; z-index:3;}
  .timeline{appearance:none; width:100%; height:36px; margin:0; padding:0 2px; background:transparent;}
  .timeline::-webkit-slider-runnable-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-moz-range-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-webkit-slider-thumb{-webkit-appearance:none; width:24px; height:24px; margin-top:-10px; border-radius:50%;
    background:#e6eef8; border:0;}
  .timeline::-moz-range-thumb{width:24px; height:24px; border:0; border-radius:50%; background:#e6eef8;}
  /* Info sheet (closed by default) */
  .sheet{position:fixed; inset:auto 0 0 0; background:#0b1017; border-top:1px solid #1e2632;
    transform:translateY(100%); transition:.25s transform ease; padding:14px; z-index:5;}
  .sheet.on{transform:translateY(0)}
  .sheet h3{margin:0 0 8px; font-size:14px}
  .row{display:flex; gap:8px; flex-wrap:wrap;}
  .tag{padding:6px 10px; border-radius:999px; background:#131a23; color:var(--muted); font-size:12px; border:1px solid #1f2a38;}
  .close{float:right}
</style>
</head>
<body>
  <div id="stage">
    <canvas id="cv"></canvas>

    <!-- top-left: info + now; top-right: play + compass -->
    <div class="hud-top">
      <div style="display:flex;gap:8px">
        <button id="infoBtn" class="btn" title="Details">i</button>
        <button id="nowBtn"  class="btn" title="Jump to current time">Now</button>
      </div>
      <div style="display:flex;gap:8px">
        <button id="playBtn"    class="btn" title="Play/Pause">Play</button>
        <button id="compassBtn" class="btn" title="Enable location & orientation">ðŸ§­</button>
      </div>
    </div>

    <!-- full-width slider inside the viewport -->
    <div class="hud-bottom">
      <input id="timeSlider" class="timeline" type="range" min="0" max="100" step="1" />
    </div>
  </div>

  <!-- collapsible info -->
  <div id="sheet" class="sheet" aria-hidden="true">
    <button id="closeSheet" class="btn close">Close</button>
    <h3>Eclipse details (NASA/EclipseWise)</h3>
    <div id="when" style="margin:6px 0 12px; color:var(--muted)"></div>
    <div class="row" id="ticks"></div>
    <p style="color:var(--muted);margin-top:12px">Align the ðŸ§­ pointer to the gold arrow to face the Moon (Â± a few degrees).</p>
  </div>

<script>
(() => {
  // ===== Besselian polynomials (EclipseWise). TT baseline; Î”T applied. =====
  const poly = {
    t0TT: Date.parse("2025-09-07T18:00:00Z"),
    dTsec: 71.9,
    x:  [ 0.02402,  0.48791,  0.00019, -0.00001],
    y:  [-0.29632,  0.26398,  0.00016, -0.00000],
    d:  [ 0.10060, -0.00030, -0.00000,  0.00000],
    f1: [ 1.26901,  0.00040, -0.00000,  0.00000],
    f2: [ 0.73989,  0.00040, -0.00000,  0.00000],
    f3: [ 0.26935,  0.00011, -0.00000,  0.00000]
  };
  function evalPoly(c,t){ return ((c[3]||0)*t + (c[2]||0))*t*t + (c[1]||0)*t + c[0]; }
  function besselAtUTC(msUTC){
    const msTT = msUTC + poly.dTsec*1000;
    const t = (msTT - poly.t0TT)/3600000;
    const x = evalPoly(poly.x,t), y = evalPoly(poly.y,t);
    const f1 = evalPoly(poly.f1,t), f2 = evalPoly(poly.f2,t), sm = evalPoly(poly.f3,t);
    return { x, y, f1, f2, sm };
  }

  // ===== DOM =====
  const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
  const slider = document.getElementById('timeSlider');
  const playBtn = document.getElementById('playBtn');
  const nowBtn  = document.getElementById('nowBtn');
  const infoBtn = document.getElementById('infoBtn');
  const sheet = document.getElementById('sheet');
  const closeSheet = document.getElementById('closeSheet');
  const ticksBox = document.getElementById('ticks');
  const when = document.getElementById('when');
  const compassBtn = document.getElementById('compassBtn');

  // Contacts (UTC) for sheet
  const contacts = [
    { k:"P1", t:"2025-09-07T15:28:06Z" },
    { k:"U1", t:"2025-09-07T16:26:51Z" },
    { k:"U2", t:"2025-09-07T17:30:36Z" },
    { k:"GE", t:"2025-09-07T18:11:46Z" },
    { k:"U3", t:"2025-09-07T18:53:18Z" },
    { k:"U4", t:"2025-09-07T19:56:53Z" },
    { k:"P4", t:"2025-09-07T20:55:27Z" },
  ].map(o=>({k:o.k, ms:Date.parse(o.t)}));
  const T0 = contacts[0].ms, T1 = contacts[contacts.length-1].ms;

  const fmtLocal = ms => new Date(ms).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', timeZoneName:'short'});
  when.textContent = `Local window: ${fmtLocal(T0)} â€” ${fmtLocal(T1)}`;
  for (const c of contacts){ const el=document.createElement('span'); el.className='tag'; el.textContent=`${c.k} ${fmtLocal(c.ms)}`; ticksBox.appendChild(el); }

  // Slider setup
  slider.min = T0; slider.max = T1; slider.step = 1000;
  slider.value = clamp(Date.now(), T0, T1);

  // ===== Compass (topocentric Moon; phone heading) =====
  const rad=Math.PI/180, dayMs=86400000;
  const obs = { lat:50.0755, lon:14.4378 };
  let deviceHeading=null, moonBearing=null, moonAlt=null, alignedPrev=false;

  function toJulian(d){ return d.valueOf()/dayMs - 0.5 + 2440588; }
  function toDays(d){ return toJulian(d) - 2451545; }
  function rightAsc(l,b){ const e=23.4397*rad; return Math.atan2(Math.sin(l)*Math.cos(e)-Math.tan(b)*Math.sin(e), Math.cos(l)); }
  function decl(l,b){ const e=23.4397*rad; return Math.asin(Math.sin(b)*Math.cos(e)+Math.cos(b)*Math.sin(e)*Math.sin(l)); }
  function sidereal(D,lw){ return rad*(280.16 + 360.9856235*D) - lw; }
  function moonCoords(D){
    const L=rad*(218.316+13.176396*D), M=rad*(134.963+13.064993*D), F=rad*(93.272+13.229350*D);
    const l=L + rad*6.289*Math.sin(M), b=rad*5.128*Math.sin(F), dist=385001 - 20905*Math.cos(M);
    return { ra:rightAsc(l,b), dec:decl(l,b), dist };
  }
  function getMoonPos(date, lat, lon){
    const D=toDays(date), lw=-lon*rad, Ï†=lat*rad, c=moonCoords(D), H=sidereal(D,lw)-c.ra;
    let h=Math.asin(Math.sin(Ï†)*Math.sin(c.dec)+Math.cos(Ï†)*Math.cos(c.dec)*Math.cos(H));
    const az=Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(Ï†)-Math.tan(c.dec)*Math.cos(Ï†));
    const hp=Math.asin(1/(c.dist/6371)); h=h-hp*Math.cos(h);
    return { alt:h, az };
  }
  function azToBearing(az){ let b=(az+Math.PI)*180/Math.PI; b%=360; if(b<0)b+=360; return b; }
  function angDiff(a,b){ let d=Math.abs(a-b)%360; return d>180?360-d:d; }

  // ======= Event bindings BEFORE first paint =======
  slider.addEventListener('input', ()=> updateForTime(Number(slider.value)));
  nowBtn.addEventListener('click', ()=>{ slider.value=clamp(Date.now(),T0,T1); updateForTime(Number(slider.value)); });
  let playing=false; playBtn.addEventListener('click', ()=>{ playing=!playing; playBtn.textContent=playing?'Pause':'Play'; });
  infoBtn.addEventListener('click', ()=>{ sheet.classList.add('on'); sheet.setAttribute('aria-hidden','false'); });
  closeSheet.addEventListener('click', ()=>{ sheet.classList.remove('on'); sheet.setAttribute('aria-hidden','true'); });
  compassBtn.addEventListener('click', enableCompass);

  function enableCompass(){
    if (navigator.geolocation){
      navigator.geolocation.getCurrentPosition(p=>{ obs.lat=p.coords.latitude; obs.lon=p.coords.longitude; }, ()=>{});
    }
    function onDO(e){
      let h=null;
      if (typeof e.webkitCompassHeading==='number') h=e.webkitCompassHeading;
      else if (typeof e.alpha==='number'){
        h = 360 - e.alpha;
        const ang=(screen.orientation && typeof screen.orientation.angle==='number')?screen.orientation.angle:(window.orientation||0);
        h=(h+ang)%360;
      }
      if (h!=null && isFinite(h)) deviceHeading=(h%360+360)%360;
    }
    if (window.DeviceOrientationEvent){
      if (typeof DeviceOrientationEvent.requestPermission==='function'){
        DeviceOrientationEvent.requestPermission().then(state=>{
          if (state==='granted') window.addEventListener('deviceorientation', onDO, true);
        }).catch(()=>{});
      } else {
        window.addEventListener('deviceorientation', onDO, true);
      }
    }
  }

  // ===== Layout + render (guard against zero size) =====
  function resize(){
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    const w = cv.clientWidth|0, h = cv.clientHeight|0;
    if (!w || !h) { requestAnimationFrame(resize); return; } // wait for layout
    cv.width = Math.round(w*dpr); cv.height = Math.round(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    draw(Number(slider.value));
  }
  window.addEventListener('resize', resize, {passive:true});
  requestAnimationFrame(resize); // defer first paint until layout is real

  // ===== Animation loop =====
  let last=performance.now(), RATE=120; // sec simulated per sec real
  function loop(now){
    if (playing){
      const dt=(now-last)/1000; let v=Number(slider.value)+dt*1000*RATE; if (v>T1) v=T0; slider.value=v;
    }
    last=now;
    updateForTime(Number(slider.value));
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // ===== Draw (guard against zero size) =====
  function draw(msUTC){
    const W=cv.clientWidth|0, H=cv.clientHeight|0;
    if (!W || !H) return; // bail until we have size

    const cx=W/2, cy=H/2;
    const Rpx = Math.max(1, Math.min(W,H)*0.28); // never 0

    // Besselian â†’ Moon-radii units
    const B = besselAtUTC(msUTC);
    const toMR = 1 / B.sm;
    const penR = B.f1 * toMR;
    const umbR = B.f2 * toMR;
    const vx   =  B.x * toMR;
    const vy   = -B.y * toMR; // y north+, canvas y down

    // Clear
    ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

    // Moon
    ctx.save(); ctx.translate(cx,cy);
    const g=ctx.createRadialGradient(-Rpx*0.25,-Rpx*0.25,Math.max(1,Rpx*0.2), 0,0,Rpx);
    g.addColorStop(0, getCSS('--moon-hi')); g.addColorStop(1, getCSS('--moon-lo'));
    ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();

    // Clip to Moon
    ctx.save(); ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.clip();

    // Shadows (physically sized)
    ctx.save(); ctx.scale(Rpx,Rpx); // units: Moon radii
    ctx.beginPath(); ctx.arc(vx,vy,penR,0,Math.PI*2);
    ctx.fillStyle=getCSS('--pen-fill'); ctx.fill();
    ctx.lineWidth=1/Rpx; ctx.strokeStyle=getCSS('--ring'); ctx.stroke();

    ctx.beginPath(); ctx.arc(vx,vy,umbR,0,Math.PI*2);
    ctx.fillStyle=getCSS('--umb-fill'); ctx.fill();
    ctx.lineWidth=1.25/Rpx; ctx.strokeStyle=getCSS('--ring'); ctx.stroke();
    ctx.restore(); // units

    ctx.restore(); // unclip
    ctx.restore(); // translate

    // Compass
    drawCompass(cx,cy,Math.min(W,H)*0.12);
  }

  function drawCompass(cx,cy,r){
    const ring=r, inner=r*0.62;
    ctx.save(); ctx.translate(cx,cy);

    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.2)';
    ctx.beginPath(); ctx.arc(0,0, ring, 0, Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(0,0, inner, 0, Math.PI*2); ctx.stroke();

    ctx.fillStyle='rgba(255,255,255,.8)'; ctx.font='600 11px system-ui,-apple-system,Segoe UI';
    [['N',0],['E',90],['S',180],['W',270]].forEach(([t,deg])=>{
      const a=(deg-90)*rad, tx=Math.cos(a)*(ring+10), ty=Math.sin(a)*(ring+10);
      ctx.fillText(t, tx-4, ty+4);
    });

    if (deviceHeading!=null){
      const a=(deviceHeading-90)*rad;
      ctx.save(); ctx.rotate(a);
      ctx.beginPath(); ctx.moveTo(inner*0.2,0); ctx.lineTo(ring*0.95,0);
      ctx.strokeStyle='rgba(90,200,250,.95)'; ctx.lineWidth=3; ctx.stroke();
      ctx.beginPath(); ctx.moveTo(ring*0.95,0); ctx.lineTo(ring*0.78,-6); ctx.lineTo(ring*0.78,6); ctx.closePath();
      ctx.fillStyle='rgba(90,200,250,.95)'; ctx.fill();
      ctx.restore();
    }

    if (moonBearing!=null){
      const a=(moonBearing-90)*rad; ctx.save(); ctx.rotate(a);
      ctx.beginPath(); ctx.moveTo(inner*0.1,0); ctx.lineTo(inner*0.1,-5); ctx.lineTo(ring*0.86,0); ctx.lineTo(inner*0.1,5); ctx.closePath();
      ctx.fillStyle = (moonAlt!=null && moonAlt>0) ? 'rgba(255,220,140,.98)' : 'rgba(180,180,180,.85)';
      ctx.fill(); ctx.restore();
    }

    if (deviceHeading!=null && moonBearing!=null){
      const diff=angDiff(deviceHeading,moonBearing);
      if (diff<=10){
        ctx.beginPath(); ctx.arc(0,0, ring+6, 0, Math.PI*2);
        ctx.strokeStyle='rgba(90,200,250,.8)'; ctx.lineWidth=4; ctx.stroke();
        if (!alignedPrev && 'vibrate' in navigator) navigator.vibrate(20);
        alignedPrev=true;
      } else alignedPrev=false;
    }

    ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2);
    ctx.fillStyle='rgba(255,255,255,.9)'; ctx.fill();
    ctx.restore();
  }

  // ===== Update + helpers =====
  function updateForTime(ms){
    const pos = getMoonPos(new Date(ms), obs.lat, obs.lon);
    moonAlt = pos.alt*180/Math.PI;
    moonBearing = azToBearing(pos.az);
    draw(ms);
  }
  function getCSS(name){ return getComputedStyle(document.documentElement).getPropertyValue(name).trim(); }
  function clamp(v,a,b){ return Math.min(Math.max(v,a),b); }

  // Animation driver
  let last=performance.now(), RATE=120;
  function loop(now){
    // playing state handled in event binding above
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

})();
</script>
</body>
</html>