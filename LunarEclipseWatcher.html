<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Lunar Eclipse — Local-View Correct (Besselian + Parallactic + Live Compass)</title>
<style>
  :root{
    --bg:#000; --fg:#e8eef5; --muted:#9aa1ad;
    --moon-hi:#dddddd; --moon-lo:#bfc3c8;
    --ring:rgba(255,255,255,.22);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--fg);
    font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial; overflow:hidden;}
  #stage{position:relative; width:100vw; height:min(100svh,100vh);
    display:flex; align-items:center; justify-content:center;}
  #cv{width:92vmin; height:92vmin; display:block; border-radius:12px;}
  .hud-top{position:absolute; top:calc(env(safe-area-inset-top,0px) + 10px); left:10px; right:10px;
    display:flex; justify-content:space-between; gap:8px; z-index:3;}
  .btn{-webkit-tap-highlight-color:transparent; border:1px solid #293242; background:#12161d; color:var(--fg);
    padding:8px 12px; border-radius:10px; font-weight:600; cursor:pointer;}
  .btn:active{transform:translateY(1px)}
  .bottom-ui{position:absolute; left:calc(env(safe-area-inset-left,0px) + 10px);
    right:calc(env(safe-area-inset-right,0px) + 10px);
    bottom:calc(env(safe-area-inset-bottom,0px) + 10px);
    display:flex; flex-direction:column; gap:6px; align-items:stretch; z-index:3;}
  .time{text-align:center; color:var(--fg); font-weight:600;
    padding:6px 10px; border-radius:10px; background:rgba(18,22,29,.75);
    border:1px solid #2a3445; backdrop-filter:saturate(120%) blur(6px);}
  .timeline{appearance:none; width:100%; height:36px; margin:0; padding:0 2px; background:transparent;}
  .timeline::-webkit-slider-runnable-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-moz-range-track{height:4px; background:#263041; border-radius:999px;}
  .timeline::-webkit-slider-thumb{-webkit-appearance:none; width:24px; height:24px; margin-top:-10px; border-radius:50%;
    background:#e6eef8; border:0;}
  .timeline::-moz-range-thumb{width:24px; height:24px; border:0; border-radius:50%; background:#e6eef8;}
  #err{position:absolute; top:8px; left:8px; padding:4px 8px; border-radius:8px; font-size:12px;
    background:#3b1e1e; color:#ffd4d4; border:1px solid #592b2b; display:none; z-index:9;}
</style>
</head>
<body>
  <div id="stage">
    <canvas id="cv"></canvas>

    <div id="err"></div>

    <div class="hud-top">
      <div style="display:flex;gap:8px">
        <button id="nowBtn"  class="btn">Now</button>
        <button id="playBtn" class="btn">Play</button>
      </div>
      <div><button id="compassBtn" class="btn" title="Enable live heading">🧭 Turn-to-Moon</button></div>
    </div>

    <div class="bottom-ui">
      <div id="timeLabel" class="time">—</div>
      <input id="timeSlider" class="timeline" type="range" min="0" max="100" step="1" />
    </div>
  </div>

<script>
(()=>{
// ---------------- tiny error badge ----------------
const badge = document.getElementById('err');
function showErr(m){ badge.textContent=m; badge.style.display='inline-block'; console.error(m); }

// =================== Besselian polynomials (TT baseline) ===================
const poly = {
  t0TT: Date.parse("2025-09-07T18:00:00Z"),
  dTsec: 71.9, // TT-UTC
  // x,y,d,f1(pen),f2(umb),f3(Moon semidiam) [degrees on sky]; x east+, y north+
  x:[ 0.02402,  0.48791,  0.00019, -0.00001],
  y:[-0.29632,  0.26398,  0.00016, -0.00000],
  d:[ 0.10060, -0.00030, -0.00000,  0.00000],
  f1:[ 1.26901,  0.00040, -0.00000,  0.00000],
  f2:[ 0.73989,  0.00040, -0.00000,  0.00000],
  f3:[ 0.26935,  0.00011, -0.00000,  0.00000]
};
function evalPoly(c,t){ return ((c[3]||0)*t + (c[2]||0))*t*t + (c[1]||0)*t + c[0]; }
function besselAtUTC(msUTC){
  const msTT = msUTC + poly.dTsec*1000;
  const t = (msTT - poly.t0TT)/3600000; // hours from t0 (TT)
  const x=evalPoly(poly.x,t), y=evalPoly(poly.y,t);
  const f1=evalPoly(poly.f1,t), f2=evalPoly(poly.f2,t), sm=evalPoly(poly.f3,t);
  return { x, y, f1, f2, sm };
}

// =================== Contacts (UTC) ===================
const contacts = [
  { k:"P1", ms:Date.parse("2025-09-07T15:28:06Z") },
  { k:"U1", ms:Date.parse("2025-09-07T16:26:51Z") },
  { k:"U2", ms:Date.parse("2025-09-07T17:30:36Z") },
  { k:"GE", ms:Date.parse("2025-09-07T18:11:46Z") },
  { k:"U3", ms:Date.parse("2025-09-07T18:53:18Z") },
  { k:"U4", ms:Date.parse("2025-09-07T19:56:53Z") },
  { k:"P4", ms:Date.parse("2025-09-07T20:55:27Z") },
];
const T0=contacts[0].ms, T1=contacts[contacts.length-1].ms;

// =================== DOM ===================
const cv = document.getElementById('cv'), ctx = cv.getContext('2d');
const slider = document.getElementById('timeSlider');
const playBtn = document.getElementById('playBtn');
const nowBtn  = document.getElementById('nowBtn');
const compassBtn = document.getElementById('compassBtn');
const timeLabel = document.getElementById('timeLabel');

slider.min=T0; slider.max=T1; slider.step=1000; slider.value=clamp(Date.now(),T0,T1);

// =================== Topocentric Moon + parallactic angle ===================
const rad=Math.PI/180, dayMs=86400000;
const obs={lat:50.0755, lon:14.4378}; // default Prague; geoloc will overwrite
let deviceHeading=null, moonBearing=null, moonAlt=null, parAng=0;
let aligned=false, linkToNow=false;

function toJulian(d){return d.valueOf()/dayMs - 0.5 + 2440588;}
function toDays(d){return toJulian(d) - 2451545;}
function rightAsc(l,b){ const e=23.4397*rad; return Math.atan2(Math.sin(l)*Math.cos(e)-Math.tan(b)*Math.sin(e), Math.cos(l)); }
function decl(l,b){ const e=23.4397*rad; return Math.asin(Math.sin(b)*Math.cos(e)+Math.cos(b)*Math.sin(e)*Math.sin(l)); }
function sidereal(D,lw){return rad*(280.16 + 360.9856235*D) - lw;}
function moonCoords(D){
  const L=rad*(218.316+13.176396*D), M=rad*(134.963+13.064993*D), F=rad*(93.272+13.229350*D);
  const l=L + rad*6.289*Math.sin(M), b=rad*5.128*Math.sin(F), dist=385001 - 20905*Math.cos(M);
  return { ra:rightAsc(l,b), dec:decl(l,b), dist };
}
function getMoonPosAndEqu(date, lat, lon){
  const D=toDays(date), lw=-lon*rad, φ=lat*rad, c=moonCoords(D), H=sidereal(D,lw)-c.ra;
  let h=Math.asin(Math.sin(φ)*Math.sin(c.dec)+Math.cos(φ)*Math.cos(c.dec)*Math.cos(H));
  const az=Math.atan2(Math.sin(H), Math.cos(H)*Math.sin(φ)-Math.tan(c.dec)*Math.cos(φ));
  const hp=Math.asin(1/(c.dist/6371)); h=h-hp*Math.cos(h); // parallax approx
  // parallactic angle: angle from celestial North to local Up at the Moon (eastward positive)
  const q = Math.atan2(Math.sin(H), Math.tan(φ)*Math.cos(c.dec) - Math.sin(c.dec)*Math.cos(H));
  return { alt:h, az, H, dec:c.dec, q };
}
function azToBearing(az){ let b=(az+Math.PI)*180/Math.PI; b%=360; if(b<0)b+=360; return b; }
function normDeg(a){ a%=360; if(a<0)a+=360; return a; }

// =================== EVENTS (bind FIRST) ===================
let playing=false;
slider.addEventListener('input', ()=>{ linkToNow=false; safeUpdate(Number(slider.value)); });
nowBtn.addEventListener('click', ()=>{ linkToNow=true; safeUpdate(clamp(Date.now(),T0,T1)); });
playBtn.addEventListener('click', ()=>{ playing=!playing; linkToNow=false; playBtn.textContent=playing?'Pause':'Play'; });

compassBtn.addEventListener('click', ()=>{
  if (navigator.geolocation){
    navigator.geolocation.getCurrentPosition(p=>{obs.lat=p.coords.latitude; obs.lon=p.coords.longitude;}, ()=>{});
  }
  function onDO(e){
    let h=null;
    if (typeof e.webkitCompassHeading==='number') h=e.webkitCompassHeading; // iOS true-north
    else if (typeof e.alpha==='number'){
      h = 360 - e.alpha; // CW from device-top to geomagnetic north
      const ang=(screen.orientation && typeof screen.orientation.angle==='number')?screen.orientation.angle:(window.orientation||0);
      h = (h + ang);
    }
    if (h!=null && isFinite(h)){ deviceHeading=normDeg(h); safeUpdate(Number(slider.value)); }
  }
  const type=('ondeviceorientationabsolute' in window)?'deviceorientationabsolute':'deviceorientation';
  if (window.DeviceOrientationEvent){
    if (typeof DeviceOrientationEvent.requestPermission==='function'){
      DeviceOrientationEvent.requestPermission().then(s=>{ if(s==='granted') window.addEventListener(type,onDO,true); }).catch(()=>{});
    } else window.addEventListener(type,onDO,true);
  }
});

// =================== LAYOUT (guards) ===================
let compassCenter={x:0,y:0,r:0};
function cacheCompassPlacement(){
  const W=cv.clientWidth|0, H=cv.clientHeight|0; if(!W||!H) return;
  const compR=Math.min(W,H)*0.095;
  const canvasRect=cv.getBoundingClientRect(), sliderRect=slider.getBoundingClientRect();
  const sliderTopInCanvas=sliderRect.top - canvasRect.top;
  const cy=Math.min(H-16-compR, Math.max(compR+16, sliderTopInCanvas - 10 - compR));
  compassCenter={x:W/2, y:cy, r:compR};
}
function resize(){
  try{
    const dpr=Math.max(1,window.devicePixelRatio||1);
    const w=cv.clientWidth|0, h=cv.clientHeight|0;
    if(!w||!h){ requestAnimationFrame(resize); return; }
    cv.width=Math.round(w*dpr); cv.height=Math.round(h*dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
    cacheCompassPlacement();
    safeUpdate(Number(slider.value));
  }catch(e){ showErr('resize:'+e.message); }
}
window.addEventListener('resize', resize, {passive:true});
requestAnimationFrame(resize);

// =================== RAF LOOP ===================
let last=performance.now(), RATE=120; // simulated seconds / real second
function loop(now){
  try{
    const nowMs=Date.now();
    if (linkToNow){
      const v=clamp(nowMs,T0,T1);
      if(Math.abs(v-Number(slider.value))>250) slider.value=v;
      safeUpdate(v);
    } else if (playing){
      const dt=(now-last)/1000; let v=Number(slider.value)+dt*1000*RATE; if(v>T1) v=T0;
      slider.value=v; safeUpdate(v);
    }
    last=now;
  }catch(e){ showErr('loop:'+e.message); }
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// =================== UPDATE + DRAW ===================
function safeUpdate(ms){ try{ updateForTime(ms); }catch(e){ showErr('update:'+e.message); } }
function updateForTime(ms){
  const p = getMoonPosAndEqu(new Date(ms), obs.lat, obs.lon);
  moonAlt = p.alt*180/Math.PI;
  moonBearing = azToBearing(p.az);
  parAng = p.q; // radians — rotate shadow from N/E to local Up/Right
  const isNow=linkToNow && !playing;
  const txt=new Date(ms).toLocaleString([], {weekday:'short', hour:'2-digit', minute:'2-digit', second:'2-digit', timeZoneName:'short'});
  timeLabel.textContent=(playing?'Sim ': (isNow?'Now ':'Sim ')) + txt;
  safeDraw(ms);
}
function safeDraw(ms){ try{ draw(ms); }catch(e){ showErr('draw:'+e.message); } }

// Core draw: rotate Besselian x,y by -parallactic so “up” = zenith
function draw(msUTC){
  const W=cv.clientWidth|0, H=cv.clientHeight|0; if(!W||!H) return;

  const cx=W/2, cy=H/2;
  const Rpx=Math.max(1, Math.min(W,H)*0.28);

  // Besselian → Moon radii
  const B=besselAtUTC(msUTC);
  const toMR=1/Math.max(1e-6,B.sm);
  // start in equatorial components with east→right, north→up
  const xe =  B.x*toMR;   // east (right on screen before rotation)
  const yn =  B.y*toMR;   // north (up before rotation)
  // rotate coordinates by -parAng to align north→up(zenith)
  const cq=Math.cos(parAng), sq=Math.sin(parAng);
  const x_loc =  xe*cq + yn*sq;
  const y_loc = -xe*sq + yn*cq;
  // map to canvas: +x right, +y down
  const vx = x_loc;
  const vy = -y_loc;

  const penR=B.f1*toMR, umbR=B.f2*toMR;

  // Clear
  ctx.fillStyle='#000'; ctx.fillRect(0,0,W,H);

  // 1) Background shadow (unclipped): visible before contact
  ctx.save(); ctx.translate(cx,cy); ctx.scale(Rpx,Rpx);
  drawConcentricShadow(vx,vy,umbR,penR,'background');
  ctx.restore();

  // 2) Moon base
  ctx.save(); ctx.translate(cx,cy);
  const g = ctx.createRadialGradient(-Rpx*0.25,-Rpx*0.25,Math.max(1,Rpx*0.2), 0,0,Rpx);
  g.addColorStop(0, getCSS('--moon-hi')); g.addColorStop(1, getCSS('--moon-lo'));
  ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.fillStyle=g; ctx.fill();

  // 3) Shadow on Moon (clip + multiply) — this is the actual overlap/colouring
  ctx.save(); ctx.beginPath(); ctx.arc(0,0,Rpx,0,Math.PI*2); ctx.clip();
  ctx.globalCompositeOperation='multiply';
  ctx.scale(Rpx,Rpx);
  drawConcentricShadow(vx,vy,umbR,penR,'onMoon');
  ctx.globalCompositeOperation='source-over';
  ctx.restore(); // unclip
  ctx.restore(); // moon

  // 4) Turn-to-Moon compass (below)
  drawTurnToMoon(compassCenter.x,compassCenter.y,compassCenter.r);
}

// ---- Concentric shadow (rings) ----
function drawConcentricShadow(cxR,cyR,umbR,penR,mode){
  const Npen=20, Numb=28;
  const k=(mode==='onMoon') ? {pen:0.45, umbCtr:0.92, umbEdg:0.40} : {pen:0.10, umbCtr:0.24, umbEdg:0.12};

  // penumbra: outer→inner
  for(let i=0;i<Npen;i++){
    const t0=i/Npen, t1=(i+1)/Npen;
    const r0=lerp(umbR,penR,t0), r1=lerp(umbR,penR,t1);
    const u=1 - t0; const a=k.pen*(u*u);
    ring(cxR,cyR,r1,r0,a,mode,false);
  }
  // umbra: center→edge
  for(let i=0;i<Numb;i++){
    const t0=i/Numb, t1=(i+1)/Numb;
    const r0=lerp(0,umbR,t0), r1=lerp(0,umbR,t1);
    const a=(mode==='onMoon') ? (k.umbCtr - (k.umbCtr-k.umbEdg)*Math.pow(t0,0.8))
                              : (k.umbCtr*0.3 + (k.umbEdg*0.7)*(1-t0));
    ring(cxR,cyR,r1,r0,a,mode,true);
  }

  if(mode==='background'){
    const s=1/Math.max(1, cv.clientWidth*0.28);
    ctx.lineWidth=s; ctx.strokeStyle=getCSS('--ring');
    ctx.beginPath(); ctx.arc(cxR,cyR,penR,0,Math.PI*2); ctx.stroke();
    ctx.beginPath(); ctx.arc(cxR,cyR,umbR,0,Math.PI*2); ctx.stroke();
  }
}
function ring(cxR,cyR,rOuter,rInner,alpha,mode,isUmbra){
  if(rOuter<=0||rOuter<=rInner) return;
  ctx.beginPath(); ctx.arc(cxR,cyR,rOuter,0,Math.PI*2);
  if(rInner>0) ctx.arc(cxR,cyR,rInner,0,Math.PI*2,true);
  ctx.fillStyle=(mode==='onMoon' && isUmbra) ? `rgba(130,40,30,${clamp(alpha,0,1)})`
                                             : `rgba(0,0,0,${clamp(alpha,0,1)})`;
  try{ ctx.fill('evenodd'); }catch(_){ ctx.fill(); }
}

// ---- Turn-to-Moon compass: single relative arrow (no north) ----
function drawTurnToMoon(cx,cy,r){
  if(!r) return;
  ctx.save(); ctx.translate(cx,cy);
  ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.2)';
  ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke();

  if(moonBearing!=null && deviceHeading!=null){
    const rel=normDeg(moonBearing - deviceHeading); // 0 = straight ahead
    const a=(rel-90)*rad;
    const inner=r*0.62;
    ctx.save(); ctx.rotate(a);
    ctx.beginPath(); ctx.moveTo(inner*0.1,0); ctx.lineTo(inner*0.1,-6);
    ctx.lineTo(r*0.88,0); ctx.lineTo(inner*0.1,6); ctx.closePath();
    ctx.fillStyle=(moonAlt!=null && moonAlt>0)?'rgba(255,220,140,.98)':'rgba(180,180,180,.85)';
    ctx.fill(); ctx.restore();

    const diff=rel<=180?rel:360-rel;
    const ok=diff<=8;
    if(ok){
      ctx.beginPath(); ctx.arc(0,0,r+6,0,Math.PI*2);
      ctx.strokeStyle='rgba(255,220,140,.85)'; ctx.lineWidth=4; ctx.stroke();
      if(!aligned && 'vibrate' in navigator) navigator.vibrate(20);
    }
    aligned=ok;
  } else {
    ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,.25)';
    ctx.beginPath(); ctx.moveTo(0,-r*0.62); ctx.lineTo(0,-r); ctx.stroke();
  }

  ctx.beginPath(); ctx.arc(0,0,4,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,.9)'; ctx.fill();
  ctx.restore();
}

// =================== Utils ===================
function lerp(a,b,t){return a+(b-a)*t;}
function getCSS(n){return getComputedStyle(document.documentElement).getPropertyValue(n).trim();}
function clamp(v,a,b){return Math.min(Math.max(v,a),b);}

})();
</script>
</body>
</html>